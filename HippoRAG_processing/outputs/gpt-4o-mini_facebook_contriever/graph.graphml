<?xml version="1.0" encoding="UTF-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
         http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
<!-- Created by igraph -->
  <key id="v_hash_id" for="node" attr.name="hash_id" attr.type="string"/>
  <key id="v_content" for="node" attr.name="content" attr.type="string"/>
  <key id="v_name" for="node" attr.name="name" attr.type="string"/>
  <key id="v_id" for="node" attr.name="id" attr.type="string"/>
  <key id="e_weight" for="edge" attr.name="weight" attr.type="double"/>
  <graph id="G" edgedefault="undirected">
    <node id="n0">
      <data key="v_hash_id">entity-8c4205ec33d8f6caeaaaa0c10a14138c</data>
      <data key="v_content">adrian</data>
      <data key="v_name">entity-8c4205ec33d8f6caeaaaa0c10a14138c</data>
      <data key="v_id">n0</data>
    </node>
    <node id="n1">
      <data key="v_hash_id">entity-4921c0e2d1f6005abe1f9ec2e2041909</data>
      <data key="v_content">ai</data>
      <data key="v_name">entity-4921c0e2d1f6005abe1f9ec2e2041909</data>
      <data key="v_id">n1</data>
    </node>
    <node id="n2">
      <data key="v_hash_id">entity-9e0ca26184493ce6305aebff06cbd959</data>
      <data key="v_content">associative container</data>
      <data key="v_name">entity-9e0ca26184493ce6305aebff06cbd959</data>
      <data key="v_id">n2</data>
    </node>
    <node id="n3">
      <data key="v_hash_id">entity-82855eee5f4345a2186397736175aa43</data>
      <data key="v_content">autograder</data>
      <data key="v_name">entity-82855eee5f4345a2186397736175aa43</data>
      <data key="v_id">n3</data>
    </node>
    <node id="n4">
      <data key="v_hash_id">entity-4d6c4d6b5b6c7fd2c43727ce32a56f4e</data>
      <data key="v_content">barbara</data>
      <data key="v_name">entity-4d6c4d6b5b6c7fd2c43727ce32a56f4e</data>
      <data key="v_id">n4</data>
    </node>
    <node id="n5">
      <data key="v_hash_id">entity-393236a7f5f26444612b9d0e8bc7035e</data>
      <data key="v_content">binary search trees and maps</data>
      <data key="v_name">entity-393236a7f5f26444612b9d0e8bc7035e</data>
      <data key="v_id">n5</data>
    </node>
    <node id="n6">
      <data key="v_hash_id">entity-07b0c8f80e5beec91832382ff5268d6d</data>
      <data key="v_content">binarysearchtree</data>
      <data key="v_name">entity-07b0c8f80e5beec91832382ff5268d6d</data>
      <data key="v_id">n6</data>
    </node>
    <node id="n7">
      <data key="v_hash_id">entity-4a8a08f09d37b73795649038408b5f33</data>
      <data key="v_content">c</data>
      <data key="v_name">entity-4a8a08f09d37b73795649038408b5f33</data>
      <data key="v_id">n7</data>
    </node>
    <node id="n8">
      <data key="v_hash_id">entity-e9ed3822a50df996263f82270487b0ad</data>
      <data key="v_content">c   projects</data>
      <data key="v_name">entity-e9ed3822a50df996263f82270487b0ad</data>
      <data key="v_id">n8</data>
    </node>
    <node id="n9">
      <data key="v_hash_id">entity-5dd2199ad68327cc76d583b057aee7d5</data>
      <data key="v_content">card</data>
      <data key="v_name">entity-5dd2199ad68327cc76d583b057aee7d5</data>
      <data key="v_id">n9</data>
    </node>
    <node id="n10">
      <data key="v_hash_id">entity-b12f65ccb8ef918bc542b96fceeb7c07</data>
      <data key="v_content">card cpp</data>
      <data key="v_name">entity-b12f65ccb8ef918bc542b96fceeb7c07</data>
      <data key="v_id">n10</data>
    </node>
    <node id="n11">
      <data key="v_hash_id">entity-010f2810d41b13de23cd4e4e9afd0dc9</data>
      <data key="v_content">card hpp</data>
      <data key="v_name">entity-010f2810d41b13de23cd4e4e9afd0dc9</data>
      <data key="v_id">n11</data>
    </node>
    <node id="n12">
      <data key="v_hash_id">entity-5edd3c4a9bae214368161a5802342bfb</data>
      <data key="v_content">card tests cpp</data>
      <data key="v_name">entity-5edd3c4a9bae214368161a5802342bfb</data>
      <data key="v_id">n12</data>
    </node>
    <node id="n13">
      <data key="v_hash_id">entity-14957ea89617381d6a37d01dc5d74e40</data>
      <data key="v_content">cats csv</data>
      <data key="v_name">entity-14957ea89617381d6a37d01dc5d74e40</data>
      <data key="v_id">n13</data>
    </node>
    <node id="n14">
      <data key="v_hash_id">entity-e387118aa24c46c31e79664939d6ee1d</data>
      <data key="v_content">cats out correct</data>
      <data key="v_name">entity-e387118aa24c46c31e79664939d6ee1d</data>
      <data key="v_id">n14</data>
    </node>
    <node id="n15">
      <data key="v_hash_id">entity-8ffd3c9a78a5430cb11e1761392460b2</data>
      <data key="v_content">chi chih</data>
      <data key="v_name">entity-8ffd3c9a78a5430cb11e1761392460b2</data>
      <data key="v_id">n15</data>
    </node>
    <node id="n16">
      <data key="v_hash_id">entity-08dd5c33e894e4b12a4ce9e4cd870cdd</data>
      <data key="v_content">classifier</data>
      <data key="v_name">entity-08dd5c33e894e4b12a4ce9e4cd870cdd</data>
      <data key="v_id">n16</data>
    </node>
    <node id="n17">
      <data key="v_hash_id">entity-6b1d6198fa690a31496c6dfb40bee0e2</data>
      <data key="v_content">crabster ppm</data>
      <data key="v_name">entity-6b1d6198fa690a31496c6dfb40bee0e2</data>
      <data key="v_id">n17</data>
    </node>
    <node id="n18">
      <data key="v_hash_id">entity-5c4cb3eaaf9d2526d8c4aeb5d8883a07</data>
      <data key="v_content">csvstream hpp</data>
      <data key="v_name">entity-5c4cb3eaaf9d2526d8c4aeb5d8883a07</data>
      <data key="v_id">n18</data>
    </node>
    <node id="n19">
      <data key="v_hash_id">entity-15c8de14af8e7f0726cf6fcecaee965d</data>
      <data key="v_content">current row and column</data>
      <data key="v_name">entity-15c8de14af8e7f0726cf6fcecaee965d</data>
      <data key="v_id">n19</data>
    </node>
    <node id="n20">
      <data key="v_hash_id">entity-26837a280ecc1225ad8c5aea5e444221</data>
      <data key="v_content">dabbala</data>
      <data key="v_name">entity-26837a280ecc1225ad8c5aea5e444221</data>
      <data key="v_id">n20</data>
    </node>
    <node id="n21">
      <data key="v_hash_id">entity-d22ef1ea1e9d6ee933e6b90a26e72735</data>
      <data key="v_content">december 9  2024</data>
      <data key="v_name">entity-d22ef1ea1e9d6ee933e6b90a26e72735</data>
      <data key="v_id">n21</data>
    </node>
    <node id="n22">
      <data key="v_hash_id">entity-dfc9ab572988259f8035ae23a9a8e436</data>
      <data key="v_content">dog ppm</data>
      <data key="v_name">entity-dfc9ab572988259f8035ae23a9a8e436</data>
      <data key="v_id">n22</data>
    </node>
    <node id="n23">
      <data key="v_hash_id">entity-7aa23492064a9e2a97a6f8887659ec87</data>
      <data key="v_content">e0</data>
      <data key="v_name">entity-7aa23492064a9e2a97a6f8887659ec87</data>
      <data key="v_id">n23</data>
    </node>
    <node id="n24">
      <data key="v_hash_id">entity-fca9b5b9e65393f1a171c7f95429ffd8</data>
      <data key="v_content">editable sequence of characters</data>
      <data key="v_name">entity-fca9b5b9e65393f1a171c7f95429ffd8</data>
      <data key="v_id">n24</data>
    </node>
    <node id="n25">
      <data key="v_hash_id">entity-df7dbf3c2e9a486ad8f1607bc3a0e32c</data>
      <data key="v_content">eecs 280</data>
      <data key="v_name">entity-df7dbf3c2e9a486ad8f1607bc3a0e32c</data>
      <data key="v_id">n25</data>
    </node>
    <node id="n26">
      <data key="v_hash_id">entity-762d19ab5586dc0c1c36f2588ffbc892</data>
      <data key="v_content">emacs</data>
      <data key="v_name">entity-762d19ab5586dc0c1c36f2588ffbc892</data>
      <data key="v_id">n26</data>
    </node>
    <node id="n27">
      <data key="v_hash_id">entity-0db92403f3bede730b5b9e3358bb9b16</data>
      <data key="v_content">euchre</data>
      <data key="v_name">entity-0db92403f3bede730b5b9e3358bb9b16</data>
      <data key="v_id">n27</data>
    </node>
    <node id="n28">
      <data key="v_hash_id">entity-f085197fdf1fa446e14a55e6b64b3357</data>
      <data key="v_content">euchre cpp</data>
      <data key="v_name">entity-f085197fdf1fa446e14a55e6b64b3357</data>
      <data key="v_id">n28</data>
    </node>
    <node id="n29">
      <data key="v_hash_id">entity-631e7765429a1c616b07551dd16612a7</data>
      <data key="v_content">euchre game</data>
      <data key="v_name">entity-631e7765429a1c616b07551dd16612a7</data>
      <data key="v_id">n29</data>
    </node>
    <node id="n30">
      <data key="v_hash_id">entity-c38d53f632f151d289d59d89f0bdcde7</data>
      <data key="v_content">fall 2024</data>
      <data key="v_name">entity-c38d53f632f151d289d59d89f0bdcde7</data>
      <data key="v_id">n30</data>
    </node>
    <node id="n31">
      <data key="v_hash_id">entity-7c8452f3cfe67beafd51026b340ebff1</data>
      <data key="v_content">february 12th  2025</data>
      <data key="v_name">entity-7c8452f3cfe67beafd51026b340ebff1</data>
      <data key="v_id">n31</data>
    </node>
    <node id="n32">
      <data key="v_hash_id">entity-89aab12eed0f20311eecceaed155b81c</data>
      <data key="v_content">february 24  2025</data>
      <data key="v_name">entity-89aab12eed0f20311eecceaed155b81c</data>
      <data key="v_id">n32</data>
    </node>
    <node id="n33">
      <data key="v_hash_id">entity-de06ed8dfc218126aa1bfbb9385f612e</data>
      <data key="v_content">femto</data>
      <data key="v_name">entity-de06ed8dfc218126aa1bfbb9385f612e</data>
      <data key="v_id">n33</data>
    </node>
    <node id="n34">
      <data key="v_hash_id">entity-c230444b1f8e0e21ce21e44a48bca14d</data>
      <data key="v_content">four players</data>
      <data key="v_name">entity-c230444b1f8e0e21ce21e44a48bca14d</data>
      <data key="v_id">n34</data>
    </node>
    <node id="n35">
      <data key="v_hash_id">entity-bf215181b5140522137b3d4f6b73544a</data>
      <data key="v_content">github</data>
      <data key="v_name">entity-bf215181b5140522137b3d4f6b73544a</data>
      <data key="v_id">n35</data>
    </node>
    <node id="n36">
      <data key="v_hash_id">entity-4fa42aa0ba652605cada43bca0fc6389</data>
      <data key="v_content">google drive</data>
      <data key="v_name">entity-4fa42aa0ba652605cada43bca0fc6389</data>
      <data key="v_id">n36</data>
    </node>
    <node id="n37">
      <data key="v_hash_id">entity-3989e92c2ba4625b54d0e847eabc6702</data>
      <data key="v_content">hcmst ver 3 04 tsv</data>
      <data key="v_name">entity-3989e92c2ba4625b54d0e847eabc6702</data>
      <data key="v_id">n37</data>
    </node>
    <node id="n38">
      <data key="v_hash_id">entity-9628fc2e0cc510d92af902e458eda36f</data>
      <data key="v_content">helper commands for building</data>
      <data key="v_name">entity-9628fc2e0cc510d92af902e458eda36f</data>
      <data key="v_id">n38</data>
    </node>
    <node id="n39">
      <data key="v_hash_id">entity-9719477824a79813e5991d2e01e13bcf</data>
      <data key="v_content">horses ppm</data>
      <data key="v_name">entity-9719477824a79813e5991d2e01e13bcf</data>
      <data key="v_id">n39</data>
    </node>
    <node id="n40">
      <data key="v_hash_id">entity-4101c114e91794049ea8ca182a1d3f87</data>
      <data key="v_content">how couples meet and stay together  hcmst</data>
      <data key="v_name">entity-4101c114e91794049ea8ca182a1d3f87</data>
      <data key="v_id">n40</data>
    </node>
    <node id="n41">
      <data key="v_hash_id">entity-99e9bae675b12967251c175696f00a70</data>
      <data key="v_content">human</data>
      <data key="v_name">entity-99e9bae675b12967251c175696f00a70</data>
      <data key="v_id">n41</data>
    </node>
    <node id="n42">
      <data key="v_hash_id">entity-2221de5c6a8af3552be19564ca3f6375</data>
      <data key="v_content">image processing</data>
      <data key="v_name">entity-2221de5c6a8af3552be19564ca3f6375</data>
      <data key="v_id">n42</data>
    </node>
    <node id="n43">
      <data key="v_hash_id">entity-2c42e5cf1cdbafea04ed267018ef1511</data>
      <data key="v_content">ivan</data>
      <data key="v_name">entity-2c42e5cf1cdbafea04ed267018ef1511</data>
      <data key="v_id">n43</data>
    </node>
    <node id="n44">
      <data key="v_hash_id">entity-ab4f3ccba74857c5f2ba0d5b7dbf65e1</data>
      <data key="v_content">jpeg</data>
      <data key="v_name">entity-ab4f3ccba74857c5f2ba0d5b7dbf65e1</data>
      <data key="v_id">n44</data>
    </node>
    <node id="n45">
      <data key="v_hash_id">entity-73f88293703b2f2bcacd8c415658b8a7</data>
      <data key="v_content">jpeg format</data>
      <data key="v_name">entity-73f88293703b2f2bcacd8c415658b8a7</data>
      <data key="v_id">n45</data>
    </node>
    <node id="n46">
      <data key="v_hash_id">entity-f71b127defcfaf5cb7008ee39051b515</data>
      <data key="v_content">judea</data>
      <data key="v_name">entity-f71b127defcfaf5cb7008ee39051b515</data>
      <data key="v_id">n46</data>
    </node>
    <node id="n47">
      <data key="v_hash_id">entity-77856facf8b496f2321dcb60c291dd1f</data>
      <data key="v_content">key compare</data>
      <data key="v_name">entity-77856facf8b496f2321dcb60c291dd1f</data>
      <data key="v_id">n47</data>
    </node>
    <node id="n48">
      <data key="v_hash_id">entity-f151bec110cbc7a268243c7aa05b6e6f</data>
      <data key="v_content">key type</data>
      <data key="v_name">entity-f151bec110cbc7a268243c7aa05b6e6f</data>
      <data key="v_id">n48</data>
    </node>
    <node id="n49">
      <data key="v_hash_id">entity-b6b17ec3280a7a6af00f85af26cbd4c2</data>
      <data key="v_content">kunle</data>
      <data key="v_name">entity-b6b17ec3280a7a6af00f85af26cbd4c2</data>
      <data key="v_id">n49</data>
    </node>
    <node id="n50">
      <data key="v_hash_id">entity-c1136bafabfa927efc1c88b00774fef5</data>
      <data key="v_content">libjpeg</data>
      <data key="v_name">entity-c1136bafabfa927efc1c88b00774fef5</data>
      <data key="v_id">n50</data>
    </node>
    <node id="n51">
      <data key="v_hash_id">entity-bebfefa98e4957b880173b2b2498b5a0</data>
      <data key="v_content">libjpeg turbo</data>
      <data key="v_name">entity-bebfefa98e4957b880173b2b2498b5a0</data>
      <data key="v_id">n51</data>
    </node>
    <node id="n52">
      <data key="v_hash_id">entity-86c13e2ad8f671bb60a30ad9b60238ee</data>
      <data key="v_content">liskov</data>
      <data key="v_name">entity-86c13e2ad8f671bb60a30ad9b60238ee</data>
      <data key="v_id">n52</data>
    </node>
    <node id="n53">
      <data key="v_hash_id">entity-10ae9fc7d453b0dd525d0edf2ede7961</data>
      <data key="v_content">list</data>
      <data key="v_name">entity-10ae9fc7d453b0dd525d0edf2ede7961</data>
      <data key="v_id">n53</data>
    </node>
    <node id="n54">
      <data key="v_hash_id">entity-cd5dbf3629c558b0104ba8f0937d6816</data>
      <data key="v_content">makefile</data>
      <data key="v_name">entity-cd5dbf3629c558b0104ba8f0937d6816</data>
      <data key="v_id">n54</data>
    </node>
    <node id="n55">
      <data key="v_hash_id">entity-1d78dc8ed51214e518b5114fe24490ae</data>
      <data key="v_content">map</data>
      <data key="v_name">entity-1d78dc8ed51214e518b5114fe24490ae</data>
      <data key="v_id">n55</data>
    </node>
    <node id="n56">
      <data key="v_hash_id">entity-002c7e17e29b7d357eba0b42f8608044</data>
      <data key="v_content">march 12  2025</data>
      <data key="v_name">entity-002c7e17e29b7d357eba0b42f8608044</data>
      <data key="v_id">n56</data>
    </node>
    <node id="n57">
      <data key="v_hash_id">entity-827cc2427465dbe841e44031b2a5007c</data>
      <data key="v_content">march 28  2024</data>
      <data key="v_name">entity-827cc2427465dbe841e44031b2a5007c</data>
      <data key="v_id">n57</data>
    </node>
    <node id="n58">
      <data key="v_hash_id">entity-21b72c0b7adc5c7b4a50ffcb90d92dd6</data>
      <data key="v_content">matrix</data>
      <data key="v_name">entity-21b72c0b7adc5c7b4a50ffcb90d92dd6</data>
      <data key="v_id">n58</data>
    </node>
    <node id="n59">
      <data key="v_hash_id">entity-04259b09ae8961d12d9af9a2023e3f55</data>
      <data key="v_content">memory debugging</data>
      <data key="v_name">entity-04259b09ae8961d12d9af9a2023e3f55</data>
      <data key="v_id">n59</data>
    </node>
    <node id="n60">
      <data key="v_hash_id">entity-5ada5946feba299ba4020a0410c93f3c</data>
      <data key="v_content">michigan</data>
      <data key="v_name">entity-5ada5946feba299ba4020a0410c93f3c</data>
      <data key="v_id">n60</data>
    </node>
    <node id="n61">
      <data key="v_hash_id">entity-b594baa1b4c99824c8c51f9a8e2fa18b</data>
      <data key="v_content">multi variate bernoulli naive bayes classifier</data>
      <data key="v_name">entity-b594baa1b4c99824c8c51f9a8e2fa18b</data>
      <data key="v_id">n61</data>
    </node>
    <node id="n62">
      <data key="v_hash_id">entity-1657ec96792937f71c20c9e1bdc2300f</data>
      <data key="v_content">nano</data>
      <data key="v_name">entity-1657ec96792937f71c20c9e1bdc2300f</data>
      <data key="v_id">n62</data>
    </node>
    <node id="n63">
      <data key="v_hash_id">entity-0048246241ea606e84b864dd5900a311</data>
      <data key="v_content">ncurses</data>
      <data key="v_name">entity-0048246241ea606e84b864dd5900a311</data>
      <data key="v_id">n63</data>
    </node>
    <node id="n64">
      <data key="v_hash_id">entity-e4f5c222b04277901d0780514a13e87f</data>
      <data key="v_content">november 25  2024</data>
      <data key="v_name">entity-e4f5c222b04277901d0780514a13e87f</data>
      <data key="v_id">n64</data>
    </node>
    <node id="n65">
      <data key="v_hash_id">entity-b484857901742afc9e9d4e9853596ce2</data>
      <data key="v_content">pack</data>
      <data key="v_name">entity-b484857901742afc9e9d4e9853596ce2</data>
      <data key="v_id">n65</data>
    </node>
    <node id="n66">
      <data key="v_hash_id">entity-294de175130af2f285ae4e46210f79f7</data>
      <data key="v_content">pack hpp</data>
      <data key="v_name">entity-294de175130af2f285ae4e46210f79f7</data>
      <data key="v_id">n66</data>
    </node>
    <node id="n67">
      <data key="v_hash_id">entity-402a95e44f84ed03d8952a5630b15606</data>
      <data key="v_content">pack in</data>
      <data key="v_name">entity-402a95e44f84ed03d8952a5630b15606</data>
      <data key="v_id">n67</data>
    </node>
    <node id="n68">
      <data key="v_hash_id">entity-7da60a666972972820563a4a114ef9df</data>
      <data key="v_content">pack tests cpp</data>
      <data key="v_name">entity-7da60a666972972820563a4a114ef9df</data>
      <data key="v_id">n68</data>
    </node>
    <node id="n69">
      <data key="v_hash_id">entity-e2dce986c1425858db8ee35da1827c0a</data>
      <data key="v_content">pair type</data>
      <data key="v_name">entity-e2dce986c1425858db8ee35da1827c0a</data>
      <data key="v_id">n69</data>
    </node>
    <node id="n70">
      <data key="v_hash_id">entity-4558aac7b93717f32323b02d2db1f28b</data>
      <data key="v_content">piazza</data>
      <data key="v_name">entity-4558aac7b93717f32323b02d2db1f28b</data>
      <data key="v_id">n70</data>
    </node>
    <node id="n71">
      <data key="v_hash_id">entity-d3401cacf87221ecb1fe4f93b8bb90cd</data>
      <data key="v_content">pico</data>
      <data key="v_name">entity-d3401cacf87221ecb1fe4f93b8bb90cd</data>
      <data key="v_id">n71</data>
    </node>
    <node id="n72">
      <data key="v_hash_id">entity-912af0dff974604f1321254ca8ff38b6</data>
      <data key="v_content">player</data>
      <data key="v_name">entity-912af0dff974604f1321254ca8ff38b6</data>
      <data key="v_id">n72</data>
    </node>
    <node id="n73">
      <data key="v_hash_id">entity-f5bbced77c686ab37d0dfcfb85d1de55</data>
      <data key="v_content">player hpp</data>
      <data key="v_name">entity-f5bbced77c686ab37d0dfcfb85d1de55</data>
      <data key="v_id">n73</data>
    </node>
    <node id="n74">
      <data key="v_hash_id">entity-54dfd8419338ca198b8ec0dd432bd74b</data>
      <data key="v_content">player tests cpp</data>
      <data key="v_name">entity-54dfd8419338ca198b8ec0dd432bd74b</data>
      <data key="v_id">n74</data>
    </node>
    <node id="n75">
      <data key="v_hash_id">entity-02749405f389b8f7ebbf4244719253f6</data>
      <data key="v_content">ppage</data>
      <data key="v_name">entity-02749405f389b8f7ebbf4244719253f6</data>
      <data key="v_id">n75</data>
    </node>
    <node id="n76">
      <data key="v_hash_id">entity-183665f71780ba64b6a97b97bca89b93</data>
      <data key="v_content">ppm format</data>
      <data key="v_name">entity-183665f71780ba64b6a97b97bca89b93</data>
      <data key="v_id">n76</data>
    </node>
    <node id="n77">
      <data key="v_hash_id">entity-46f86faa6bbf9ac94a7e459509a20ed0</data>
      <data key="v_content">project</data>
      <data key="v_name">entity-46f86faa6bbf9ac94a7e459509a20ed0</data>
      <data key="v_id">n77</data>
    </node>
    <node id="n78">
      <data key="v_hash_id">entity-4416032c8b090ab3c951fcce71021963</data>
      <data key="v_content">project 3</data>
      <data key="v_name">entity-4416032c8b090ab3c951fcce71021963</data>
      <data key="v_id">n78</data>
    </node>
    <node id="n79">
      <data key="v_hash_id">entity-420d7ffd2ca3476bf6d4066855bb74fe</data>
      <data key="v_content">q24 met online</data>
      <data key="v_name">entity-420d7ffd2ca3476bf6d4066855bb74fe</data>
      <data key="v_id">n79</data>
    </node>
    <node id="n80">
      <data key="v_hash_id">entity-d49219abcf675434bbb3b5ea60de8168</data>
      <data key="v_content">reading csv files</data>
      <data key="v_name">entity-d49219abcf675434bbb3b5ea60de8168</data>
      <data key="v_id">n80</data>
    </node>
    <node id="n81">
      <data key="v_hash_id">entity-a0f848942ce863cf53c0fa6cc684007d</data>
      <data key="v_content">setup</data>
      <data key="v_name">entity-a0f848942ce863cf53c0fa6cc684007d</data>
      <data key="v_id">n81</data>
    </node>
    <node id="n82">
      <data key="v_hash_id">entity-5bead975bcfeab76f6d6828b755ee89d</data>
      <data key="v_content">sp16 projects exam csv</data>
      <data key="v_name">entity-5bead975bcfeab76f6d6828b755ee89d</data>
      <data key="v_id">n82</data>
    </node>
    <node id="n83">
      <data key="v_hash_id">entity-0a4246f93dcdd2c0220c7cde1d23c989</data>
      <data key="v_content">stanford university</data>
      <data key="v_name">entity-0a4246f93dcdd2c0220c7cde1d23c989</data>
      <data key="v_id">n83</data>
    </node>
    <node id="n84">
      <data key="v_hash_id">entity-50f30b0591add504877d5ebea278149c</data>
      <data key="v_content">std  list</data>
      <data key="v_name">entity-50f30b0591add504877d5ebea278149c</data>
      <data key="v_id">n84</data>
    </node>
    <node id="n85">
      <data key="v_hash_id">entity-9e4c26898fb265cae41e4ba8bd52a918</data>
      <data key="v_content">std  map</data>
      <data key="v_name">entity-9e4c26898fb265cae41e4ba8bd52a918</data>
      <data key="v_id">n85</data>
    </node>
    <node id="n86">
      <data key="v_hash_id">entity-98b36ef7e18c4be100170fa7f330d105</data>
      <data key="v_content">std  pair</data>
      <data key="v_name">entity-98b36ef7e18c4be100170fa7f330d105</data>
      <data key="v_id">n86</data>
    </node>
    <node id="n87">
      <data key="v_hash_id">entity-3a89ae268dcae7895f5a5a734127e7fe</data>
      <data key="v_content">submitting code</data>
      <data key="v_name">entity-3a89ae268dcae7895f5a5a734127e7fe</data>
      <data key="v_id">n87</data>
    </node>
    <node id="n88">
      <data key="v_hash_id">entity-bbeab568798e7edc63cc5341f43ece4c</data>
      <data key="v_content">terminal editor</data>
      <data key="v_name">entity-bbeab568798e7edc63cc5341f43ece4c</data>
      <data key="v_id">n88</data>
    </node>
    <node id="n89">
      <data key="v_hash_id">entity-f83bccda2f733c615293a89ecea2ec61</data>
      <data key="v_content">test small csv</data>
      <data key="v_name">entity-f83bccda2f733c615293a89ecea2ec61</data>
      <data key="v_id">n89</data>
    </node>
    <node id="n90">
      <data key="v_hash_id">entity-ae2b1fca515949e5d54fb22b8ed95575</data>
      <data key="v_content">testing</data>
      <data key="v_name">entity-ae2b1fca515949e5d54fb22b8ed95575</data>
      <data key="v_id">n90</data>
    </node>
    <node id="n91">
      <data key="v_hash_id">entity-3d05832e0ff1d81d0ec36bff9a645022</data>
      <data key="v_content">textbuffer</data>
      <data key="v_name">entity-3d05832e0ff1d81d0ec36bff9a645022</data>
      <data key="v_id">n91</data>
    </node>
    <node id="n92">
      <data key="v_hash_id">entity-3a18b297026f44367037b7ec2d0851a4</data>
      <data key="v_content">train small csv</data>
      <data key="v_name">entity-3a18b297026f44367037b7ec2d0851a4</data>
      <data key="v_id">n92</data>
    </node>
    <node id="n93">
      <data key="v_hash_id">entity-4d98bd8c32ccd36582b00cc79420cad2</data>
      <data key="v_content">two sample analysis program</data>
      <data key="v_name">entity-4d98bd8c32ccd36582b00cc79420cad2</data>
      <data key="v_id">n93</data>
    </node>
    <node id="n94">
      <data key="v_hash_id">entity-39d0b1f36ac358d2c4fac6a95e5b8b7a</data>
      <data key="v_content">two sample exe</data>
      <data key="v_name">entity-39d0b1f36ac358d2c4fac6a95e5b8b7a</data>
      <data key="v_id">n94</data>
    </node>
    <node id="n95">
      <data key="v_hash_id">entity-b031a93bd55b1a898d4189cb70b6f65c</data>
      <data key="v_content">unit test framework</data>
      <data key="v_name">entity-b031a93bd55b1a898d4189cb70b6f65c</data>
      <data key="v_id">n95</data>
    </node>
    <node id="n96">
      <data key="v_hash_id">entity-848a356ff04f1440a87829c21f0cb89d</data>
      <data key="v_content">unit test framework hpp</data>
      <data key="v_name">entity-848a356ff04f1440a87829c21f0cb89d</data>
      <data key="v_id">n96</data>
    </node>
    <node id="n97">
      <data key="v_hash_id">entity-1b45811985d9e722b331c35b1546a3cf</data>
      <data key="v_content">unit testing</data>
      <data key="v_name">entity-1b45811985d9e722b331c35b1546a3cf</data>
      <data key="v_id">n97</data>
    </node>
    <node id="n98">
      <data key="v_hash_id">entity-2e8c7be2e939a01b74abd1b0d820b30f</data>
      <data key="v_content">valgrind</data>
      <data key="v_name">entity-2e8c7be2e939a01b74abd1b0d820b30f</data>
      <data key="v_id">n98</data>
    </node>
    <node id="n99">
      <data key="v_hash_id">entity-130f3abb9780f0a8be1b705f537bf752</data>
      <data key="v_content">value type</data>
      <data key="v_name">entity-130f3abb9780f0a8be1b705f537bf752</data>
      <data key="v_id">n99</data>
    </node>
    <node id="n100">
      <data key="v_hash_id">entity-ce9d57aa3ca6d2e5275ce2a8ce13ce6b</data>
      <data key="v_content">version control</data>
      <data key="v_name">entity-ce9d57aa3ca6d2e5275ce2a8ce13ce6b</data>
      <data key="v_id">n100</data>
    </node>
    <node id="n101">
      <data key="v_hash_id">entity-35b36b28916d38b34abddf832e286126</data>
      <data key="v_content">vi</data>
      <data key="v_name">entity-35b36b28916d38b34abddf832e286126</data>
      <data key="v_id">n101</data>
    </node>
    <node id="n102">
      <data key="v_hash_id">entity-287808e14dc30ced980adfb2355b07c1</data>
      <data key="v_content">visual editors</data>
      <data key="v_name">entity-287808e14dc30ced980adfb2355b07c1</data>
      <data key="v_id">n102</data>
    </node>
    <node id="n103">
      <data key="v_hash_id">entity-39ddcbe4d08aa13fdd01f0bc3e77a22c</data>
      <data key="v_content">visual studio</data>
      <data key="v_name">entity-39ddcbe4d08aa13fdd01f0bc3e77a22c</data>
      <data key="v_id">n103</data>
    </node>
    <node id="n104">
      <data key="v_hash_id">entity-d6aad39c99ebccf3a40132d6fe33f40c</data>
      <data key="v_content">vs code</data>
      <data key="v_name">entity-d6aad39c99ebccf3a40132d6fe33f40c</data>
      <data key="v_id">n104</data>
    </node>
    <node id="n105">
      <data key="v_hash_id">entity-dfb189ac0c5a119e374eed564e1cfbd2</data>
      <data key="v_content">w14 f15 instructor student csv</data>
      <data key="v_name">entity-dfb189ac0c5a119e374eed564e1cfbd2</data>
      <data key="v_id">n105</data>
    </node>
    <node id="n106">
      <data key="v_hash_id">entity-e3ceedebe6fee4d8c8e7cf7d660b0d77</data>
      <data key="v_content">w16 instructor student csv</data>
      <data key="v_name">entity-e3ceedebe6fee4d8c8e7cf7d660b0d77</data>
      <data key="v_id">n106</data>
    </node>
    <node id="n107">
      <data key="v_hash_id">entity-c4caa55e19bc31513e3e3eb972660c01</data>
      <data key="v_content">w16 projects exam csv</data>
      <data key="v_name">entity-c4caa55e19bc31513e3e3eb972660c01</data>
      <data key="v_id">n107</data>
    </node>
    <node id="n108">
      <data key="v_hash_id">entity-57bd5f7eb663ffa9aeae4704fcf90ab8</data>
      <data key="v_content">winter 2025</data>
      <data key="v_name">entity-57bd5f7eb663ffa9aeae4704fcf90ab8</data>
      <data key="v_id">n108</data>
    </node>
    <node id="n109">
      <data key="v_hash_id">entity-8f8efce3a06ce9346c794ed97ccb6d50</data>
      <data key="v_content">xcode</data>
      <data key="v_name">entity-8f8efce3a06ce9346c794ed97ccb6d50</data>
      <data key="v_id">n109</data>
    </node>
    <node id="n110">
      <data key="v_hash_id">entity-ba9bf05693b9fa202d922dd43a08f281</data>
      <data key="v_content">youtube</data>
      <data key="v_name">entity-ba9bf05693b9fa202d922dd43a08f281</data>
      <data key="v_id">n110</data>
    </node>
    <node id="n111">
      <data key="v_hash_id">chunk-56f089ad684730c76782bd5994888a3a</data>
      <data key="v_content">---
layout: spec
mermaid: true
---

EECS 280 Project 2: Image Processing
===================================
{: .primer-spec-toc-ignore }

Due 8:00pm EST Wednesday February 12th, 2025.  You may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)).

Winter 2025 release.

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**IMPORTANT**
If you are retaking the course, please note changes this term to the underlying implementation of the `Matrix` ADT that affect several parts of the project. While we always suggest students retaking the course redo the entire project from scratch (as it is helpful practice), we nevertheless want to highlight these changes to the project.
&lt;/div&gt;

## Introduction
Build an image resizing program using a seam-carving algorithm.

The learning goals of this project include Testing, Debugging, Pointers, Strings, Streams, IO, and Abstract Data Types in C.  You&apos;ll gain practice with C-style pointers and structs.

When you&apos;re done, you&apos;ll have a program that uses seam carving for content-aware resizing of images.  The algorithm works by finding and
removing &quot;seams&quot; in the image that pass through the least important
pixels. For a quick introduction, check out [this video](https://www.youtube.com/watch?v=6NcIJXTlugc).

&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33%&quot; /&gt;
&lt;col style=&quot;width: 33%&quot; /&gt;
&lt;col style=&quot;width: 33%&quot; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center; vertical-align: bottom;&quot;&gt;
  &lt;img src=&quot;images/image11.png&quot; style=&quot;width: 100%&quot;/&gt;&lt;br /&gt;
  Original Image: 479x382
&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: bottom;&quot;&gt;
  &lt;img src=&quot;images/image15.png&quot; style=&quot;width: 62.6%&quot;/&gt;&lt;br /&gt;
  Resized: 300x382
&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: bottom;&quot;&gt;
  &lt;img src=&quot;images/image5.png&quot; style=&quot;width: 83.5%&quot;/&gt;&lt;br /&gt;
  Resized: 400x250
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

## Setup

Set up your visual debugger and version control, then submit to the autograder.

### Visual debugger
During setup, name your project `p2-image-processing`. Use this starter files link: `https://eecs280staff.github.io/image-processing/starter-files.tar.gz`

| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html) | [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |

If you created a `main.cpp` while following the setup tutorial, rename it to `resize.cpp`. Otherwise, create a new file `resize.cpp`.  You should end up with a folder with starter files that looks like this.  You may have already renamed files like `Matrix.cpp.starter` to `Matrix.cpp`.
```console
$ ls
Image.cpp.starter            dog_4x5.correct.ppm
Image.hpp                    dog_cost_correct.txt
Image_public_test.cpp        dog_energy_correct.txt
Image_test_helpers.cpp       dog_left.correct.ppm
Image_test_helpers.hpp       dog_removed.correct.ppm
Image_tests.cpp.starter      dog_right.correct.ppm
Makefile                     dog_seam_correct.txt
Matrix.cpp.starter           horses.ppm
Matrix.hpp                   horses_300x382.correct.ppm
Matrix_public_test.cpp       horses_400x250.correct.ppm
Matrix_test_helpers.cpp      horses_cost_correct.txt
Matrix_test_helpers.hpp      horses_energy_correct.txt
Matrix_tests.cpp.starter     horses_left.correct.ppm
crabster.ppm                 horses_removed.correct.ppm
crabster_50x45.correct.ppm   horses_right.correct.ppm
crabster_70x35.correct.ppm   horses_seam_correct.txt
crabster_cost_correct.txt    jpeg.hpp
crabster_energy_correct.txt  processing.cpp.starter
crabster_left.correct.ppm    processing.hpp
crabster_removed.correct.ppm processing_public_tests.cpp
crabster_right.correct.ppm   resize.cpp
crabster_seam_correct.txt    unit_test_framework.hpp
dog.ppm
```
{: data-variant=&quot;no-line-numbers&quot; }

Here&apos;s a short description of each starter file.

File | Description
------- | -----------
`Matrix.hpp` | Interface specification for the `Matrix` module.
`Image.hpp`  | Interface specification for the `Image` module.
`processing.hpp` | Specification of image processing functions that are pieces of the seam carving algorithm.
`Matrix.cpp.starter` | Starter code for the `Matrix` module.
`Image.cpp.starter` | Starter code for the `Image` module.
`processing.cpp.starter` | Starter code for the `processing` module.
`Matrix_tests.cpp.starter` | Starter code for unit testing the `Matrix` module.
`Image_tests.cpp.starter` | Starter code for unit testing the `Image` module.
`Matrix_public_test.cpp` | Public tests for the `Matrix` module.
`Image_public_test.cpp` | Public tests for the `Image` module.
`processing_public_tests.cpp` | Tests for the `processing` module and seam carving algorithm.
`Matrix_test_helpers.hpp` &lt;br&gt;`Matrix_test_helpers.cpp` &lt;br&gt;`Image_test_helpers.hpp` &lt;br&gt;`Image_test_helpers.cpp` | Helper functions for unit tests
`unit_test_framework.hpp` | A simple unit-testing framework
`jpeg.hpp` | Code for reading and writing JPEG files
`dog.ppm`, `crabster.ppm`, `horses.ppm` | Sample input image files.
Several `_correct.txt` files. &lt;br&gt;Several `.correct.ppm` files. | Sample (correct) output files used by the `processing_public_tests` program.
`Makefile` | Helper commands for building and submitting

### Version control
Set up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).

After you&apos;re done, you should have a local repository with a &quot;clean&quot; status and your local repository should be connected to a remote GitHub repository.
```console
$ git status
On branch main
Your branch is up-to-date with &apos;origin/main&apos;.

nothing to commit, working tree clean
$ git remote -v
origin	https://github.com/awdeorio/p2-image-processing.git (fetch)
origin	https://githubcom/awdeorio/p2-image-processing.git (push)
```

You should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#create-a-local-repository)).
```console
$ pwd
/Users/awdeorio/src/eecs280/p2-image-processing
$ head .gitignore
# This is a sample .gitignore file that&apos;s useful for C++ projects.
...
```

### Group registration
Register your partnership (or working alone) on the Autograder using the direct link in the [Submission and Grading section](#submission-and-grading).  Then, submit the code you have.

## Matrix Module

Create a Matrix abstract data type (ADT).  Write implementations in `Matrix.cpp` for the functions declared in `Matrix.hpp`.

Run the public Matrix tests.
```console
$ make Matrix_public_tests.exe
$ ./Matrix_public_tests.exe
```

Complete the EECS 280 [Unit Test Framework Tutorial](https://eecs280staff.github.io/unit_test_framework/).

Write tests for `Matrix` in `Matrix_tests.cpp` using the unit test framework.  You&apos;ll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.
```console
$ make Matrix_tests.exe
$ ./Matrix_tests.exe
```

Submit `Matrix.cpp` and `Matrix_tests.cpp` to the Autograder using the link in the [Submission and Grading section](#submission-and-grading).

### Setup

Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):
-  `Matrix.cpp.starter` -&gt; `Matrix.cpp`
-  `Matrix_tests.cpp.starter` -&gt; `Matrix_tests.cpp`

The Matrix tests should compile and run.  Expect them to fail at this point because the `Matrix.cpp` starter code contains function stubs.
```console
$ make Matrix_public_tests.exe
$ ./Matrix_public_tests.exe
$ make Matrix_tests.exe
$ ./Matrix_tests.exe
```

Configure your IDE to debug either the public tests or your own tests.

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;/th&gt;
  &lt;th&gt;
  Public tests
  &lt;/th&gt;
  &lt;th&gt;
  Your own tests
  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Matrix_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Matrix_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Matrix_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Matrix_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;XCode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Matrix_public_test.cpp`, `Matrix.cpp`, `Matrix_test_helpers.cpp`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Matrix_tests.cpp`, `Matrix.cpp`, `Matrix_test_helpers.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Matrix_public_test.cpp`
  - Exclude `Matrix_tests.cpp`, `Image_public_test.cpp`, `Image_tests.cpp`, `processing_public_tests.cpp`, `resize.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Matrix_tests.cpp`
  - Exclude `Matrix_public_test.cpp`, `Image_public_test.cpp`, `Image_tests.cpp`, `processing_public_tests.cpp`, `resize.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

### Interface

A matrix is a two-dimensional grid of elements. For this project,
matrices store integer elements and we will refer to locations by
row/column. For example, here&apos;s a 3x5 matrix.

![](images/matrix3x5.svg){: .invert-colors-in-dark-mode }

The `Matrix.hpp` file defines a `Matrix` struct to represent matrices
and specifies the interface for functions to operate on them.
Dimensions of 0 are not allowed.

To create a `Matrix`, first declare a variable and then use an
initializer function.

```c++
Matrix m; // create a Matrix object in local memory
Matrix_init(&amp;m, 100, 100); // initialize it as a 100x100 matrix
```

Once a `Matrix` is initialized, it is considered valid. Now we can use
any of the functions declared in `Matrix.hpp` to operate on it.

```c++
Matrix_fill(&amp;m, 0); // fill with zeros

// fill first row with ones
for (int c = 0; c &lt; Matrix_width(m); ++c) {
  *Matrix_at(&amp;m, 0, c) = 1; // see description below
}

Matrix_print(&amp;m, cout); // print matrix to cout
```

Access to individual elements in a `Matrix` is provided through a
pointer to their location, which can be retrieved through a call to
`Matrix_at`. To read or write the element, you just dereference the
pointer.

The RMEs in `Matrix.hpp` give a full specification of the interface for
each `Matrix` function.

### Implementation
The `Matrix` struct looks like this:

```c++
struct Matrix {
  int width;
  int height;
  std::vector&lt;int&gt; data;
};
```

`Matrix` stores a 2D grid of numbers in an underlying one-dimensional
vector, which in turn stores its elements in a one-dimensional array.

Interface | Implementation
--------- | --------------
![](images/matrix3x5.svg){: .invert-colors-in-dark-mode } | ![](images/matrix3x5_impl.svg){: .invert-colors-in-dark-mode }

&lt;div class=&quot;primer-spec-callout info icon-info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** You will need to either create a vector with a given
size, or resize an existing vector to that size. Here are some ways to
do so:

```c++
// create a vector with 100 elements, all initialized to the value 0
// primer-spec-highlight-start
std::vector&lt;int&gt; vec(100, 0);
// primer-spec-highlight-end

// modify an existing vector to have 200 elements with value 0
// primer-spec-highlight-start
vec.assign(200, 0);
// primer-spec-highlight-end

// replace an existing vector with a new one containing 50 elements,
// all initialized to the value 0
// primer-spec-highlight-start
vec = std::vector&lt;int&gt;(50, 0);
// primer-spec-highlight-end
```
&lt;/div&gt;

Each of the functions in the `Matrix` module takes a pointer to the
`Matrix` that is supposed to be operated on. In your implementations
of these functions, you should access the `width`, `height`, and
`data` members of that `Matrix`, but this is the only place you may do
so. To all other code, the individual members are an implementation
detail that should be hidden behind the provided interfaces for the
`Matrix` module.

Your `Matrix_at` functions will need to perform the appropriate
arithmetic to convert from a (row,column) pair to an index in the
vector. *This function does not require a loop, and you&apos;ll find
your implementation will be very slow if you use a loop.*

There are two versions of the `Matrix_at` function to support element
access for both const and non-const matrices. The constness of the
pointer returned corresponds to the `Matrix` passed in. The
implementations for these will be identical.

Remember that you may call any of the functions in a module as part of
the implementation of another, and in fact you should do this if it
reduces code duplication. In particular, you can access the
`data` member directly in the `Matrix_init`, `Matrix_at`, and `Matrix_fill` 
functions. However, other functions including `Matrix_fill_border`, 
`Matrix_min_value_in_row`, and `Matrix_column_of_min_value_in_row`
will be *easier* to write if they access elements by calling 
`Matrix_at()` as a helper function instead.

&lt;div class=&quot;primer-spec-callout info icon-info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:**  Use `assert()` to check the conditions in the REQUIRES clause.  If other code breaks the interface, that&apos;s a bug and you want to know right away!  Here&apos;s an example.

```c++
// primer-spec-highlight-start
// REQUIRES: mat points to a valid Matrix
//           0 &lt;= row &amp;&amp; row &lt; Matrix_height(&amp;mat)
//           0 &lt;= column &amp;&amp; column &lt; Matrix_width(&amp;mat)
// primer-spec-highlight-end
// EFFECTS:  Returns a pointer to the element in
//           the Matrix at the given row and column.
int* Matrix_at(Matrix* mat, int row, int column) {
  // primer-spec-highlight-start
  assert(0 &lt;= row &amp;&amp; row &lt; mat-&gt;height);
  assert(0 &lt;= column &amp;&amp; column &lt; mat-&gt;width);
  // primer-spec-highlight-end
  // ...
}
```

Some things can&apos;t be checked, for example that a pointer points to a valid `Matrix`.
&lt;/div&gt;

### Testing
Test your Matrix functions to ensure that your implementations conform to
specification in the RME.

Heed the Small Scope Hypothesis. There is no need for large `Matrix` structs. (Other than an as edge case for max size.) Think about what makes tests meaningfully different.

Respect the interfaces for the modules you are testing. Do not access member variables of the structs directly. Do not test inputs that break the REQUIRES clause for a function.
```c++
TEST(test_bad) {
  Matrix mat;
  const int width = 3;
  const int height = 5;
  const int value = 42;
  Matrix_init(&amp;mat, 3, 5);
  Matrix_fill(&amp;mat, value);

  for(int r = 0; r &lt; height; ++r) {
    for(int c = 0; c &lt; width; ++c) {
      // primer-spec-highlight-start
      ASSERT_EQUAL(mat.data[r][c], value);  // BAD! DO NOT access member directly
      // primer-spec-highlight-end
    }
  }
}
```

Sometimes you need to use one Matrix one function while testing another.  For example, you need `Matrix_at` to test `Matrix_fill`.
```c++
TEST(test_fill_basic) {
  Matrix mat;
  const int width = 3;
  const int height = 5;
  const int value = 42;
  Matrix_init(&amp;mat, 3, 5);
  // primer-spec-highlight-start
  Matrix_fill(&amp;mat, value);
  // primer-spec-highlight-end

  for(int r = 0; r &lt; height; ++r) {
    for(int c = 0; c &lt; width; ++c) {
      // primer-spec-highlight-start
      ASSERT_EQUAL(*Matrix_at(&amp;mat, r, c), value);
      // primer-spec-highlight-end
    }
  }
}
```

Use an `ostringstream` to test `Matrix_print()`.
```c++
#include &lt;sstream&gt;

TEST(test_matrix_print) {
  Matrix mat;
  Matrix_init(&amp;mat, 1, 1);

  *Matrix_at(&amp;mat, 0, 0) = 42;
  ostringstream expected;
  expected &lt;&lt; &quot;1 1\n&quot;
           &lt;&lt; &quot;42 \n&quot;;
  ostringstream actual;
  Matrix_print(&amp;mat, actual);
  ASSERT_EQUAL(expected.str(), actual.str());
}
```

In your `Matrix` tests, you may use the functions provided in `Matrix_test_helpers.hpp`.  Do not use `Image_test_helpers.hpp` in your `Matrix` tests.

## Image Module
Create an Image abstract data type (ADT).  Write implementations in `Image.cpp` for the functions declared in `Image.hpp`.

Run the public Image tests.
```console
$ make Image_public_tests.exe
$ ./Image_public_tests.exe
```

Write tests for `Image` in `Image_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You&apos;ll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.
```console
$ make Image_tests.exe
$ ./Image_tests.exe
```

Submit `Image.cpp` and `Image_tests.cpp` to the Autograder using the link in the [Submission and Grading section](#submission-and-grading).

### Setup

Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):
- `Image.cpp.starter` -&gt; `Image.cpp`
- `Image_tests.cpp.starter` -&gt; `Image_tests.cpp`

The Image tests should compile and run.  Expect them to fail at this point because the `Image.cpp` starter code contains function stubs.
```console
$ make Image_public_tests.exe
$ ./Image_public_tests.exe
$ make Image_tests.exe
$ ./Image_tests.exe
```

Write tests for `Image` in `Image_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You&apos;ll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.
```console
$ make Image_tests.exe
$ ./Image_tests.exe
```

Configure your IDE to debug either the public tests or your own tests.

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;
  &lt;/th&gt;
  &lt;th&gt;
  Public tests
  &lt;/th&gt;
  &lt;th&gt;
  Your own tests
  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Image_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Image_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Image_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Image_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;XCode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Image_public_test.cpp`, `Matrix.cpp`, `Image.cpp`, `Matrix_test_helpers.cpp`, `Image_test_helpers.cpp`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Image_tests.cpp`, `Matrix.cpp`, `Image.cpp`, `Matrix_test_helpers.cpp`, `Image_test_helpers.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build : &lt;br&gt;
  - Include `Image_public_test.cpp`
  - Exclude `Image_tests.cpp`, `Matrix_public_test.cpp`, `Matrix_tests.cpp`, `processing_public_tests.cpp`, `resize.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Image_tests.cpp`
  - Exclude `Image_public_test.cpp`, `Matrix_public_test.cpp`, `Matrix_tests.cpp`, `processing_public_tests.cpp`, `resize.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

### Interface
An `Image` is similar to a `Matrix`, but contains `Pixel`s instead of
integers. Each `Pixel` includes three integers, which represent red,
green, and blue (RGB) color components. Each component takes on an
intensity value between 0 and 255. The `Pixel` type is considered
&quot;Plain Old Data&quot; (POD), which means it doesn&apos;t have a separate
interface. We just use its member variables directly. Here is the
`Pixel` struct and some examples:

&lt;table&gt;
&lt;tr&gt;
&lt;td rowspan=&quot;3&quot;&gt;
&lt;pre data-variant=&quot;legacy&quot;&gt;
struct Pixel {
  int r;  // red
  int g;  // green
  int b;  // blue
}
&lt;/pre&gt;
&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;images/image20.png&quot; /&gt;
&lt;br&gt;
(255,0,0)
&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;images/image18.png&quot; /&gt;
&lt;br&gt;
(0,255,0)
&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;images/image3.png&quot; /&gt;
&lt;br&gt;
(0,0,255)
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;images/image24.png&quot; /&gt;
&lt;br&gt;
(0,0,0)
&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;images/image19.png&quot; style=&quot;border:1px solid black&quot;/&gt;
&lt;br&gt;
(255,255,255)
&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;images/image8.png&quot; /&gt;
&lt;br&gt;
(100,100,100)
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;images/image2.png&quot; /&gt;
&lt;br&gt;
(101,151,183)
&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;images/image25.png&quot; /&gt;
&lt;br&gt;
(124,63,63)
&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;images/image14.png&quot; /&gt;
&lt;br&gt;
(163,73,164)
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

Below is a 5x5 image and its conceptual representation
as a grid of pixels.

![](images/dog_pixels.svg)

Dimensions of 0 are not allowed. To create an `Image`, first declare a
variable and then use an initializer function. There are several
initializer functions, but for now we&apos;ll just use the basic one.

```c++
Image img; // create an Image object in local memory
Image_init(&amp;img, 5, 5); // initialize it as a 5x5 image
```

Once an `Image` is initialized, it is considered valid. Now we can use
any of the functions declared in `Image.hpp` to operate on it.

```c++
Pixel um_blue = { 0, 46, 98 };
Pixel um_maize = { 251, 206, 51 };
Image_fill(&amp;img, um_blue); // fill with blue

// fill every other column with maize to make stripes
for (int c = 0; c &lt; Image_width(&amp;img); ++c) {
  if (c % 2 == 0) { // only even columns
    for (int r = 0; r &lt; Image_height(&amp;img); ++r) {
      Image_set_pixel(&amp;img, r, c, um_maize);
    }
  }
}
```

To read and write individual `Pixel`s in an `Image`, use the
`Image_get_pixel` and `Image_set_pixel` functions, respectively.

The RMEs in `Image.hpp` give a full specification of the interface for
each `Image` function.

### PPM Format

The `Image` module also provides functions to read and write `Image`s
from/to the PPM image format. Here&apos;s an example of an `Image` and its
representation in PPM.

&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%&quot; /&gt;
&lt;col style=&quot;width: 50%&quot; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;th&gt;Image&lt;/th&gt;
&lt;th&gt;Image Representation in PPM&lt;/th&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;&lt;img src=&quot;images/image7.png&quot; /&gt;&lt;/td&gt;
&lt;td&gt;
&lt;pre data-variant=&quot;legacy&quot;&gt;
P3
5 5
255
0 0 0 0 0 0 255 255 250 0 0 0 0 0 0 
255 255 250 126 66 0 126 66 0 126 66 0 255 255 250 
126 66 0 0 0 0 255 219 183 0 0 0 126 66 0 
255 219 183 255 219 183 0 0 0 255 219 183 255 219 183 
255 219 183 0 0 0 134 0 0 0 0 0 255 219 183 
&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

The PPM format begins with these elements, each
separated by
    whitespace:

  - `P3` (Indicates it&apos;s a &quot;Plain PPM file&quot;.)
  - `WIDTH HEIGHT` (Image width and height, separated by whitespace.)
  - `255` (Max value for RGB intensities. We&apos;ll always use 255.)

This is followed by the pixels in the image, listed with each row on a
separate line. A pixel is written as three integers for its RGB
components in that order, separated by whitespace.

To write an image to PPM format, use the `Image_print` function that
takes in a `std::ostream`. This can be used in conjunction with file
I/O to write an image to a PPM file. **The `Image_print` function must
produce a PPM using whitespace in a very specific way** so that we can
use `diff` to compare your output PPM file against a correct PPM file.
See the RME for the full details.

To create an image by reading from PPM format, use the `Image_init`
function that takes in a `std::istream`. This can be used in
conjunction with file I/O to read an image from a PPM file. Because we
may be reading in images generated from programs that don&apos;t use
whitespace in the same way that we do, the `Image_init` function must
accommodate any kind of whitespace used to separate elements of the
PPM format (if you use C++ style I/O with `&gt;&gt;`, this should be no
problem). Other than variance in whitespace (not all PPM files put
each row on its own line, for example), you may assume any input
to this function is in valid PPM format. (Some PPM files may contain
&quot;comments&quot;, but you do not have to account for these.)

See [Working with PPM Files](ppm.html) for more
information on working with PPM files and programs that can be used to
view or create them on various platforms.

### Implementation

The `Image` struct looks like this:

```c++
struct Image {
  int width;
  int height;
  Matrix red_channel;
  Matrix green_channel;
  Matrix blue_channel;
};
```

The Interface for `Image` makes it seem like we have a grid of
`Pixel`s, but the `Image` struct actually stores the information for
the image in three separate `Matrix` structs, one for each of the RGB
color channels. There are no `Pixel`s in the underlying
representation, so your `Image_get_pixel` function must pack the RGB
values from each color `Matrix` into a `Pixel` to be returned.
Likewise, `Image_set_pixel` must unpack RGB values from an input
`Pixel` and store them into each `Matrix`.

Each of the functions in the `Image` module takes a pointer to the
`Image` that is supposed to be operated on. When you are writing
implementations for these functions, you may be tempted to access
members of the `Matrix` struct directly (e.g.
`img-&gt;red_channel.width`, `img-&gt;green_channel.data[x]`). Don&apos;t do it!
They aren&apos;t part of the interface for `Matrix`, and you should not use
them from the outside. Instead, use the `Matrix` functions that are
part of the interface (e.g. `Matrix_width(&amp;img-&gt;red_channel)`,
`Matrix_at(&amp;img-&gt;green_channel, r, c)`).

In your implementation of the `Image_init` functions, space for the
`Matrix` members will have already been allocated as part of the
`Image`. However, you still need to initialize these with a call to
`Matrix_init` to ensure they are the right size!

The `Image` struct contains `width` and `height` members. These are
technically redundant, since each of the `Matrix` members also keeps
track of a width and height, but having them around should make the
implementations for your functions easier to read.

### Respect the Interfaces!

Our goal is to use several modules that work together through
well-defined interfaces, and to keep the implementations separate from
those interfaces. The interfaces consist of the functions we provide
in the `.hpp` file for the module, but NOT the member variables of the
struct. The member variables are part of the implementation, not the
interface!

This means you may access member variables directly (i.e. using `.` or
`-&gt;`) when you&apos;re writing code within their module, but never from the
outside world! For example, let&apos;s consider the `Image` module. If I&apos;m
writing the implementation of a function inside the module, like
`Image_print`, it&apos;s fine to use the member variable `height` directly:

```c++
void Image_print(const Image *img, std::ostream&amp; os) {
  ...
  // loop through all the rows
  for (int r = 0; r &lt; img-&gt;height; ++r) {
    // do something
  }
  ...
}
```

This is fine, because we assume the person who implements the module
is fully aware of all the details of how to use `height` correctly.
However, if I&apos;m working from the outside, then using member variables
directly is very dangerous. This code won&apos;t work right:

```c++
int main() {
  // Make a 400x300 image (sort of)
  Image img;
  img.width = 400;
  img.height = 300;
  // do something with img but it doesn&apos;t work :(
  ...
}
```

The problem is that we &quot;forgot&quot; about initializing the width and
height of the `Matrix` structs that make up each color channel in the
image. Instead, we should have used the `Image_init` function from the
outside, which takes care of everything for us.

Here&apos;s the big idea - we don&apos;t want the &quot;outside world&quot; to have to
worry about the details of the implementation, or even to know them at
all. We want to support substitutability, so that the implementation
can change without breaking outside code (as long as it still conforms
to the interface). Using member variables directly from the outside
messes this all up. Don&apos;t do it! It could break your code and this
will be tested on the autograder!

An exception to this rule is the `Pixel` struct. It&apos;s considered to be
a &quot;Plain Old Data&quot; (POD) type. In this case, the interface and the
implementation are the same thing. It&apos;s just an aggregate of three
ints to represent an RGB pixel - nothing more, nothing less.

We should note there are patterns used in C-style programming that
hide away the definition of a struct&apos;s members and prevent us from
accidentally accessing them outside the correct module. Unfortunately,
this causes complications that we don&apos;t have all the tools to deal
with yet (namely dynamic memory management). We&apos;ll also see that C++
adds some built-in language mechanisms to control member
accessibility. For now, you&apos;ll just have to be careful!

### Copying Large Structs

In many cases you will find it useful to copy `Matrix` and `Image`
structs in your code. This is supported by the interface, so feel free
to use it wherever useful. However, try to avoid making unnecessary
copies, as this can slow down your code.

As an example, let&apos;s say you wanted to add a border to a `Matrix` and
print it without changing the original. You could write this:

```c++
...
// Assume we have a variable mat that points to a Matrix

// Make a copy of mat and add the border. original remains unchanged
Matrix mat_border = *mat; // need to dereference mat to copy it 
Matrix_fill_border(&amp;mat_border, 0);

// print the bordered version
Matrix_print(&amp;mat_border, os);
...
```

### Testing

Respect the interfaces for the modules you are testing. Do not access
member variables of the structs directly. Do not test inputs that
break the REQUIRES clause for a function.

You may use stringstreams to simulate file input and/or output for your unit tests. You may also use the image files `dog.ppm`, `crabster.ppm`, and `horses.ppm`, but no others.

In your `Image` tests, you may use the functions provided in `Image_test_helpers.hpp`.  Do not use `Matrix_test_helpers.hpp` in your `Image` tests.

## Processing Module
The `processing` module contains several functions that perform image
processing operations. Some of these provide an interface for
content-aware resizing of images, while others correspond to
individual steps in the seam carving algorithm.

The main interface for using content-aware resizing is through the
`seam_carve`, `seam_carve_width` and `seam_carve_height` functions.
These functions use the seam carving algorithm to shrink either an
image&apos;s width or height in a context-aware fashion. The `seam_carve`
function adjusts both width and height, but width is always done
first. For this project, we only support shrinking an image, so the
requested width and height will always be less than or equal to the
original values.

Write implementations in `processing.cpp` for the functions declared in `processing.hpp`.

Run the public processing tests.
```console
$ make processing_public_tests.exe
$ ./processing_public_tests.exe
```

Submit `processing.cpp` to the Autograder using the link in the [Submission and Grading section](#submission-and-grading).

### Setup

Rename this file ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):
- `processing.cpp.starter` -&gt; `processing.cpp`

The Processing tests should compile and run.  Expect them to fail at this point because the `processing.cpp` starter code contains function stubs.
```console
$ make processing_public_tests.exe
$ ./processing_public_tests.exe
```

Configure your IDE to debug public tests.

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/processing_public_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/processing_public_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;XCode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `processing_public_tests.cpp`, `Matrix.cpp`, `Image.cpp`, `processing.cpp`, `Matrix_test_helpers.cpp`, `Image_test_helpers.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `processing_public_tests.cpp`
  - Exclude `Matrix_public_test.cpp`, `Matrix_tests.cpp`, `Image_public_test.cpp`, `Image_tests.cpp`, `resize.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

### Energy Matrix

`compute_energy_matrix`: The seam carving algorithm works by removing seams that pass through
the least important pixels in an image. We use a pixel&apos;s energy as a
measure of its importance.

To compute a pixel&apos;s energy, we look at its neighbors. We&apos;ll call them
N (north), S (south), E (east), and W (west) based on their direction
from the pixel in question (we&apos;ll call it X).

![](images/energy_matrix.svg)

The energy of X is the sum of the squared differences
between its N/S and E/W neighbors:

```
energy(X) = squared_difference(N, S) + squared_difference(W, E)
```

The static function `squared_difference` is provided as part of the
starter code. Do not change the implementation of the
`squared_difference` function.

To construct the energy `Matrix` for the whole image, your function
should do the following:

1.  Initialize the energy `Matrix` with the same size as the `Image`
    and fill it with zeros.
2.  Compute the energy for each non-border pixel, using the formula
    above.
3.  Find the maximum energy so far, and use it to fill in the border
    pixels.

### Cost Matrix

`compute_vertical_cost_matrix`: Once the energy matrix has been computed, the next step is to find the
path from top to bottom (i.e. a vertical seam) that passes through the
pixels with the lowest total energy (this is the seam that we would
like to remove).

We will begin by answering a related question - given a particular
pixel, what is the minimum energy we must move through to get to that
pixel via any possible path? We will refer to this as the cost of that
pixel. Our goal for this stage of the algorithm will be to compute a
matrix whose entries correspond to the cost of each pixel in the
image.

Now, to get to any pixel we have to come from one of the three pixels
above it.

&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%&quot; /&gt;
&lt;col style=&quot;width: 50%&quot; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;p&gt;&lt;img src=&quot;images/image16.png&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;&lt;br /&gt;
Pixels above (3,2)&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;p&gt;&lt;img src=&quot;images/image1.png&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;&lt;br /&gt;
Pixels above (2,4)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

We would want to choose the least costly from those pixels, which
means the minimum cost to get to a pixel is its own energy plus the
minimum cost for any pixel above it. This is a recurrence relation.
For a pixel with row `r` and column `c`, the cost is:

```
cost(r, c) = energy(r, c) + min(cost(r-1, c-1),
                                cost(r-1, c),
                                cost(r-1, c+1))
```

Use the `Matrix_min_value_in_row` function to help with this equation.
Of course, you need to be careful not to consider coming from pixels
outside the bounds of the `Matrix`.

We could compute costs recursively, with
pixels in the first row as our base case, but this would involve a lot
of repeated work since our subproblems will end up overlapping.
Instead, let&apos;s take the opposite approach...

1.  Initialize the cost `Matrix` with the same size as the energy
    `Matrix`.
2.  Fill in costs for the first row (index 0). The cost for these
    pixels is just the energy.
3.  Loop through the rest of the pixels in the `Matrix`, row by row,
    starting with the second row (index 1). Use the recurrence above
    to compute each cost. Because a pixel&apos;s cost only depends on other
    costs in an earlier row, they will have already been computed and
    can just be looked up in the `Matrix`.

### Minimal Vertical Seam
`find_minimal_vertical_seam`: The pixels in the bottom row of the image correspond to the possible
endpoints for any seam, so we start with the one of those that is
lowest in the cost matrix.

&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%&quot; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;p&gt;&lt;img src=&quot;images/image6.png&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;&lt;br /&gt;
First, find the minimum cost pixel in the bottom row.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

Now, we work our way up, considering where we would have come from in
the row above. In the pictures below, the blue box represents the
&quot;pixels above&quot; in each step.

&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%&quot; /&gt;
&lt;col style=&quot;width: 50%&quot; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;p&gt;&lt;img src=&quot;images/image9.png&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;&lt;br /&gt;
Then find the minimum cost pixel above.&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;p&gt;&lt;img src=&quot;images/image13.png&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;&lt;br /&gt;
Don&apos;t look outside the bounds!&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;p&gt;&lt;img src=&quot;images/image21.png&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;&lt;/p&gt;
&lt;p&gt;For ties, pick the leftmost.&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;p&gt;&lt;img src=&quot;images/image17.png&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Repeat until you reach the top row.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

You will find the `Matrix_column_of_min_value_in_row` function useful
here. Each time you process a row, put the column number of the best
pixel in the seam vector, working your way from the back to front.
(i.e. The last element corresponds to the bottom row.)

![](images/seam.svg){: .invert-colors-in-dark-mode }

### Removing a Vertical Seam

`remove_vertical_seam`: 
The seam vector passed into this function contains the column numbers
of the pixels that should be removed in each row, in order from the
top to bottom rows. To remove the seam, copy the image one row at a
time, first copying the part of the row before the seam (green),
skipping that pixel, and then copying the rest (orange).

&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%&quot; /&gt;
&lt;col style=&quot;width: 50%&quot; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;p&gt;&lt;img src=&quot;images/image12.png&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;&lt;br /&gt;
Original&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;p&gt;&lt;img src=&quot;images/image23.png&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;&lt;br /&gt;
Seam Removed&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

You should copy into a smaller auxiliary `Image` and then back into
the original, because there is no way to change the width of an
existing image. Do not attempt to use `Image_init` to &quot;resize&quot; the
original - it doesn&apos;t preserve existing data in an `Image`.

### Seam Carving Algorithm

We can apply seam carving to the width of an image, the height, or both.

#### `seam_carve_width`
{: .primer-spec-toc-ignore }

To apply seam carving to the width, remove the minimal cost seam until the image has reached the appropriate width.

1.  Compute the energy matrix
2.  Compute the cost matrix
3.  Find the minimal cost seam
4.  Remove the minimal cost seam

#### `seam_carve_height`
{: .primer-spec-toc-ignore }

To apply seam carving to the height, just do the following:

1.  Rotate the image left by 90 degrees
2.  Apply `seam_carve_width`
3.  Rotate the image right by 90 degrees

#### `seam_carve`
{: .primer-spec-toc-ignore }

To adjust both dimensions:

1.  Apply `seam_carve_width`
2.  Apply `seam_carve_height`

### Testing

We have provided the `processing_public_tests.cpp` file that contains
a test suite for the seam carving algorithm that runs each of the
functions in the `processing` module and compares the output to the
&quot;`_correct`&quot; files included with the project.

You should write your own tests for the `processing` module, but you
do not need to turn them in. You may do this either by creating a copy
of `processing_public_tests.cpp` and building onto it, or writing more
tests from scratch. Pay attention to edge cases.

Use the Makefile to compile the test with this command:

```console
$ make processing_public_tests.exe
```
{: data-variant=&quot;no-line-numbers&quot; }

Then you can run the tests for the `dog`, `crabster`, and `horses`
images as follows:

```console
$ ./processing_public_tests.exe
```
{: data-variant=&quot;no-line-numbers&quot; }

You can also run the tests on just a single image:

```console
$ ./processing_public_tests.exe test1_dog
$ ./processing_public_tests.exe test2_crabster
$ ./processing_public_tests.exe test3_horses
```

When the test program runs, it will also write out image files
containing the results from your functions before asserting that they
are correct. You may find it useful to look at the results from your
own code and visually compare them to the provided correct outputs
when debugging the algorithm.

The seam carving tests work sequentially and stop at the first
deviation from correct behavior so that you can identify the point at
which your code is incorrect.

## Resize Program

The main resize program supports content-aware resizing of images via a command line interface. 

Create a `resize.cpp` file and write your implementations of the driver program there.

Compile and run the program.  The [interface](#interface-2) section explains each command line argument.
```console
$ make resize.exe
$ ./resize.exe horses.ppm horses_400x250.ppm 400 250
```
{: data-variant=&quot;no-line-numbers&quot; }

### Setup

If you created a `main.cpp` while following the setup tutorial, rename it to `resize.cpp`.  Otherwise, create a new file `resize.cpp` ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#add-new-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#add-new-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#add-new-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#add-new-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#touch)).

Add &quot;hello world&quot; code if you haven&apos;t already.
```c++
#include &lt;iostream&gt;
using namespace std;

int main() {
  cout &lt;&lt; &quot;Hello World!\n&quot;;
}
```

The resize program should compile and run.
```console
$ make resize.exe
$ ./resize.exe
Hello World!
```

Configure your IDE to debug the resize program.

&lt;table&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/resize.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/resize.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;XCode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `resize.cpp`, `Matrix.cpp`, `Image.cpp`, `processing.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `resize.cpp`
  - Exclude `Matrix_public_test.cpp`, `Matrix_tests.cpp`, `Image_public_test.cpp`, `Image_tests.cpp`, `processing_public_tests.cpp`, `main.cpp` (if present).
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

Configure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)).  We recommend starting with the smallest input, `dog.ppm dog_4x5.out.ppm 4 5`.

To compile, run, and test the smallest input at the command line:
```console
$ make resize.exe
$ ./resize.exe dog.ppm dog_4x5.out.ppm 4 5
$ diff dog_4x5.out.ppm dog_4x5.correct.ppm
```

### Interface

To resize the file
`horses.ppm` to be 400x250 pixels
and store the result in the file
`horses_400x250.ppm`, we
would use the following command:

```console
$ ./resize.exe horses.ppm horses_400x250.ppm 400 250
```
{: data-variant=&quot;no-line-numbers&quot; }

In particular, here&apos;s what each of those means:

Argument | Meaning
-------- | -------
`horses.ppm` | The name of the input file from which the image is read.
`horses_400x250.ppm` | The name of the output file to which the image is written.
`400` | The desired width for the output image.
`250` | The desired height for the output image. (Optional)

The program is invoked with three or four arguments. If
no height argument is supplied, the original height is kept (i.e. only
the width is resized). If your program takes about 30 seconds for large
images, that&apos;s ok. There&apos;s a lot of computation involved.

#### Error Checking

The program checks that the command line arguments obey
the following rules:

  - There are 4 or 5 arguments, including the executable name itself
    (i.e. `argv[0]`).
  - The desired width is greater than 0 and less than or equal to the
    original width of the input image.
  - The desired height is greater than 0 and less than or equal to the
    original height of the input image.

If any of these are violated, use the following lines of code
(literally) to print an error message.

```c++
cout &lt;&lt; &quot;Usage: resize.exe IN_FILENAME OUT_FILENAME WIDTH [HEIGHT]\n&quot;
     &lt;&lt; &quot;WIDTH and HEIGHT must be less than or equal to original&quot; &lt;&lt; endl;
```

Your program should then exit with a non-zero return value from
`main`. Do **not** use the `exit` function in the standard library, as
it does not clean up local objects.

If the input or output files cannot be opened, use the following lines
of code (literally, except change the variable `filename` to whatever
variable you have containing the name of the problematic file) to
print an error message, and then return a non-zero value from `main`.

```c++
cout &lt;&lt; &quot;Error opening file: &quot; &lt;&lt; filename &lt;&lt; endl;
```
{: data-variant=&quot;no-line-numbers&quot; }

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
You do not need to do any error checking for command line arguments or
file I/O other than what is described in this section. However, you must
use precisely the error messages given here in order to receive
credit.
&lt;/div&gt;

### Implementation

Your `main` function should not contain much code. It should just
process the command line arguments, check for errors, and then call
the appropriate functions from the other modules to perform the
desired task.

### Optional: Reading and Writing JPEG Files

Your program must handle input and output files in the PPM format, but
you may optionally also implement support for files in the JPEG format.
To do so, follow these steps:

1. Install the [libjpeg](https://libjpeg.sourceforge.net/) or
   [libjpeg-turbo](https://libjpeg-turbo.org/) library. On MacOS, you
   can run the following:

   ```console
   $ brew install jpeg-turbo
   ```

   On WSL or Linux, run the following:

   ```console
   $ sudo apt install libjpeg-turbo8-dev
   ```

2. Edit the `Makefile` and set `USE_LIBJPEG` to `true`:

   ```make
   USE_LIBJPEG ?= true
   ```

   On MacOS, you will also need to set `LIBJPEG_PATH`. Run the
   following in the terminal:

   ```console
   $ brew info jpeg-turbo
   ```

   You should see output like the following:

    ```text
   ==&gt; jpeg-turbo: stable 3.0.2 (bottled), HEAD
   JPEG image codec that aids compression and decompression
   https://www.libjpeg-turbo.org/
   /opt/homebrew/Cellar/jpeg-turbo/3.0.2 (44 files, 3.4MB) *
   ...
   ```
   {: data-variant=&quot;no-line-numbers&quot; }
   {: data-highlight=&quot;4&quot; }

   Set `LIBJPEG_PATH` to the path you see in the output, e.g.

   ```make
   LIBJPEG_PATH ?= /opt/homebrew/Cellar/jpeg-turbo/3.0.2
   ```

3. In `resize.cpp`, add the following `#include`. Do not add it in any other files.

   ```c++
   #include &quot;jpeg.hpp&quot;
   ```

   You can then make use of the following functions defined in
   `jpeg.hpp`:

   - `has_jpeg_extension()` determines whether a file name ends with
      `.jpg` or `.jpeg`, ignoring capitalization – use this to
      determine whether the files specified at the command line are
      JPEG files
   - `read_jpeg()` reads a JPEG image from a file into an `Image`
     object
   - `write_jpeg()` writes an image from an `Image` object into a JPEG
     file

   See the full documentation of each function in `jpeg.hpp`.

4. Once you are sure that your program is working, you may wish to
   compile with optimization enabled to make it run significantly
   faster:

   ```console
   $ make clean
   $ make resize.exe CXXFLAGS=&quot;--std=c++17 -O3&quot;
   ```

   Even with optimizations enabled, seam carving is quite expensive.
   We recommend using input images that are no larger than 1000x1000
   pixels.

## Submission and Grading
Submit to the autograder using this direct autograder link: [https://autograder.io/web/project/3030](https://autograder.io/web/project/3030).
  - `Matrix.cpp`
  - `Matrix_tests.cpp`
  - `Image.cpp`
  - `Image_tests.cpp`
  - `processing.cpp`
  - `resize.cpp`

This project will be autograded for correctness, comprehensiveness of
your test cases, and programming style. See the [style checking
tutorial](https://eecs280staff.github.io/tutorials/setup_style.html)
for the criteria and how to check your style automatically on CAEN.

### Testing

Run all the unit tests and system tests.  This includes the public tests we provided and the unit tests that you wrote.

```console
$ make test
```

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Run commands in parallel with `make -j`.
```console
$ make -j4 test
```
{: data-variant=&quot;no-line-numbers&quot; }
&lt;/div&gt;

### Unit Test Grading

We will autograde your `Matrix` and `Image` unit tests.

Your unit tests must use the [unit test framework](https://eecs280staff.github.io/unit_test_framework/).

A test suite must complete less than 5 seconds and contain 50 or fewer `TEST()` items.  One test suite is one `_test.cpp` file.

To grade your unit tests, we use a set of intentionally buggy instructor solutions.  You get points for catching the bugs.

1.  We compile and run your unit tests with a **correct solution**.
    - Tests that pass are **valid**.
    - Tests that fail are **invalid**, they falsely report a bug.
3.  We compile and run all of your **valid** tests against each **buggy solution**.
    - If any of your tests fail, you caught the bug.
    - You earn points for each bug that you catch.

### Requirements and Restrictions
It is our goal for you to gain practice with good C-style object-based
programming and proper use of pointers and structs. Here are
some (mandatory) guidelines.

| DO | DO NOT |
| -- | ------ |
| Use *either* traversal by pointer or traversal by index, as necessary | |
| Modify `.cpp` files | Modify `.hpp` files |
| Put any extra helper functions in the `.cpp` files and declare them `static` | Modify `.hpp` files |
| | `#include` a `.hpp` file from a module that does not require the code in the `.hpp` file (e.g. including `Image.hpp` from `Matrix.cpp`), as this introduces an incorrect dependency between modules |
| `#include` a library to use its functions | Assume that the compiler will find the library for you (some do, some don&apos;t) |
| Pass large structs or classes by pointer | Pass large structs or classes by value |
| Pass by pointer-to-const when appropriate | &quot;I don&apos;t think I&apos;ll modify it ...&quot; |


### Diagnosing Slow Code
If your code runs too slowly (especially on larger images like the &quot;horses&quot;
example), a tool called `perf` can analyze which parts of your code take
the most time. See the [Perf Tutorial](perf.html) for details.

### Undefined Behavior
If your code produces different results on different machine (e.g.
your computer vs. the autograder), the likely source is undefined behavior.
Refer to the [Sanitizers Tutorial](https://eecs280staff.github.io/tutorials/setup_asan.html)
for how to use the Address Sanitizer (ASAN) to check for undefined behavior.

## Reach Goals
Optionally check out the project [reach goals](extra.html).  Reach goals are entirely optional.


## Acknowledgments
This project was written by James Juett, Winter 2016 at the University
of Michigan. It was inspired by Josh Hug&apos;s &quot;Nifty Assignment&quot; at
SIGCSE 2015.
</data>
      <data key="v_name">chunk-56f089ad684730c76782bd5994888a3a</data>
      <data key="v_id">n111</data>
    </node>
    <node id="n112">
      <data key="v_hash_id">chunk-ebb71aa553680fa66eb7ba7ab0a35328</data>
      <data key="v_content">---
layout: spec
latex: true
mermaid: true
---

EECS 280 Project 4: Machine Learning
====================================
{: .primer-spec-toc-ignore }

Winter 2025 release.

Project due 8:00pm EST Friday March 28, 2024.

You may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)).

## Introduction

Automatically identify the subject of posts from the EECS 280 Piazza using natural language processing and machine learning techniques.

The learning goals of this project include using container ADTs, such as sets and maps. You will also gain experience designing and implementing a substantial application program.

For example, your program will be able to read a Piazza post like this and figure out that it&apos;s about Project 3: Euchre.

&lt;img src=&quot;images/image28.png&quot; width=&quot;640px&quot; /&gt;


## Setup
Set up your visual debugger and version control, then submit to the autograder.

### Visual debugger
During setup, name your project `ml-classifier`. Use this starter files link: `https://eecs280staff.github.io/ml-classifier/starter-files.tar.gz`

| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |

You should end up with a folder with starter files that look like this. You may also have a `main.cpp` file after following the setup tutorial, which you should rename to `classifier.cpp`. If not, you will create a `classifier.cpp` file in the [Classifier](#classifier) section.
```console
$ ls
Makefile						train_small.csv
csvstream.hpp					train_small_train_only.out.correct
instructor_student.out.correct	w14-f15_instructor_student.csv
projects_exam.out.correct		w16_instructor_student.csv
sp16_projects_exam.csv			w16_projects_exam.csv
test_small.csv					w16_projects_exam_train_only.out.correct
test_small.out.correct
```
{: data-variant=&quot;no-line-numbers&quot; }

Here&apos;s a short description of each starter file.

| File(s) | Description |
| ------- | ----------- |
| `csvstream.hpp` | Library for reading CSV files. |
| `train_small.csv`&lt;br&gt; `test_small.csv`&lt;br&gt; `test_small.out.correct`&lt;br&gt; `train_small_train_only.out.correct` | Sample input and output for the classifier. |
| `sp16_projects_exam.csv`&lt;br&gt; `w14-f15_instructor_student.csv`&lt;br&gt; `w16_instructor_student.csv`&lt;br&gt; `w16_projects_exam.csv`&lt;br&gt;`w16_projects_exam_train_only.out.correct`&lt;br&gt; `instructor_student.out.correct`&lt;br&gt; `projects_exam.out.correct` | Piazza data input from past terms, with correct output. |
| `Makefile` | Helper commands for building. |

### Version control
Set up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).

After you&apos;re done, you should have a local repository with a &quot;clean&quot; status and your local repository should be connected to a remote GitHub repository.
```console
$ git status
On branch main
Your branch is up-to-date with &apos;origin/main&apos;.

nothing to commit, working tree clean
$ git remote -v
origin	https://github.com/awdeorio/ml-classifier.git (fetch)
origin	https://githubcom/awdeorio/ml-classifier.git (push)
```

You should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).
```console
$ head .gitignore
# This is a sample .gitignore file that&apos;s useful for C++ projects.
...
```

### Group registration
Register your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.


## ML and NLP Background
&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Skim this section the first time through.  Refer back to it while you&apos;re coding the [Classifier](#classifier).
&lt;/div&gt;

### Machine Learning and Classification

The goal for this project is to write an intelligent program that can
**classify** Piazza posts according to topic. This task is easy for humans -
we simply read and understand the content of the post, and the topic is
intuitively clear. But how do we compose an algorithm to do the same? We
can&apos;t just tell the computer to &quot;look at it&quot; and understand. This is
typical of problems in artificial intelligence and natural language
processing.

![](images/image28.png)

We know this is about Euchre, but how can we write an algorithm that
&quot;knows&quot; that?

With a bit of introspection, we might realize each individual word is a
bit of evidence for the topic about which the post was written. Seeing a
word like &quot;card&quot; or &quot;spades&quot; leads us toward the Euchre
project. We judge a potential label for a post based on how likely it is
given all the evidence. Along these lines, information about how common
each word is for each topic essentially constitutes our classification
algorithm.

But we don&apos;t have that information (i.e. that algorithm). You could try
to sit down and write out a list of common words for each project, but
there&apos;s no way you&apos;ll get them all. For example, the word &quot;lecture&quot;
appears much more frequently in posts about exam preparation. This makes
sense, but we probably wouldn&apos;t come up with it on our own. And what if
the projects change? We don&apos;t want to have to put in all that work
again.

Instead, let&apos;s write a program to comb through Piazza posts from
previous terms (which are already tagged according to topic) and learn
which words go with which topics. Essentially, the result of our program
is an algorithm! This approach is called (supervised) machine learning.
Once we&apos;ve trained the classifier on some set of Piazza posts, we can
apply it to new ones written in the future.

![](images/image29.png){: .invert-colors-in-dark-mode }

At a high level, the classifier we&apos;ll implement works by assuming a
probabilistic model of how Piazza posts are composed, and then finding
which label (e.g. our categories of  &quot;euchre&quot;, &quot;exam&quot;, etc.) is the most
probable source of a particular post.

All the details of natural language processing (NLP) and machine
learning (ML) techniques you need to implement the project are described
here. You are welcome to consult other resources, but there are many
kinds of classifiers that have subtle differences. The classifier we
describe here is a simplified version of a &quot;Multi-Variate Bernoulli
Naive Bayes Classifier&quot;. If you find other resources, but you&apos;re not
sure they apply, make sure to check them against this specification.

[This document](naive_bayes.html) provides a more complete description
of the way the classifier works, in case you&apos;re interested in the math
behind the formulas here.

### Piazza Dataset

For this project, we retrieved archived Piazza posts from EECS 280 in
past terms. We will focus on two different ways to divide Piazza posts
into labels (i.e. categories).

- By **topic**. Labels: &quot;exam&quot;, &quot;calculator&quot;, &quot;euchre&quot;, &quot;image&quot;, &quot;recursion&quot;,
  &quot;statistics&quot;

  Example: Posts extracted from `w16_projects_exam.csv`

  | label | content |
  | ----- | ------- |
  | exam | will final grades be posted within 72 hours |
  | calculator | can we use the friend class list in stack |
  | euchre | weird problem when i try to compile euchrecpp |
  | image | is it normal for the horses tests to take 10 minutes |
  | recursion | is an empty tree a sorted binary tree |
  | statistics | are we supposed to have a function for summary |
  | ... | ... |

- By **author**. Labels: &quot;instructor&quot;, &quot;student&quot;

  Example: Posts extracted from `w14-f15_instructor_student.csv`

  | label | content |
  | ----- | ------- |
  | instructor | disclaimer not actually a party just extra OH |
  | student | how can you use valgrind with calccpp |
  | student | could someone explain to me what the this keyword means |
  | ... | ... |

The Piazza datasets are Comma Separated Value (CSV) files. The label for
each post is found in the &quot;tag&quot; column, and the content in the
&quot;content&quot; column. There may be other columns in the CSV file; your
code should ignore all but the &quot;tag&quot; and &quot;content&quot; columns. **You may
assume all Piazza files are formatted
correctly, and that post content and labels only contain lowercase
characters, numbers, and no punctuation.** You must use the
`csvstream.hpp` library (see
[https://github.com/awdeorio/csvstream](https://github.com/awdeorio/csvstream) for
documentation) to read CSV files in your application. The
`csvstream.hpp` file itself is included with the starter code.

**Your classifier should not hardcode any labels. Instead, it should use
the exact set of labels that appear in the training data.**

&lt;div id=&quot;splitting-a-whitespace-delimited-string&quot; class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Here&apos;s how to split a string into words. You may use this code as given.
```c++
// EFFECTS: Return a set of unique whitespace delimited words
set&lt;string&gt; unique_words(const string &amp;str) {
  istringstream source(str);
  set&lt;string&gt; words;
  string word;
  while (source &gt;&gt; word) {
    words.insert(word);
  }
  return words;
}
```
&lt;/div&gt;

We have included several Piazza datasets with the project:
  - `train_small.csv` - Made up training data intended for small-scale
    testing.
  - `test_small.csv` - Made up test data intended for small-scale
    testing.
  - `w16_projects_exam.csv` - (Train) Real posts from W16 labeled by
    topic.
  - `sp16_projects_exam.csv` - (Test) Real posts from Sp16 labeled by
    topic.
  - `w14-f15_instructor_student.csv` - (Train) Real posts from four
    terms labeled by author.
  - `w16_instructor_student.csv` - (Test) Real posts from W16 Piazza
    labeled by author.

For the real datasets, we have indicated which are intended for training
vs. testing.

### Bag of Words Model

We will treat a Piazza post as a &quot;**bag of words**&quot; - each post is simply characterized by which words it includes. The ordering of words is ignored, as are multiple occurrences of the same word. These two posts would be considered equivalent:
- &quot;the left bower took the trick&quot;
- &quot;took took trick the left bower bower&quot;

Thus, we could imagine the post-generation process as a person sitting down and going through every possible word and deciding which to toss into a bag.

#### Conditional Probability

We write $$ P(A) $$ to denote the probability (a number
between 0 and 1) that some event $$ A $$ will occur.
$$ P(A \mid B) $$ denotes the probability that event
$$ A $$ will occur given that we already know event
$$ B $$ has occurred. For example,
$$ P(bower \mid euchre) \approx 0.007 $$. This means that if a Piazza post is about the
euchre project, there is a 0.7% chance it will contain the word bower
(we should say &quot;at least once&quot;, technically, because of the bag of words
model).

### Training

Before the classifier can make predictions, it needs to be trained on a
set of previously labeled Piazza posts (e.g. `train_small.csv` or
`w16_projects_exam.csv`). Your application should process each post in
the training set, and record the following information:

  - The total number of posts in the entire training set.
  - The number of unique words in the entire training set. (The
    **vocabulary size**.)
  - For each word $$ w $$, the number of posts in the
    entire training set that contain $$ w $$.
  - For each label $$ C $$, the number of posts with that
    label.
  - For each label $$ C $$ and word
    $$ w $$, the number of posts with label
    $$ C $$ that contain $$ w $$.

### Prediction

How do we predict a label for a new post?

Given a new Piazza post $$ X $$, we must determine the
most probable label $$ C $$, based on what the classifier
has learned from the training set. A measure of the likelihood of $$ C $$ is
the **log-probability score** given the post:

$$
\ln P(C) + \ln P(w_1 \mid C) + \ln P(w_2 \mid C) + \cdots + \ln P(w_n \mid C)
$$

**Important**: Because we&apos;re using the bag-of-words model, the words $$ w_1, w_2, \ldots, w_n $$ in this formula are only the [unique
words](#splitting-a-whitespace-delimited-string) in the
post, not including duplicates\! To ensure consistent results, make
sure to add the contributions from each word in alphabetic order.

The classifier should predict whichever label has the highest
log-probability score for the post. If multiple labels are tied, predict
whichever comes first alphabetically.

$$ \ln P(C) $$ is the **log-prior** probability of label
$$ C $$ and is a reflection of how common it is:

$$
\ln P(C) = \ln \left( \frac{\text{number of training posts with label } C}{\text{number of training posts}} \right)
$$

$$ \ln P(w \mid C) $$ is the **log-likelihood** of a word
$$ w $$ given a label $$ C $$, which is a
measure of how likely it is to see word $$ w $$ in posts
with label $$ C $$. The regular formula for
$$ \ln P(w \mid C) $$ is:

$$
\ln P(w \mid C) = \ln \left( \frac{\text{number of training posts with label } C \text{ that contain } w}{\text{number of training posts with label } C} \right)
$$

However, if $$ w $$ was never seen in a post with label
$$ C $$ in the training data, we get a log-likelihood of
$$ -\infty $$, which is no good. Instead, use one of these two alternate formulas:

---

$$
\ln P(w \mid C) = \ln \left( \frac{\text{number of training posts that contain } w}{\text{number of training posts}} \right)
$$

(Use when $$ w $$ does not occur in posts labeled $$ C $$ but does occur in the training data overall.)

---

$$
\ln P(w \mid C) = \ln \left( \frac{1}{\text{number of training posts}} \right)
$$

(Use when $$ w $$ does not occur anywhere at all in the
training set.)

---


## Classifier

Write the classifier in `classifier.cpp` using the [bag of words model](#bag-of-words-model).

Run the classifier on a small dataset.
```console
$ ./classifier.exe train_small.csv test_small.csv
```

### Setup

If you created a `main.cpp` while following the setup tutorial, rename it to `classifier.cpp` if you have not already done so.  Otherwise, create a new file `classifier.cpp` ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#add-new-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#add-new-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#add-new-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#add-new-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#touch)).

Add &quot;hello world&quot; code if you haven&apos;t already.
```c++
#include &lt;iostream&gt;
using namespace std;

int main() {
  cout &lt;&lt; &quot;Hello World!\n&quot;;
}
```

The classifier program should compile and run.
```console
$ make classifier.exe
$ ./classifier.exe
Hello World!
```

Configure your IDE to debug the classifier program.

&lt;table&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/classifier.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/classifier.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Xcode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `classifier.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `classifier.cpp`
  - Exclude any other tests
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

Configure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)). We recommend starting with the smallest input in train-only mode, `train_small.csv`.

To compile and run the smallest input at the command line:
```console
$ make classifier.exe
$ ./classifier.exe train_small.csv
```

### Command Line Interface

Here is the usage message for the top-level application:
```console
$ ./classifier.exe
Usage: classifier.exe TRAIN_FILE [TEST_FILE]
```

The classifier application always requires a file for training, and it optionally takes a file for testing. The training file must have at least one post, but the test file may have no posts. You may assume all files are in the correct format, with a header that has at least the &quot;tag&quot; and &quot;content&quot; columns.

Use the provided small-scale files for initial testing and to check your output formatting:

```console
$ ./classifier.exe train_small.csv
$ ./classifier.exe train_small.csv test_small.csv
```

Correct output is in `train_small_train_only.out.correct` and
`test_small.out.correct`. The output format is discussed in detail below.

#### Error Checking

The program checks that the command line arguments obey the following
rule:

- There are 2 or 3 arguments, including the executable name itself
  (i.e. `argv[0]`).

If this is violated, print out the usage message and then quit
by returning a non-zero value from `main`. **Do not use the `exit`
library function, as this fails to clean up local objects.**

```c++
cout &lt;&lt; &quot;Usage: classifier.exe TRAIN_FILE [TEST_FILE]&quot; &lt;&lt; endl;
```
{: data-variant=&quot;no-line-numbers&quot; }

If any file cannot be opened, print out the following message, where
`filename` is the name of the file that could not be opened, and quit by
returning a non-zero value from `main`.

```c++
cout &lt;&lt; &quot;Error opening file: &quot; &lt;&lt; filename &lt;&lt; endl;
```
{: data-variant=&quot;no-line-numbers&quot; }

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** The `csvstream` constructor will throw a `csvstream_exception` containing the correct error message if a file cannot be opened. The example at [https://github.com/awdeorio/csvstream#error-handling](https://github.com/awdeorio/csvstream#error-handling) shows how to handle the exception with a `try`/`catch` block.
&lt;/div&gt;

You do not need to do any error checking for command-line arguments or
file I/O other than what is described on this page. However, you must
use precisely the error messages given here in order to receive credit.
(**Just literally use the code given here to print them.**)

As mentioned earlier, you may assume all Piazza data files are in the
correct format.

### Design

Here is some high-level guidance:

1.  First, your application should read posts from a file (e.g.
    `train_small.csv`) and use them to train the classifier. After
    training, your classifier abstraction should store the information
    mentioned in the [Training](#training) section.
2.  Your classifier should be able to compute the log-probability
    score of a post (i.e. a collection of words) given a particular
    label. To predict a label for a new post, it should choose the label
    that gives the highest log-probability score.  See the [Prediction](#prediction) section.
3.  Read posts from a file (e.g. `test_small.csv`) to use as testing
    data. For each post, predict a label using your classifier.

Some of these steps have output associated with them. See the &quot;output&quot;
section below for the details.

The structure
of your classifier application, including which procedural abstractions
and/or ADTs to use for the classifier, is entirely up to you. Make sure
your decisions are informed by carefully considering the classifier and
top-level application described in this specification.

We **strongly** suggest you make a class to represent the classifier - the
private data members for the class should keep track of the classifier
parameters learned from the training data, and the public member
functions should provide an interface that allows you to train the
classifier and make predictions for new piazza posts.

You should write RMEs and appropriate comments to describe the
interfaces for the abstractions you choose (ADTs, classes, functions,
etc.). You should also write unit tests to verify each component works
on its own.

You are welcome to use any part of the C++ standard library in your top-level classifier
application. See our [C++ Standard Library Containers](containers.html) reference for a description of several containers and examples of how to use them. In particular, `std::map` and `std::set` will be
useful for this project.

### Example

We&apos;ve provided full example output for a small input (`train_small.csv` and `test_small.csv`).  The output is in `test_small.out.correct`.  The output in train-only mode is in `train_small_train_only.out.correct`, here we&apos;ve indicated train-only output with &quot;(TRAIN-ONLY)&quot;.  Some lines are indented by two spaces.

To run this example at the command line in train-only mode:
```console
$ make classifier.exe
$ ./classifier.exe train_small.csv
```

To run with test data and generate predictions:
```console
$ ./classifier.exe train_small.csv test_small.csv
```

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Debug output differences with `diff -y -B`, which shows differences side-by-side and ignores whitespace.  We&apos;ll use the `less` pager so we can scroll through the long terminal output.  Press `q` to quit.
```console
$ make classifier.exe
$ ./classifier.exe train_small.csv &gt; train_small_train_only.out
$ diff -y -B train_small_train_only.out train_small_train_only.out.correct | less  # q to quit
```
&lt;/div&gt;

Add this line at the beginning of your `main` function to set floating
point precision:

```c++
cout.precision(3);
```
{: data-variant=&quot;no-line-numbers&quot; }

First, print information about the training data:

- (TRAIN-ONLY) Line-by-line, the label and content for each training document.
  ```
  training data:
    label = euchre, content = can the upcard ever be the left bower
    label = euchre, content = when would the dealer ever prefer a card to the upcard
    label = euchre, content = bob played the same card twice is he cheating
    ...
    label = calculator, content = does stack need its own big three
    label = calculator, content = valgrind memory error not sure what it means
  ```
  {: data-variant=&quot;no-line-numbers&quot; }
- The number of training posts.
  ```
  trained on 8 examples
  ```
  {: data-variant=&quot;no-line-numbers&quot; }
- (TRAIN-ONLY) The vocabulary size (the number of unique words in all training content).
  ```
  vocabulary size = 49
  ```
  {: data-variant=&quot;no-line-numbers&quot; }
- An extra blank line

In train-only mode, also print information about the classifier
trained on the training posts. Whenever classes or words are listed,
they are in alphabetic order.

- (TRAIN-ONLY) The classes in the training data, and the number of examples for each.
  ```
  classes:
    calculator, 3 examples, log-prior = -0.981
    euchre, 5 examples, log-prior = -0.47
  ```
  {: data-variant=&quot;no-line-numbers&quot; }
- (TRAIN-ONLY) For each label, and for each word that occurs for that label: The
  number of posts with that label that contained the word, and the
  log-likelihood of the word given the label.
  ```
  classifier parameters:
    calculator:assert, count = 1, log-likelihood = -1.1
    calculator:big, count = 1, log-likelihood = -1.1
    ...
    euchre:twice, count = 1, log-likelihood = -1.61
    euchre:upcard, count = 2, log-likelihood = -0.916
    ...
   ```
   {: data-variant=&quot;no-line-numbers&quot; }
- (TRAIN-ONLY) An extra blank line

Finally, if a test file is provided, use the classifier to predict
classes for each example in the testing data. Print information about
the test data as well as these predictions.

- Line-by-line, the &quot;correct&quot; label, the predicted label and its log-probability
  score, and the content for each test. Insert a blank line after each for
  readability.
  ```
  test data:
    correct = euchre, predicted = euchre, log-probability score = -13.7
    content = my code segfaults when bob is the dealer

    correct = euchre, predicted = calculator, log-probability score = -12.5
    content = no rational explanation for this bug

    correct = calculator, predicted = calculator, log-probability score = -13.6
    content = countif function in stack class not working
  ```
  {: data-variant=&quot;no-line-numbers&quot; }
- The number of correct predictions and total number of test posts.
  ```
  performance: 2 / 3 posts predicted correctly
  ```
  {: data-variant=&quot;no-line-numbers&quot; }

The last thing printed should be a newline character.

### Accuracy

In case you&apos;re curious, here&apos;s the accuracy for the large datasets. Not too bad!

|                               Command                                |  Accuracy   |
| -------------------------------------------------------------------- | ----------- |
| `./classifier.exe w16_projects_exam.csv sp16_projects_exam.csv`              | 245 / 332   |
| `./classifier.exe w14-f15_instructor_student.csv w16_instructor_student.csv` | 2602 / 2988 |

### Efficiency

While efficiency is not a primary goal for this project, you should
aim for your code to run the largest test case above in no more than a
minute. Some common causes of slowdown you should avoid:

- Processing a post more than once (including reading it more than
  once or saving all the data in a vector).
- Iterating over a map to find something rather than using `[]` or `find()`.
- Passing strings, pairs, or containers by value.
- Iterating by value in a range-based for loop.

Refer to the [Project 2 perf
tutorial](https://eecs280staff.github.io/p2-cv/perf.html)
for instructions on how to use the `perf` tool to identify slow
functions.

## Submission and Grading

Submit these files to the [autograder](https://autograder.io).
  - `classifier.cpp`

This project will be autograded for correctness and programming style. See the [style checking
tutorial](https://eecs280staff.github.io/p1-stats/setup_style.html)
for the criteria and how to check your style automatically on CAEN.

### Testing

Run all the tests.  For this project, the tests only consist of system tests.

```console
$ make test
```

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Run commands in parallel with `make -j`.
```console
$ make -j4 test
```
{: data-variant=&quot;no-line-numbers&quot; }
&lt;/div&gt;

### Requirements and Restrictions

| DO | DO NOT |
| -- | ------ |
| Put all top-level application code in `classifier.cpp`. | Create additional files other than `classifier.cpp`. |
| Create any ADTs or functions you wish for your top-level classifier application. | Write everything in the `main()` function. |
| Use any part of the C++ standard library for your top level classifier application, including `map` and `set`. | Write your own implementation of maps and sets -- they will likely be too slow. |
| Follow course style guidelines. | Use non-const static or global variables. |
| [Check for undefined behavior](https://eecs280staff.github.io/p1-stats/setup_asan.html#p1-stats) using address sanitizer and other tools | &quot;It runs fine on my machine!&quot; |


## Acknowledgments

Andrew DeOrio and James Juett wrote the original project and specification. Amir Kamil contributed to code structure, style, and implementation details. This project was developed for EECS 280, Fall 2016 at the University of Michigan. The classifer was forked into a separate project in Fall 2024.
</data>
      <data key="v_name">chunk-ebb71aa553680fa66eb7ba7ab0a35328</data>
      <data key="v_id">n112</data>
    </node>
    <node id="n113">
      <data key="v_hash_id">chunk-88c3276aa3d516a88e6627f42cbd462f</data>
      <data key="v_content">---
layout: spec
latex: true
mermaid: true
---

EECS 280 Project 6: Binary Search Trees and Maps
================================================
{: .primer-spec-toc-ignore }

Fall 2024 release.

Project due 8:00pm EST Monday December 9, 2024.

You may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)). If you work alone, you must work alone on both the checkpoint and the full project. If you work with a partner, you must work with the same partner on the checkpoint and the full project. You may not work alone on the checkpoint and then add a partner for the full project.

## Introduction

In this project, you implement a map container (similar to `std::map`) based on an underlying binary search tree data structure. The learning goals of this project include functors, templates, recursion, binary search trees, and associative containers.

## Setup
Set up your visual debugger and version control, then submit to the autograder.

### Visual debugger
During setup, name your project `bst-map`. Use this starter files link: `https://eecs280staff.github.io/bst-map/starter-files.tar.gz`

| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |

You should end up with a folder with starter files that look like this.  You may have already renamed files like `Map.hpp.starter` to `Map.hpp`. You may also have a `main.cpp` file after following the setup tutorial. If so, delete the file.
```console
$ ls
BinarySearchTree.hpp.starter		Map_compile_check.cpp
BinarySearchTree_compile_check.cpp	Map_public_tests.cpp
BinarySearchTree_public_tests.cpp	Map_tests.cpp.starter
BinarySearchTree_tests.cpp.starter	TreePrint.hpp
Makefile							unit_test_framework.hpp
Map.hpp.starter
```
{: data-variant=&quot;no-line-numbers&quot; }

Here&apos;s a short description of each starter file.

| File(s) | Description |
| ------- | ----------- |
| `BinarySearchTree.hpp.starter` | Starter code for `BinarySearchTree`. |
| `BinarySearchTree_tests.cpp.starter` | Your `BinarySearchTree` unit tests. |
| `BinarySearchTree_public_tests.cpp` | A small test for `BinarySearchTree` |
| `BinarySearchTree_compile_check.cpp` | Compile check test for `BinarySearchTree` |
| `TreePrint.hpp` | Test helper function for printing trees. |
| `Map.hpp.starter` | Starter code for `Map`. |
| `Map_tests.cpp.starter` | Your `Map` unit tests. |
| `Map_public_tests.cpp` | Your `Map` unit tests. |
| `Map_compile_check.cpp` | Compile check test for `Map`. |
| `Makefile` | Helper commands for building. |
| `unit_test_framework.hpp` | A simple unit-testing framework. |

### Version control
Set up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).

After you&apos;re done, you should have a local repository with a &quot;clean&quot; status and your local repository should be connected to a remote GitHub repository.
```console
$ git status
On branch main
Your branch is up-to-date with &apos;origin/main&apos;.

nothing to commit, working tree clean
$ git remote -v
origin	https://github.com/awdeorio/bst-map.git (fetch)
origin	https://githubcom/awdeorio/bst-map.git (push)
```

You should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).
```console
$ head .gitignore
# This is a sample .gitignore file that&apos;s useful for C++ projects.
...
```

### Group registration
Register your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.


## BinarySearchTree

A binary search tree supports efficiently storing and searching for
elements.

Write implementations in `BinarySearchTree.hpp` for each `_impl` function.  The file already contains function stubs and you should replace the `assert(false)` with your code.  For example:
```c++
static bool empty_impl(const Node *node) {
  assert(false);  // Replace with your code
}
```
{: data-title=&quot;BinarySearchTree.hpp&quot; }

Run the public Binary Search Tree tests.
```console
$ make BinarySearchTree_compile_check.exe
$ make BinarySearchTree_public_tests.exe
$ ./BinarySearchTree_public_tests.exe
```

Write tests for `BinarySearchTree` in `BinarySearchTree_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You&apos;ll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.
```console
$ make BinarySearchTree_tests.exe
$ ./BinarySearchTree_tests.exe
```

Submit `BinarySearchTree.hpp` and `BinarySearchTree_tests.cpp` to the [autograder](https://autograder.io).

### Setup
Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):
-  `BinarySearchTree.hpp.starter` -&gt; `BinarySearchTree.hpp`
-  `BinarySearchTree_tests.cpp.starter` -&gt; `BinarySearchTree_tests.cpp`

The BinarySearchTree tests should compile and run. The public tests and compile check will fail until you implement the functions.  The test you write (`BinarySearchTree_tests.cpp`) will pass because the starter file only contains `ASSERT_TRUE(true)`.
```console
$ make BinarySearchTree_compile_check.exe
$ make BinarySearchTree_public_tests.exe
$ ./BinarySearchTree_public_tests.exe
$ make BinarySearchTree_tests.exe
$ ./BinarySearchTree_tests.exe
```

Configure your IDE to debug either the public tests or your own tests.

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;/th&gt;
  &lt;th&gt;
  Public tests
  &lt;/th&gt;
  &lt;th&gt;
  Your own tests
  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/BinarySearchTree_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/BinarySearchTree_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/BinarySearchTree_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/BinarySearchTree_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Xcode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `BinarySearchTree_public_tests.cpp`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `BinarySearchTree_tests.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `BinarySearchTree_public_tests.cpp`
  - Exclude any other tests
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `BinarySearchTree_tests.cpp`
  - Exclude any other tests
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

### Template Parameters

`BinarySearchTree` has two template parameters:

  - `T` - The type of elements stored within the tree.
  - `Compare` - The type of comparator object (a functor) that should be
    used to determine whether one element is less than another. The
    default type is `std::less&lt;T&gt;`, which compares two `T` objects with
    the `&lt;` operator. To compare elements in a different fashion, a
    custom comparator type must be specified.

### No Duplicates Invariant

In the context of this project, duplicate values are NOT allowed in a
BST. This does not need to be the case, but it avoids some distracting
complications.

### Sorting Invariant

A binary search tree is special in that the structure of the tree
corresponds to a sorted ordering of elements and allows efficient
searches (i.e. in logarithmic time).

Every node in a well-formed binary search tree must obey this sorting
invariant:

- It represents an empty tree (i.e. a null `Node*`).

\- OR -

- The left subtree obeys the sorting invariant, and every element in
  the left subtree is less than the root element (i.e. this node).

  \- AND -

  The right subtree obeys the sorting invariant, and the root element
  (i.e. this node) is less than every element in the right subtree.

Put briefly, go left and you&apos;ll find smaller elements. Go right and
you&apos;ll find bigger ones. For example, the following are all well-formed
sorted binary trees:

&lt;!--
```
      4                1
    /   \             / \
   2      6               2
  / \    / \             / \
 1   3  5   7               4
/ \ / \/ \ / \             / \
```
{: data-variant=&quot;no-line-numbers&quot; }
--&gt;

```mermaid
flowchart TB
  %% Binary tree 2
  subgraph tree2[&quot;Valid&quot;]
    direction TB
    tree2_1((1)) --&gt; tree2_1_L((&quot; &quot;)) &amp; tree2_2((2))
    tree2_2 --&gt; tree2_2_L((&quot; &quot;)) &amp; tree2_4((4))
    tree2_4 --&gt; tree2_4_L((&quot; &quot;)) &amp; tree2_4_R((&quot; &quot;))
  end

  %% Binary tree 1
  subgraph tree1[&quot;Valid&quot;]
    direction TB
    tree1_4((4)) --&gt; tree1_2((2)) &amp; tree1_6((6))
    tree1_2 --&gt; tree1_1((1)) &amp; tree1_3((3))
    tree1_1 --&gt; tree1_1_L((&quot; &quot;)) &amp; tree1_1_R((&quot; &quot;))
    tree1_3 --&gt; tree1_3_L((&quot; &quot;)) &amp; tree1_3_R((&quot; &quot;))

    tree1_6 --&gt; tree1_5((5)) &amp; tree1_7((7))
    tree1_5 --&gt; tree1_5_L((&quot; &quot;)) &amp; tree1_5_R((&quot; &quot;))
    tree1_7 --&gt; tree1_7_L((&quot; &quot;)) &amp; tree1_7_R((&quot; &quot;))
  end
```

While the following are not:

&lt;!--
```
   1          1              4               3
  / \        / \            /  \            /  \
 2          2   3          3    6          2    7
/ \        / \ / \        / \    \        / \
                         2   1    7      1   5
                        / \ / \  / \    / \ / \
```
{: data-variant=&quot;no-line-numbers&quot; }
--&gt;

```mermaid
flowchart TB
  %% Binary tree 4
  subgraph tree4[&quot;Invalid&quot;]
    direction TB
    tree4_3((3)) --&gt; tree4_2((2)) &amp; tree4_7((7))
    tree4_2 --&gt; tree4_1((1)) &amp; tree4_5((5))
    tree4_1 --&gt; tree4_1_L((&quot; &quot;)) &amp; tree4_1_R((&quot; &quot;))
    tree4_5 --&gt; tree4_5_L((&quot; &quot;)) &amp; tree4_5_R((&quot; &quot;))
  end

  %% Binary tree 3
  subgraph tree3[&quot;Invalid&quot;]
    direction TB
    tree3_4((4)) --&gt; tree3_3((3)) &amp; tree3_6((6))
    tree3_3 --&gt; tree3_2((2)) &amp; tree3_1((1))
    tree3_2 --&gt; tree3_2_L((&quot; &quot;)) &amp; tree3_2_R((&quot; &quot;))
    tree3_1 --&gt; tree3_1_L((&quot; &quot;)) &amp; tree3_1_R((&quot; &quot;))

    tree3_6 --&gt; tree3_7((7))
    tree3_7 --&gt; tree3_7_L((&quot; &quot;)) &amp; tree3_7_R((&quot; &quot;))
  end

  %% Binary tree 2
  subgraph tree2[&quot;Invalid&quot;]
    direction TB
    tree2_1((1)) --&gt; tree2_2((2)) &amp; tree2_3((3))
    tree2_2 --&gt; tree2_2_L((&quot; &quot;)) &amp; tree2_2_R((&quot; &quot;))
    tree2_3 --&gt; tree2_3_L((&quot; &quot;)) &amp; tree2_3_R((&quot; &quot;))
  end

  %% Binary tree 1
  subgraph tree1[&quot;Invalid&quot;]
    direction TB
    tree1_1((1)) --&gt; tree1_2((2)) &amp; tree1_1_R((&quot; &quot;))
    tree1_2 --&gt; tree1_2_L((&quot; &quot;)) &amp; tree1_2_R((&quot; &quot;))
  end
```

**ProTip:** When writing tests for `check_sorting_invariant()`, you can use
an iterator to break the invariant. For example:

```cpp
BinarySearchTree&lt;int&gt; b;
b.insert(1);
b.insert(0);
// change first datum to 2, resulting in the first broken tree above
*b.begin() = 2;
ASSERT_FALSE(b.check_sorting_invariant());
```

### Data Representation

The data representation for `BinarySearchTree` is a tree-like structure of
nodes similar to that described in lecture. Each `Node` contains an
element and pointers to left and right subtrees. The structure is
self-similar. A null pointer indicates an empty tree. **You must use this
data representation. Do not add member variables to `BinarySearchTree` or
`Node`.**

### Public Member Functions and Iterator Interface

The public member functions and iterator interface for
`BinarySearchTree` are already implemented in the starter code. DO NOT
modify the code for any of these functions. They delegate the work to
private, static implementation functions, which you will write.

### Implementation Functions

The core of the implementation for `BinarySearchTree` is a collection of
private, static member functions that operate on tree-like structures of
nodes. **You are responsible for writing the implementation of several of
these functions.**

To disambiguate these implementation functions from the public interface
functions, we have used names ending with `_impl`. (This is not
strictly necessary, because the compiler can differentiate them based on
the `Node*` parameter.)

There are a few keys to thinking about the implementation of these
functions:

  - **The functions have no idea that such a thing as the `BinarySearchTree`
    class exists**, and they shouldn&apos;t. A &quot;tree&quot; is not a class, but
    simply a tree-shaped structure of `Node`s. The parameter node points
    to the root of these nodes.
  - A recursive implementation depends on the idea of **similar subproblems**,
    so a &quot;subtree&quot; is just as much a tree as the &quot;whole tree&quot;. That means you
    shouldn&apos;t need to think about &quot;where you came from&quot; in your implementation.
  - Every function should have a **base case**! Start by writing this part.
  - You only need to think about one &quot;level&quot; of recursion at a time.
    Avoid thinking about the contents of subtrees and **take the recursive
    leap of faith**.

We&apos;ve structured the starter code so that the first bullet point above
is actually enforced by the language. Because they are `static` member
functions, they do not have access to a receiver object (i.e. there&apos;s no
`this` pointer). That means it&apos;s actually impossible for these functions
to try to do something bad with the `BinarySearchTree` object (e.g. trying
to access the `root` member variable).

Instead, the implementation functions are called from the regular member
functions to perform specific operations on the underlying nodes and
tree structure, and are passed only a pointer to the root `Node` of the
tree/subtree they should work with.

The `empty_impl` function must run in constant time. It must must be able
to determine and return its result immediately, without using either
iteration or recursion. The rest of the implementation functions must be
recursive. There are additional requirements on the kind of recursion
that must be used for some functions. See comments in the starter code
for details. **Iteration (i.e. using loops) is not allowed in any of the
`_impl` functions**.

#### Using the Comparator

The `_impl` functions that need to compare data take in a comparator
parameter called `less`. Make sure to use `less` rather than the `&lt;` operator
to compare elements\!

#### The `insert_impl` Function

The key to properly maintaining the sorting invariant lies in the
implementation of the `insert_impl` function - this is essentially where
the tree is built, and this function will make or break the whole ADT.
Your `insert_impl` function should follow this procedure:

1.  Handle an originally empty tree as a special case.
2.  Insert the element into the appropriate place in the tree, keeping
    in mind the sorting invariant. You&apos;ll need to compare elements for
    this, and to do so make sure to use the `less` comparator passed in as
    a parameter.
3.  Use the recursive leap of faith and call `insert_impl` itself on the
    left or right subtree. Hint: You **do** need to use the return value of
    the recursive call. (Why?)

&lt;div class=&quot;primer-spec-callout warning&quot; markdown=&quot;1&quot;&gt;
**Important:** When recursively inserting an item into the left or right
subtree, be sure to replace the old left or right pointer of the current
node with the result from the recursive call. This is essential, because
in some cases the old tree structure (i.e. the nodes pointed to by the
old left or right pointer) is not reused. Specifically, if the subtree
is empty, the only way to get the current node to &quot;know&quot; about the newly
allocated node is to use the pointer returned from the recursive call.
&lt;/div&gt;

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Technicality:** In some cases, the tree structure may become unbalanced
(i.e. too many nodes on one side of the tree, causing it to be much deeper
than necessary) and prevent efficient operation for large trees. You
don&apos;t have to worry about this.
&lt;/div&gt;

### Testing
&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** When writing tests for functions that return a `size_t` (which is an unsigned integer type), compare against an unsigned literal. For example:

```cpp
BinarySearchTree&lt;int&gt; b;
ASSERT_EQUAL(b.height(), 0u);
```
&lt;/div&gt;

## Map

Write a map abstract data type (ADT). Map is an *associative container*, and works just like `std::map`.

Write implementations at the end of `Map.hpp` for the functions declared at the beginning of `Map.hpp`. The most important functions are `find`, `insert`, and the `[]` operator.  

Your implementations should not require much code. Reuse the functionality provided by `BinarySearchTree`.

Run the public Map tests.
```console
$ make Map_compile_check.exe
$ make Map_public_tests.exe
$ ./Map_public_tests.exe
```

Write tests for `Map` in `Map_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/). While you should write your own tests for `Map` to ensure that your implementation is correct, you do not have to submit your tests to the autograder.
```console
$ make Map_tests.exe
$ ./Map_tests.exe
```

Submit `Map.hpp` to the [autograder](https://autograder.io).  Don&apos;t forget to include the code you finished earlier, `BinarySearchTree.hpp` and `BinarySearchTree_tests.cpp`.

### Setup
Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):
-  `Map.hpp.starter` -&gt; `Map.hpp`
-  `Map_tests.cpp.starter` -&gt; `Map_tests.cpp`

Edit `Map.hpp`, adding a function stub for every function prototype in `Map`.  Here are a few examples to get you started.  We&apos;re using `K`, `V`, and `C` as shorthands for `Key_type`, `Value_type`, and `Key_compare`.
```c++
template &lt;typename K, typename V, typename C&gt;
bool Map&lt;K, V, C&gt;::empty() const {
  assert(false);
}

template &lt;typename K, typename V, typename C&gt;
typename Map&lt;K, V, C&gt;::Iterator Map&lt;K, V, C&gt;::find(const K&amp; k) const {
  assert(false);
}

template &lt;typename K, typename V, typename C&gt;
V&amp; Map&lt;K, V, C&gt;::operator[](const K&amp; k) {
  assert(false);
}

template &lt;typename K, typename V, typename C&gt;
std::pair&lt;typename Map&lt;K, V, C&gt;::Iterator, bool&gt; Map&lt;K, V, C&gt;::insert(const Pair_type &amp;val) {
  assert(false);
}
```

Now you should be able to compile and run the Map unit tests.  The public tests will fail until you implement the functions.
```console
$ make Map_compile_check.exe
$ make Map_public_tests.exe
$ ./Map_public_tests.exe
```

Configure your IDE to debug either the public tests or your own tests.  Writing your own tests for Map is optional.

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;/th&gt;
  &lt;th&gt;
  Public tests
  &lt;/th&gt;
  &lt;th&gt;
  Your own tests
  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Map_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Map_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Map_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Map_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Xcode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Map_public_tests.cpp`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Map_tests.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Map_public_tests.cpp`
  - Exclude any other tests
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Map_tests.cpp`
  - Exclude any other tests
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

### Map Examples
A map is an *associative container*.  It stores two types, key and value.  Our map works just like `std::map`.
```c++
Map&lt;string, double&gt; words;
std::map&lt;string, double&gt; words;
```
{: data-variant=&quot;no-line-numbers&quot; }

One way to use a map is a lot like an array.
```c++
words[&quot;hello&quot;] = 1;
```
{: data-variant=&quot;no-line-numbers&quot; }

Maps store a `std::pair` type, which &quot;glues&quot; one key to one value. The computer science term is Tuple, a fixed-size heterogeneous container.
```c++
pair&lt;string, double&gt; tuple;
tuple.first = &quot;world&quot;;
tuple.second = 2;
words.insert(tuple);
```
{: data-variant=&quot;no-line-numbers&quot; }

Here&apos;s a more compact way to insert a pair.
```c++
words.insert({&quot;pi&quot;, 3.14159});
```
{: data-variant=&quot;no-line-numbers&quot; }

The range-for loop makes it easier to iterate over a map.
```c++
for (const auto &amp;kv : words) {
  const auto &amp;word = kv.first; //key
  auto number = kv.second; //value
  cout &lt;&lt; word &lt;&lt; &quot; &quot; &lt;&lt; number &lt;&lt; endl;
}
```
{: data-variant=&quot;no-line-numbers&quot; }

You can check if a key is in the map.  The `find()` function returns an iterator.
```c++
auto found_it = words.find(&quot;pi&quot;);
if (found_it != words.end()) {
  const auto &amp;word = (*found_it).first; //key
  auto number = (*found_it).second; //value
  cout &lt;&lt; &quot;found &quot; &lt;&lt; word &lt;&lt; &quot; &quot; &lt;&lt; number &lt;&lt; endl;
}
```
{: data-variant=&quot;no-line-numbers&quot; }

When using the `[]` notation, an element not found is automatically created.  If the value type of the map is numeric, it will always be `0` by default.
```c++
cout &lt;&lt; &quot;bleh: &quot; &lt;&lt; words[&quot;bleh&quot;] &lt;&lt; endl;
```
{: data-variant=&quot;no-line-numbers&quot; }

### Building on the BST

The operation of a map is quite similar to that of a BST. The additional
consideration for a map is that we want to store key-value pairs instead
of single elements, but also have any comparisons (e.g. for searching)
only depend on the key and be able to freely change the stored values
without messing up the BST sorting invariant. We can employ the has-a
pattern using a `BinarySearchTree` as the data representation for Map:

- BST template parameter: `T`

  Instantiate with: `Pair_type`

  We&apos;ve provided a using declaration in the starter code for `Pair_type`:

  `using Pair_type = std::pair&lt;Key_type, Value_type&gt;;`

  `std::pair` is basically like a struct that stores two objects together.
   `Key_type` and `Value_type` are whatever template parameters were used to
   instantiate `Map`.

- BST template parameter: `Compare`

  Instantiate with: `PairComp`

  You&apos;ll need to define your own comparator by declaring a functor
  type called `PairComp` (or whatever you want to call it) in your
  `Map` class. The overloaded `()` operator should accept two objects of
  `Pair_type` and return whether the key of the LHS is less than the
  key of the RHS (according to `Key_compare`).

Finally, we can even reuse the iterators from the BST class, since the
interface we want (based on `std::map`) calls for iterators to yield a
key-value pair when dereferenced. Since the element type `T` of the BST is
our `Pair_type`, BST iterators will yield pairs and will work just fine.
We&apos;ve provided this `using` declaration with the starter code to make
`Map::Iterator` simply an alias for iterators from the corresponding BST:

```c++
using Iterator = typename BinarySearchTree&lt;Pair_type, PairComp&gt;::Iterator;
```
{: data-variant=&quot;no-line-numbers&quot; }

## Submission and Grading

Submit these files to the [autograder](https://autograder.io).
  - `BinarySearchTree.hpp`
  - `BinarySearchTree_tests.cpp`
  - `Map.hpp`

You do not have to submit `Map_tests.cpp` to the autograder.

This project will be autograded for correctness, comprehensiveness of
your test cases, and programming style. See the [style checking
tutorial](https://eecs280staff.github.io/p1-stats/setup_style.html)
for the criteria and how to check your style automatically on CAEN.

### Testing

Run all the unit tests.  This includes the public tests we provided and the unit tests that you wrote.

```console
$ make test
```

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Run commands in parallel with `make -j`.
```console
$ make -j4 test
```
{: data-variant=&quot;no-line-numbers&quot; }
&lt;/div&gt;

### Unit Test Grading

We will autograde your `BinarySearchTree` unit tests.

Your unit tests must use the [unit test framework](https://eecs280staff.github.io/unit_test_framework/).

A test suite must complete less than 5 seconds and contain 50 or fewer `TEST()` items.  One test suite is one `_tests.cpp` file.

To grade your unit tests, we use a set of intentionally buggy instructor solutions.  You get points for catching the bugs.

1.  We compile and run your unit tests with a **correct solution**.
    - Tests that pass are **valid**.
    - Tests that fail are **invalid**, they falsely report a bug.
3.  We compile and run all of your **valid** tests against each **buggy solution**.
    - If any of your tests fail, you caught the bug.
    - You earn points for each bug that you catch.

### Requirements and Restrictions

| DO | DO NOT |
| -- | ------ |
| Create any private helper functions you want. | Modify the `BinarySearchTree` or `Map` public interfaces |
| Use any part of the STL except for containers in your `BinarySearchTree` and `Map` implementations. | Use STL containers in your implementation of `BinarySearchTree` or `Map`. |
| Use recursion for the BST `_impl` functions. | Use iteration for the BST `_impl` functions. |
| Follow course style guidelines. | Use non-const static or global variables. |
| [Check for undefined behavior](https://eecs280staff.github.io/p1-stats/setup_asan.html#p1-stats) using address sanitizer and other tools | &quot;It runs fine on my machine!&quot; |


## Acknowledgments

Andrew DeOrio and James Juett wrote the original project and specification. Amir Kamil contributed to code structure, style, and implementation details. This project was developed for EECS 280, Fall 2016 at the University of Michigan. The classifier portion was split into a separate project in Fall 2024.
</data>
      <data key="v_name">chunk-88c3276aa3d516a88e6627f42cbd462f</data>
      <data key="v_id">n113</data>
    </node>
    <node id="n114">
      <data key="v_hash_id">chunk-836e0dd33c346d6ab2b7bc8da851257d</data>
      <data key="v_content">---
layout: spec
mermaid: true
---

EECS 280 Project 3: Euchre
==========================
{: .primer-spec-toc-ignore }

Winter 2025 release.

Checkpoint due 8:00pm EST Monday February 24, 2025.  See [Submission and Grading / Checkpoint](#checkpoint).

Full project due 8:00pm EST Wednesday March 12, 2025.

You may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)). If you work alone, you must work alone on both the checkpoint and the full project. If you work with a partner, you must work with the same partner on the checkpoint and the full project. You may not work alone on the checkpoint and then add a partner for the full project.

&lt;!--
## Change Log

--&gt;

## Introduction
Euchre (pronounced &quot;YOO-kur&quot;) is a card game popular in Michigan.

The learning goals of this project include Abstract Data Types in C++, Derived Classes, Inheritance, and Polymorphism.  You&apos;ll gain practice with C++-style Object Oriented Programming (OOP) with classes and virtual functions.

When you&apos;re done, you&apos;ll have a program that simulates a game of Euchre, supporting a AI player and a Human player.
```console
$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Simple Kunle Simple Liskov Simple
Hand 0
Ivan deals
Jack of Diamonds turned up
Judea passes
Kunle passes
Liskov passes
Human player Ivan&apos;s hand: [0] Nine of Diamonds
Human player Ivan&apos;s hand: [1] Ten of Diamonds
Human player Ivan&apos;s hand: [2] Jack of Hearts
Human player Ivan&apos;s hand: [3] Queen of Hearts
Human player Ivan&apos;s hand: [4] Ace of Clubs
Human player Ivan, please enter a suit, or &quot;pass&quot;:
Diamonds
Ivan orders up Diamonds
...
```
{: data-variant=&quot;legacy&quot; }


## Setup
Set up your visual debugger and version control, then submit to the autograder.

### Visual debugger
During setup, name your project `p3-euchre`. Use this starter files link: `https://eecs280staff.github.io/euchre/starter-files.tar.gz`

| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |

If you created a `main.cpp` while following the setup tutorial, rename it to `euchre.cpp`. Otherwise, create a new file `euchre.cpp`.  You should end up with a folder with starter files that looks like this.  You may have already renamed files like `Card.cpp.starter` to `Card.cpp`.
```console
$ ls
Card.cpp.starter        Pack_public_tests.cpp     euchre_test00.out.correct
Card.hpp                Pack_tests.cpp.starter    euchre_test01.out.correct
Card_public_tests.cpp   Player.hpp                euchre_test50.in
Card_tests.cpp.starter  Player_public_tests.cpp   euchre_test50.out.correct
Makefile                Player_tests.cpp.starter  pack.in
Pack.hpp                euchre.cpp                unit_test_framework.hpp
```
{: data-variant=&quot;no-line-numbers&quot; }

Here&apos;s a short description of each starter file.

| File(s) | Description |
| ------- | ----------- |
| `Card.hpp` | Abstraction representing a playing card. |
| `Card.cpp.starter` | Starter code for the `Card`. |
| `Card_tests.cpp` | Your `Card` unit tests. |
| `Card_public_tests.cpp` | Compile check test for `Card.cpp`. |
| `Pack.hpp` | Abstraction representing a pack cards. |
| `Pack_tests.cpp` | Add your `Pack` unit tests to this file. |
| `Pack_public_tests.cpp` | Compile check test for `Pack.cpp`. |
| `Player.hpp` | Abstraction representing a euchre player. |
| `Player_tests.cpp` | Your `Player` unit tests. |
| `Player_public_tests.cpp` | Compile check test for `Player.cpp`. |
| `pack.in` | Input file containing a Euchre deck. |
| `Makefile` | Helper commands for building. |
| `euchre_test00.out.correct` &lt;br&gt;`euchre_test01.out.correct` | Correct output for system tests with Simple player.  |
| `euchre_test50.in` &lt;br&gt;`euchre_test50.out.correct` | Input and correct output for system tests with Human player. |
| `unit_test_framework.hpp` | A simple unit-testing framework. |

### Version control
Set up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).

After you&apos;re done, you should have a local repository with a &quot;clean&quot; status and your local repository should be connected to a remote GitHub repository.
```console
$ git status
On branch main
Your branch is up-to-date with &apos;origin/main&apos;.

nothing to commit, working tree clean
$ git remote -v
origin	https://github.com/awdeorio/p3-euchre.git (fetch)
origin	https://githubcom/awdeorio/p3-euchre.git (push)
```

You should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).
```console
$ head .gitignore
# This is a sample .gitignore file that&apos;s useful for C++ projects.
...
```

### Group registration
Register your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.

## EECS 280 Euchre Rules

There are many variants of Euchre. Our particular version is based on
a variety commonly played in Michigan with a few changes to make it
feasible as a coding project.

Our step-by-step explanation of a game of &quot;EECS 280 Euchre&quot; can be found in a [YouTube video](https://www.youtube.com/watch?v=M0jGJ0NRcrc) and a [PDF](https://drive.google.com/file/d/14MSt1WdtnRbfgpPiMp9YuKn2wQ4Z83Ir/view?usp=sharing).

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Skim this section the first time through.  Refer back to it while you&apos;re coding.
&lt;/div&gt;

### Players
{:.primer-spec-toc-ignore}

There are four players numbered 0-3. If the players sat around the
table, it would look like this:

![](images/image2.png){: .invert-colors-in-dark-mode }

There are two teams: players 0 and 2 are *partners*, as are 1 and 3.
Each player has left and right *neighbors*. For example, 1 is to the
left of 0, and 3 is to the right of 0. That means 1 is 0&apos;s left
*neighbor*, and 3 is 0&apos;s right *neighbor*.

### The Cards
{:.primer-spec-toc-ignore}

Euchre uses a deck of 24 *playing cards*, each of which has two
properties: a *rank* and a *suit*. The ranks are 9, 10, *Jack*,
*Queen*, *King*, and *Ace*, and the suits are *Spades*, *Hearts*,
*Clubs*, and *Diamonds*. Each card is unique &amp;mdash; there are no duplicates.
Throughout this document, we sometimes refer to ranks or suits using
only the first letter of their name. Farther below, we describe how to
determine the [ordering of the cards](#value-of-cards).

### Playing the Game

At a high level, a game of Euchre involves several rounds, which are
called *hands*. Each hand consists of the following phases.

Each hand:

1.  [Setup table](#setup-table)
    1.  [Shuffle](#shuffle)
    2.  [Deal](#deal)
2.  [Making Trump](#making-trump)
    1.  [Round One](#round-one)
    2.  [Round Two](#round-two)
3.  [Trick Taking](#trick-taking)
4.  [Scoring](#scoring)

We describe each in more detail below.

### Setup table

#### Shuffle
{:.primer-spec-toc-ignore}

The dealer shuffles the deck at the beginning of each hand. The
algorithm you will implement for shuffling is a variant of a riffle
shuffle called an &quot;in shuffle&quot;
([https://en.wikipedia.org/wiki/In\_shuffle](https://en.wikipedia.org/wiki/In_shuffle)).
Cut the deck exactly in half and then interleave the two halves,
starting with the second half. Thus, the card originally at position
12 goes to position 0, the one originally at position 0 goes to
position 1, the one originally at position 13 goes to position 2, and
so on. Do this in-shuffle process 7 times.

You will also implement an option to run the game with shuffling
disabled - when this option is chosen, just reset the pack any time
shuffling would be called for. This may make for easier testing and
debugging.

#### Deal
{:.primer-spec-toc-ignore}

In each hand, one player is designated as the *dealer* (if humans were
playing the game, the one who passes out the cards). In our game,
player 0 deals during the first hand. Each subsequent hand, the role
of dealer moves one player to the left.

Each player receives five cards, dealt in alternating batches of 3 and 2.
That is, deal 3-2-3-2 cards then 2-3-2-3 cards, for a total of 5
cards each. The player to the left of the dealer receives the first
batch, and dealing continues to the left until 8 batches have been
dealt.

Four cards remain in the deck after the deal. The next card in the
pack is called the upcard (it is turned face up, while the other cards
are all face down). It plays a special role in the next phase. The
three remaining cards are not used for the current hand.

### Making Trump

During this phase, the trump suit is determined by whichever player
chooses to *order up*.

#### Round One
{:.primer-spec-toc-ignore}

The suit of the *upcard* is used to propose a *trump* suit whose cards
become more valuable during the upcoming hand. Players are given the
opportunity to *order up* (i.e. select the suit of the upcard to be
the trump suit) or *pass*, starting with the player to the dealer&apos;s
left (also known as the *eldest hand*) and progressing once around the
circle to the left. If any player orders up, the upcard&apos;s suit becomes
trump and the dealer is given the option to replace one of their cards
with the upcard.

#### Round Two
{:.primer-spec-toc-ignore}

If all players *pass* during the first round, there is a second round
of *making*, again beginning with the eldest hand. The upcard&apos;s suit
is rejected and cannot be ordered up. Instead, the players may *order
up* any suit other than the upcard&apos;s suit. The dealer does not have
the opportunity to pick up the upcard during round two.

If *making* reaches the dealer during the second round, a variant
called *screw the dealer* is invoked: the dealer must order up a suit
other than the rejected suit.

(Note for pro Euchre players: for simplicity, we have omitted &quot;going
alone&quot; in this version.)

### Trick Taking

Once the trump has been determined, five *tricks* are played. For each
trick, players take turns laying down cards, and whoever played the
highest card *takes* the trick.

During each trick, the player who plays first is called the *leader*.
For the first trick, the eldest hand leads.

At the beginning of each trick, the leader *leads* a card, which
affects which cards other players are allowed to play, as well as the
value of each card played (see below). Each other player must *follow
suit* (play a card with the same suit as the led card) if they are
able, and otherwise may play any card (it is removed from their hand).
Play moves to the left around the table, with each player playing one
card.

A trick is won by the player who played the highest valued card (see
below to determine comparative values). The winner of the trick
*leads* the next one.

### Scoring

The team that takes the majority of tricks receives points for that hand.
* If the team that ordered up the trump suit takes 3 or 4 tricks, they get 1 point.
* If the team that ordered up the trump suit takes all 5 tricks, they get 2 points. This is called a *march*.
* If the team that did not order up takes 3, 4, or 5 tricks, they receive 2 points. This is called *euchred*.

Traditionally, the first side to reach 10 points wins the game. In
this project, the number of points needed to win is specified when the
program is run.

### Value of cards

In order to determine which of two cards is better, you must pay
attention to the context in which they are being compared. There are
three separate contexts, which depend on whether or not a trump or led
suit is present.

In the simplest case, cards are ordered by rank (A \&gt; K \&gt; Q \&gt; J \&gt;
10 \&gt; 9), with ties broken by suit (D \&gt; C \&gt; H \&gt; S).

If a *trump suit* is present, all trump cards are more valuable than
non-trump cards. That means a 9 of the trump suit will beat an Ace of
a non-trump suit. Additionally, two special cards called *bowers* take
on different values than normal.

  - *Right Bower*: The Jack of the trump suit. This is the most
    valuable card in the game.
  - *Left Bower*: The Jack of the &quot;same color&quot; suit as trump is
    **considered to be a trump** (regardless of the suit printed on
    the card) and is the second most valuable card.

The suit of the left bower is called *next*, while the two suits of the opposite color are called *cross* suits.

If a *led suit* is present as well as a trump suit, the ordering is
the same except that all cards of the led suit are considered more
valuable than all non-trump-suit, non-led-suit cards. Note that it is
possible for the trump suit and led suit to be the same.

&lt;div class=&quot;primer-spec-callout warning&quot; markdown=&quot;1&quot;&gt;
**Pitfall:** The left bower is always considered the trump suit.  For example, if Diamonds is trump, the Jack of Hearts is also considered a Diamond, not a Heart.
&lt;/div&gt;

![](images/image1.png)

The above shows card orderings in the possible contexts. Cards in
higher rows are greater than those in lower rows. Within rows, cards
farther to the left are greater. Note the right bower (blue outline)
and left bower (red outline).

### Euchre Glossary

**Trump:** A suit whose cards are elevated above their normal rank
during play.

**Right Bower:** The Jack card of the *Trump* suit, which is
considered the highest-valued card in Euchre.

**Left Bower:** The Jack from the other suit of the same color as the
*Trump* suit, considered the second highest-valued card in Euchre. The
*Left Bower* is also considered a *Trump* card.

**Face or Ace:** The Jack, Queen, and King cards are generally pictured with people on them and are called &quot;face&quot; cards. These and the ace cards are more powerful than the 9 or 10 and factor into the simple player&apos;s strategy.

**Next Suit:** The suit of the same color as trump.

**Cross Suits:** The two suits of the opposite color as trump.

**Making:** The process in which a trump card is chosen, consists of
two rounds.

**Eldest:** Player to the left of the dealer.

**Upcard:** The up-facing card in front of the dealer that proposes
the trump suit.

**Order Up:** Accepts the *Upcard* suit.

**Pass:** Player rejects the suit and passes on the decision to the
next player.

**Screw the Dealer:** When making* reaches the dealer on round two,
*the dealer must *order up* a suit other than the rejected one.

**Lead:** The first card played by the eldest* hand, regardless of who
*is the maker.

**Leader:** Person playing the lead* card in a trick, allowed to lead*
*any card.

**March:** When the side that made trump* wins all 5 tricks.

**Euchred:** When the side that didn&apos;t make trump* wins 3, 4, or 5
*tricks.


## Card

Write an abstract data type (ADT) for a playing card.  Refer back to the [Value of cards section](#value-of-cards) while you&apos;re working on the card ADT.

Before getting started, take a look at the [Operator Overloading Tutorial](operator_overloading.html).  That will help you understand functions like:
```c++
bool operator&lt;(const Card &amp;lhs, const Card &amp;rhs);
```

Next, see the short [Enumerated Type Tutorial](enum.html).  It explains code like this from `Card.hpp`.
```c++
enum Suit {
  SPADES   = 0,
  HEARTS   = 1,
  CLUBS    = 2,
  DIAMONDS = 3,
};
```

Write implementations in `Card.cpp` for the functions declared in
`Card.hpp`.

Run the public Card tests.
```console
$ make Card_public_tests.exe
$ ./Card_public_tests.exe
```

Write tests for `Card` in `Card_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You&apos;ll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.
```console
$ make Card_tests.exe
$ ./Card_tests.exe
```

Submit `Card.cpp` and `Card_tests.cpp` to the [autograder](https://autograder.io).

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Compare the underlying numeric representation of an `enum`.
```c++
Rank r = JACK;
r == JACK; // true

Suit s1 = SPADES;
Suit s2 = DIAMONDS;
s1 &lt; s2;  // true
```
&lt;/div&gt;

### Setup
Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):
-  `Card.cpp.starter` -&gt; `Card.cpp`
-  `Card_tests.cpp.starter` -&gt; `Card_tests.cpp`

Edit `Card.cpp`, adding a function stub for each of the Card member functions in `Card.hpp`.
```c++
Card::Card() {
  assert(false);
}
```
{: data-title=&quot;Card.cpp&quot; }

Edit `Card.cpp`, adding  function stubs for each of the non-member non-operator functions in `Card.hpp`.  Here are a few examples.
```c++
Suit Suit_next(Suit suit) {
  assert(false);
}

bool Card_less(const Card &amp;a, const Card &amp;b, Suit trump) {
  assert(false);
}
```
{: data-title=&quot;Card.cpp&quot; }

Edit `Card.cpp`, adding  function stubs for each of the overloaded operators in `Card.hpp`.  Here are a few examples.
```c++
std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, const Card &amp;card) {
  assert(false);
}

bool operator&lt;(const Card &amp;lhs, const Card &amp;rhs) {
  assert(false);
}

```
{: data-title=&quot;Card.cpp&quot; }

The Card tests should compile and run.  Expect them to fail at this point because the `Card.cpp` starter code contains function stubs.
```console
$ make Card_public_tests.exe
$ ./Card_public_tests.exe
$ make Card_tests.exe
$ ./Card_tests.exe
```

Configure your IDE to debug either the public tests or your own tests.

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;/th&gt;
  &lt;th&gt;
  Public tests
  &lt;/th&gt;
  &lt;th&gt;
  Your own tests
  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Card_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Card_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Card_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Card_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Xcode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Card_public_tests.cpp`, `Card.cpp`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Card_tests.cpp`, `Card.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Card_public_tests.cpp`
  - Exclude `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Card_tests.cpp`
  - Exclude `Card_public_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

### Testing
This section contains a few tips for writing your own tests in `Card_tests.cpp`.

Here&apos;s how to create a Card and check its rank and suit.
```c++
Card ace_hearts(ACE, HEARTS);
ASSERT_EQUAL(ace_hearts.get_rank(), ACE);
ASSERT_EQUAL(ace_hearts.get_suit(), HEARTS);
```

In this example, the overloaded less-than operator runs: `bool operator&lt;(const Card &amp;lhs, const Card &amp;rhs);`.  Notice that the suits are ordered to break ties (see the [Value of Cards](#value-of-cards) section).
```c++
Card ace_hearts(ACE, HEARTS);
Card ace_diamonds(ACE, DIAMONDS);
ASSERT_TRUE(ace_hearts &lt; ace_diamonds);
```

## Pack

Write an abstract data type (ADT) for a pack of playing cards.

Write implementations in `Pack.cpp` for the functions declared in
`Pack.hpp`.

Run the public Pack tests.
```console
$ make Pack_public_tests.exe
$ ./Pack_public_tests.exe
```

Write tests for `Pack` in `Pack_tests.cpp` using the unit test framework. While you should write your own tests for `Pack` to ensure that your implementation is correct, you do not have to submit your tests to the autograder.
```console
$ make Pack_tests.exe
$ ./Pack_tests.exe
```

Submit `Pack.cpp` to the [autograder](https://autograder.io).  Don&apos;t forget to include the code you finished earlier, `Card.cpp` and `Card_tests.cpp`.

### Default constructor
{: .primer-spec-toc-ignore }

The default `Pack` constructor initializes a full pack with cards in order from lowest to highest.
```c++
Pack();
```

You can take advantage of an `enum`&apos;s underlying integer representation to loop over all its values.
```c++
for (int s = SPADES; s &lt;= DIAMONDS; ++s) {
  Suit suit = static_cast&lt;Suit&gt;(s);
}
```

### Stream input constructor
{: .primer-spec-toc-ignore }

A second `Pack` constructor reads a pack from stream input. [Later](#command-line-arguments), your `main` function will open an input file and then call this constructor on the input stream.
### Setup
Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):
-  `Pack_tests.cpp.starter` -&gt; `Pack_tests.cpp`

Create a new file `Pack.cpp`.  Add a function stub for every function prototype in `Pack.hpp`.  Remember to `#include &quot;Pack.hpp&quot;`.

For example:
```c++
#include &quot;Pack.hpp&quot;
void Pack::reset() {
  assert(false);
  assert(next); // DELETEME: avoid error &quot;private field is not used&quot;
}
```
{: data-title=&quot;Pack.cpp&quot; }

The Pack tests should compile and run.  Expect them to fail at this point because the `Pack.cpp` contains function stubs.
```console
$ make Pack_public_tests.exe
$ ./Pack_public_tests.exe
$ make Pack_tests.exe
$ ./Pack_tests.exe
```

Configure your IDE to debug either the public tests or your own tests.

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;/th&gt;
  &lt;th&gt;
  Public tests
  &lt;/th&gt;
  &lt;th&gt;
  Your own tests
  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Pack_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Pack_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Pack_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Pack_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Xcode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Pack_public_tests.cpp`, `Pack.cpp`, `Card.cpp`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Pack_tests.cpp`, `Pack.cpp`, `Card.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Pack_public_tests.cpp`
  - Exclude `Pack_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Pack_tests.cpp`
  - Exclude `Pack_public_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

### Reading the Pack

One of the `Pack` constructors reads a pack from stream input. [Later](#interface), your `main` function will open an input file and then call this constructor on the input stream.
```c++
Pack(std::istream&amp; pack_input);
```
{: data-title=&quot;Pack.hpp&quot; }

The `pack.in` file provided with the project contains an example of the input format, with cards listed in &quot;new pack&quot; order:

```
Nine of Spades
Ten of Spades
Jack of Spades
...
Queen of Diamonds
King of Diamonds
Ace of Diamonds
```
{: data-title=&quot;pack.in&quot; data-variant=&quot;no-line-numbers&quot; }

Your implementation may assume any pack input is formatted correctly, with exactly 24
unique and correctly formatted cards.

## Player

We&apos;ll implement two players: a simple AI player and a human-controlled player that reads instructions from standard input (`cin`).  We have provided an abstract base class in `Player.hpp`.

### Setup
Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):
-  `Player_tests.cpp.starter` -&gt; `Player_tests.cpp`

Create a new file `Player.cpp`.  Add function stubs for the two &quot;vanilla&quot; functions in `Player.hpp`. Remember to `#include &quot;Player.hpp&quot;`. Later, you&apos;ll add new classes and member functions using derived classes, which you can ignore for now.
```c++
#include &quot;Player.hpp&quot;
Player * Player_factory(const std::string &amp;name, const std::string &amp;strategy) {
  assert(false);
}

std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, const Player &amp;p) {
  assert(false);
}
```
{: data-title=&quot;Player.cpp&quot; }

The Player tests should compile and run.  Expect them to fail at this point because the `Player.cpp` contains function stubs.
```console
$ make Player_public_tests.exe
$ ./Player_public_tests.exe
$ make Player_tests.exe
$ ./Player_tests.exe
```

Configure your IDE to debug either the public tests or your own tests.

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;/th&gt;
  &lt;th&gt;
  Public tests
  &lt;/th&gt;
  &lt;th&gt;
  Your own tests
  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Player_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Player_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Player_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/Player_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Xcode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Player_public_tests.cpp`, `Player.cpp`, `Pack.cpp`, `Card.cpp`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `Player_tests.cpp`, `Player.cpp`, `Pack.cpp`, `Card.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Player_public_tests.cpp`
  - Exclude `Player_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `Player_tests.cpp`
  - Exclude `Player_public_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

### Player factory

Since the specific types of Players are hidden inside `Player.cpp`, we
need to write a *factory function* that returns a pointer to a
`Player` with the correct dynamic type. We also need the pointed-to
objects to stick around after the factory function finishes, so we&apos;ll
create the players using *dynamically allocated memory*. The prototype
for `Player_factory` can be found in `Player.hpp`, and the
implementation will go in `Player.cpp`.

```c++
Player * Player_factory(const std::string &amp;name, 
                        const std::string &amp;strategy) {
  // We need to check the value of strategy and return 
  // the corresponding player type.
  if (strategy == &quot;Simple&quot;) {
    // The &quot;new&quot; keyword dynamically allocates an object.
    return new SimplePlayer(name);
  }
  // Repeat for each other type of Player
  ...
  // Invalid strategy if we get here
  assert(false);
  return nullptr;
}
```
{: data-title=&quot;Player.cpp&quot; }

### Simple Player

Implement the Simple Player in `Player.cpp` by creating a class that derives from our `Player` abstract base class.  Override each Player function in `Player.cpp` for the functions declared in `Player.hpp`. 

Much of the strategy for our Simple Player can be implemented using
the comparison functions provided by the Card interface.

The Simple Player should not print any output.

Run the public Simple Player tests.
```console
$ make Player_public_tests.exe
$ ./Player_public_tests.exe
```

Write tests for the Simple Player in `Player_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You&apos;ll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.
```console
$ make Player_tests.exe
$ ./Player_tests.exe
```

Submit `Player.cpp` and `Player_tests.cpp` to the [autograder](https://autograder.io).  Don&apos;t forget to include the code you finished earlier, `Card.cpp`, `Card_tests.cpp`, and `Pack.cpp`.

#### Making
{:.primer-spec-toc-ignore}

In making trump, a Simple Player considers the upcard, which player
dealt, and whether it is the first or second round of making trump. A
more comprehensive strategy would consider the other players&apos;
responses, but we will keep it simple.

During round one, a Simple Player considers ordering up the suit
of the upcard, which would make that suit trump. They will order up if
that would mean they have two or more cards that are either face or ace
cards of the trump suit (the right and left bowers, and Q, K, A of
the trump suit, which is the suit proposed by the upcard). (A Simple
Player does not consider whether they are the dealer and could gain an
additional trump by picking up the upcard.)

During round two, a Simple Player considers ordering up the suit with
the same color as the upcard, which would make that suit trump. They
will order up if that would mean they have one or more cards that are either
face or ace cards of the trump suit in their hand (the right and left bowers, and Q, K, A of the order-up
suit). For example, if the upcard is a Heart and the player has the
King of Diamonds in their hand, they will order up Diamonds. The
Simple Player will not order up any other suit. If making reaches the
dealer during the second round, we invoke *screw the dealer*, where
the dealer is forced to order up. In the case of screw the dealer, the
dealer will always order up the suit with the same color as the
upcard.

#### Adding the Upcard and Discarding a Card
{:.primer-spec-toc-ignore}

If the trump suit is ordered up during round one, the dealer picks up
the upcard. The dealer then discards the lowest card in their hand,
even if this is the upcard, for a final total of five cards. (Note that
at this point, the trump suit is the suit of the upcard.)

#### Leading Tricks
{:.primer-spec-toc-ignore}

When a Simple Player leads a trick, they play the highest non-trump
card in their hand. If they have only trump cards, they play the
highest trump card in their hand.

#### Playing Tricks
{:.primer-spec-toc-ignore}

When playing a card, Simple Players use a simple strategy that
considers only the suit that was led. A more complex strategy would
also consider the cards on the table.

If a Simple Player can follow suit, they play the highest card that
follows suit. Otherwise, they play the lowest card in their hand.

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Here&apos;s a nice way to remove a Card from a vector using [`vector::erase`](https://cplusplus.com/reference/vector/vector/erase/).
```c++
vector&lt;Card&gt; hand;  // Assume hand is full of cards
hand.erase(hand.begin() + i);  // Remove card i
```
&lt;/div&gt;

### Human Player

The Human Player reads input from the human user. You may assume all
user input is correctly formatted and has correct values. You may also
assume the user will follow the rules of the game and not try to
cheat. See [Example With Human Players](#example-with-human-players) for
exact output for a game with a human player.

Implement the Human Player in `Player.cpp` by creating a class that derives from our `Player` abstract base class.  Override each Player function in `Player.cpp` for the functions declared in `Player.hpp`. 

The tests in `Player_tests.cpp` and `Player_public_tests.cpp` test only the Simple Player.  You&apos;ll have to wait until you have a working Euchre game driver to test the Human player.

Submit `Player.cpp` again to the [autograder](https://autograder.io).  Don&apos;t forget to include the code you finished earlier, `Card.cpp`, `Card_tests.cpp`, `Pack.cpp`, and `Player_tests.cpp`.

#### Making Trump
{:.primer-spec-toc-ignore}

When making trump reaches a Human Player, first print the Player&apos;s
hand. Then, prompt the user for their decision to pass or order up. The user will
then enter one of the following: &quot;Spades&quot;, &quot;Hearts&quot;, &quot;Clubs&quot;,
&quot;Diamonds&quot;, or &quot;pass&quot; to either order up the specified suit or pass.
This procedure is the same for both rounds of making trump.

Sample output code:
```c++
print_hand();
cout &lt;&lt; &quot;Human player &quot; &lt;&lt; name &lt;&lt; &quot;, please enter a suit, or \&quot;pass\&quot;:\n&quot;;
```

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Add a private member function that prints out the human player&apos;s hand.
```c++
void print_hand() const {
  for (size_t i=0; i &lt; hand.size(); ++i)
    cout &lt;&lt; &quot;Human player &quot; &lt;&lt; name &lt;&lt; &quot;&apos;s hand: &quot;
         &lt;&lt; &quot;[&quot; &lt;&lt; i &lt;&lt; &quot;] &quot; &lt;&lt; hand[i] &lt;&lt; &quot;\n&quot;;
}
```
&lt;/div&gt;

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Use the `string_to_suit()` function provided with the starter code.
```c++
string decision;
cin &gt;&gt; decision;

if (decision != &quot;pass&quot;) {
  Suit ordered_up = string_to_suit(decision);
  ...
}
else {
  ...
}
```
&lt;/div&gt;

#### Adding the Upcard and Discarding
{:.primer-spec-toc-ignore}

If a Human Player is the dealer and someone orders up during the first
round of making, the Human Player will pick up the upcard and discard
a card of their choice. Print the Player&apos;s hand and an option to
discard the upcard. Then, prompt the user to select a card to discard.
The user will then enter the number corresponding to the card they
want to discard (or -1 if they want to discard the upcard).

Sample output code:
```c++
print_hand();
cout &lt;&lt; &quot;Discard upcard: [-1]\n&quot;;
cout &lt;&lt; &quot;Human player &quot; &lt;&lt; name &lt;&lt; &quot;, please select a card to discard:\n&quot;;
```

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Make &quot;sorted card ordering&quot; a _representation invariant_ of your Human Player class and ensure that the hand is always kept in sorted order.
For consistency with autograder test cases, the cards in a human player&apos;s hand must always be printed in ascending order, as defined by the `&lt;` operator in `Card.hpp`.

Use the STL to sort a `vector&lt;Card&gt; hand`:
```c++
#include &lt;algorithm&gt;
// ...
std::sort(hand.begin(), hand.end());
```
{: data-variant=&quot;no-line-numbers&quot; }

**Pitfall:** Using `sort` on a member variable in a `const` member function leads to a confusing error, `no matching function for call to &apos;swap&apos;`.  Instead, call `sort` when adding a card to the `hand`.
```c++
void Human::print_hand() const {
  std::sort(hand.begin(), hand.end()); // Error!
  // ...
}
```
&lt;/div&gt;

#### Playing and Leading Tricks
{:.primer-spec-toc-ignore}

When it is the Human Player&apos;s turn to lead or play a trick, first
print the Player&apos;s hand. Then, prompt the user to select a card. The user
will then enter the number corresponding to the card they want to
play.

Sample output code:
```c++
print_hand();
cout &lt;&lt; &quot;Human player &quot; &lt;&lt; name &lt;&lt; &quot;, please select a card:\n&quot;;
```


## Euchre Game

Write the Euchre Game in `euchre.cpp` following the [EECS 280 Euchre Rules](#eecs-280-euchre-rules).

Run a Euchre game with four players.
```console
$ make euchre.exe
$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple
```

### Setup
Make sure you have created `euchre.cpp` ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#add-new-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#add-new-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#add-new-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#add-new-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#touch)).

Add &quot;hello world&quot; code if you haven&apos;t already.
```c++
#include &lt;iostream&gt;
using namespace std;

int main() {
  cout &lt;&lt; &quot;Hello World!\n&quot;;
}
```

The euchre program should compile and run.
```console
$ make euchre.exe
$ ./euchre.exe
Hello World!
```

Configure your IDE to debug the euchre program.

&lt;table&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/euchre.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/euchre.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Xcode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `euchre.cpp`, `Card.cpp`, `Pack.cpp`, `Player.cpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `euchre.cpp`
  - Exclude `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `main.cpp` (if present)
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

Configure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)).  We recommend starting with the euchre test 00: `pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple`

To compile and run a Euchre game with four players.
```console
$ make euchre.exe
$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple
```

### Interface

The Euchre game driver takes several command line arguments, for example:

```console
$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple
```
{: data-variant=&quot;no-line-numbers&quot; }

Here&apos;s a short description of each command line argument.

| `./euchre.exe` | Name of the executable |
| `pack.in` | Filename of the pack |
| `noshuffle` | Don&apos;t shuffle the deck, or use `shuffle` to turn on shuffling |
| `1` | Points to win the game |
| `Adi` | Name of player 0 |
| `Simple` | Type of player 0 |
| `Barbara` | Name of player 1 |
| `Simple` | Type of player 1 |
| `Chi-Chih` | Name of player 2 |
| `Simple` | Type of player 2 |
| `Dabbala` | Name of player 3 |
| `Simple` | Type of player 3 |

Check for each of these errors:
  - There are exactly 12 arguments, including the executable name.
  - Points to win the game is between 1 and 100, inclusive.
  - The shuffle argument is either `shuffle` or `noshuffle`.
  - The types of each of the players are either `Simple` or `Human`.

If there is an error print this message and no other output.  Exit returning a non-zero value from `main`.

```c++
cout &lt;&lt; &quot;Usage: euchre.exe PACK_FILENAME [shuffle|noshuffle] &quot;
     &lt;&lt; &quot;POINTS_TO_WIN NAME1 TYPE1 NAME2 TYPE2 NAME3 TYPE3 &quot;
     &lt;&lt; &quot;NAME4 TYPE4&quot; &lt;&lt; endl;
```

You must also verify the pack input file opens successfully. If it does not,
print this error message and exit returning a non-zero value from `main`.

```c++
// Assume pack_filename is a variable containing
// the specified pack filename from argv
cout &lt;&lt; &quot;Error opening &quot; &lt;&lt; pack_filename &lt;&lt; endl;
```
{: data-variant=&quot;no-line-numbers&quot; }

If the file opens successfully, you may assume it is formatted correctly.

### Design

The Euchre game driver coordinates all the [actions in the game](#playing-the-game).  *Take some time* to design this complex piece of code before beginning.

We recommend writing a `Game` ADT. It should have a constructor that takes in details like the players, points to win, etc. and a public `play()` function.  The `Game` and its helper functions do the hard work, and the `main()` function is simple.

```c++
class Game {
 public:
  // primer-spec-highlight-start
  Game(/* game details */);
  void play();
  // primer-spec-highlight-end
};

int main(int argc, char **argv) {
  // Read command line args and check for errors
  // primer-spec-highlight-start
  Game game(/* game details */);
  game.play();
  // primer-spec-highlight-end
}
```

Next, consider which member data you&apos;ll need.  Examples include player pointers, pack of cards, etc.
```c++
class Game {
 public:
  Game(/* ... */);
  void play();

 private:
  // primer-spec-highlight-start
  std::vector&lt;Player*&gt; players;
  Pack pack;
  // ...
  // primer-spec-highlight-end
};
```

Which helper functions would help simplify the `play()` function?  Add these as private member functions.  Functions that shuffle, deal, make trump, and play a hand are a good starting point. 
```c++
class Game {
 public:
  Game(/* ... */);
  void play();

 private:
  std::vector&lt;Player*&gt; players;
  Pack pack;
  // ...

  // primer-spec-highlight-start
  void shuffle();
  void deal(/* ... */);
  void make_trump(/* ... */);
  void play_hand(/* ... */);
  // ...
  // primer-spec-highlight-end
};
```

#### End of game
{: .primer-spec-toc-ignore }

At the end of a game, delete the `Player` objects created by the [`Player_factory`](#player-factory).

```c++
for (size_t i = 0; i &lt; players.size(); ++i) {
  delete players[i];
}
```

### Example With Simple Players

We&apos;ve provided full example output for a game with four simple players in `euchre_test00.out.correct`.  This section explains the output line by line.

As a reminder, all the output in this example is produced by the Euchre Game driver, not by the simple player code in `Player.cpp`.

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Debug differences in game output using `diff -y -B`, which shows differences side-by-side and ignores whitespace.  We&apos;ll use the `less` pager so we can scroll through the long terminal output.  Press `q` to quit.
```console
$ make euchre.exe
$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple &gt; euchre_test00.out
$ diff -y -B euchre_test00.out.correct euchre_test00.out | less  # q to quit
```
&lt;/div&gt;

Run the example.

```console
$ make euchre.exe
$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple
```

First, print the executable and all arguments on the first line. Print
a single space at the end, which makes it easier to print an array.

```
./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple 
```
{: data-variant=&quot;legacy&quot; }

At the beginning of each hand, announce the hand, starting at zero,
followed by the dealer and the upcard.

```
Hand 0
Adi deals
Jack of Diamonds turned up
```
{: data-variant=&quot;legacy&quot; }

Print the decision of each player during the making procedure. Print
an extra newline when making, adding, and discarding is complete.

```
Barbara passes
Chi-Chih passes
Dabbala passes
Adi passes
Barbara orders up Hearts
```
{: data-variant=&quot;legacy&quot; }

Each of the five tricks is announced, including the lead, cards played
and the player that took the trick. Print an extra newline at the end
of each trick.

```
Jack of Spades led by Barbara
King of Spades played by Chi-Chih
Ace of Spades played by Dabbala
Nine of Diamonds played by Adi
Dabbala takes the trick

```
{: data-variant=&quot;legacy&quot; }

At the end of the hand, print the winners of the hand. When printing
the names of a partnership, print the player with the lower index
first. For example, Adi was specified on the command line before
Chi-Chih, so he goes first.

```
Adi and Chi-Chih win the hand
```
{: data-variant=&quot;legacy&quot; }

If a march occurs, print `march!` followed by a newline. If euchre
occurs, print `euchred!` followed by a newline. If neither occurs,
print nothing.

```
euchred!
```
{: data-variant=&quot;legacy&quot; }

Print the score, followed by an extra newline.

```
Adi and Chi-Chih have 2 points
Barbara and Dabbala have 0 points
```
{: data-variant=&quot;legacy&quot; }

When the game is over, print the winners of the game.

```
Adi and Chi-Chih win!
```
{: data-variant=&quot;legacy&quot; }

The output for a much longer game with four simple players is in `euchre_test01.out.correct`. See the [Euchre Test 01 Explanation](euchre_test01.html) for an explanation of the output.

### Example With Human Players

We’ve provided full example output for a game with four human players in `euchre_test50.out.correct`. The input is in `euchre_test50.in`.  This section explains the output line by line.

Output that is specific to the Human Player should be printed by the Human Player code in (`Player.cpp`). All other output that is common to both Simple and Human Players should be printed by the Euchre Game driver.

Set up input redirection ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#input-redirection), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#input-redirection), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#input-redirection), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#input-redirection)) to read `euchre_test50.in`. 

Configure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)) for euchre test 50: `noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human`

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Similar to the simple player, you can debug differences in game output using `diff -y -B`.  Press `q` to quit.
```console
$ make euchre.exe
$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human &lt; euchre_test50.in &gt; euchre_test50.out
$ diff -y -B euchre_test50.out.correct euchre_test50.out | less  # q to quit
```
&lt;/div&gt;

Run the example, redirecting the input file `euchre_test50.in` to stdin.

```console
$ make euchre.exe
$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human &lt; euchre_test50.in
```

First, print the executable and all arguments on the first line. Print
a single space at the end, which makes it easier to print an array.

```
./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human 
```
{: data-variant=&quot;legacy&quot; }

At the beginning of each hand, announce the hand, starting at zero,
followed by the dealer and the upcard.

```
Hand 0
Ivan deals
Jack of Diamonds turned up
```
{: data-variant=&quot;legacy&quot; }

Print the hand of each player during the making procedure, followed by
a prompt for their making decision. End the prompt with a newline
immediately after the colon.

```
Human player Judea&apos;s hand: [0] Nine of Spades
Human player Judea&apos;s hand: [1] Ten of Spades
Human player Judea&apos;s hand: [2] Jack of Spades
Human player Judea&apos;s hand: [3] King of Hearts
Human player Judea&apos;s hand: [4] Ace of Hearts
Human player Judea, please enter a suit, or &quot;pass&quot;:
```
{: data-variant=&quot;legacy&quot; }

Print the decision of each player during the making procedure.

```
Judea passes
...
Judea orders up Hearts
```
{: data-variant=&quot;legacy&quot; }

Print the dealer&apos;s hand if a player orders up during the first round,
as well as an option to discard the upcard. Prompt the dealer to
select a card to discard, ending the prompt with a newline immediately
after the colon. Print an extra newline when making, adding, and
discarding is done.

```
Human player Ivan&apos;s hand: [0] Nine of Diamonds
...
Human player Ivan&apos;s hand: [4] Ace of Clubs
Discard upcard: [-1]
Human player Ivan, please select a card to discard:
```
{: data-variant=&quot;legacy&quot; }

For each trick, print the Human Player&apos;s hand and prompt them to
select a card.

```
Human player Judea&apos;s hand: [0] Nine of Spades
...
Human player Judea&apos;s hand: [4] Ace of Hearts
Human player Judea, please select a card:
```
{: data-variant=&quot;legacy&quot; }

Then print the card played or lead.

```
Nine of Spades led by Judea
```
{: data-variant=&quot;legacy&quot; }

At the end of each trick, print the player who took the trick as well
as an extra newline.

```
Liskov takes the trick
```
{: data-variant=&quot;legacy&quot; }

At the end of the hand, print the winners of the hand. When printing
the names of a partnership, print the player with the lower index
first. For example, Ivan was specified on the command line before
Kunle, so he goes first.

```
Ivan and Kunle win the hand
```
{: data-variant=&quot;legacy&quot; }

If a march occurs, print `march!` followed by a newline. If euchre
occurs, print `euchred!` followed by a newline. If neither occurs, print
nothing.

```
euchred!
```
{: data-variant=&quot;legacy&quot; }

Print the score, followed by an extra newline.

```
Ivan and Kunle have 2 points
Judea and Liskov have 0 points
```
{: data-variant=&quot;legacy&quot; }

When the game is over, print the winners of the game.

```
Ivan and Kunle win!
```
{: data-variant=&quot;legacy&quot; }


## Submission and Grading

Submit these files to the [autograder](https://autograder.io).
  - `Card.cpp`
  - `Card_tests.cpp`
  - `Pack.cpp`
  - `Player.cpp`
  - `Player_tests.cpp`
  - `euchre.cpp`

You do not have to submit `Pack_tests.cpp` to the autograder.

This project will be autograded for correctness, comprehensiveness of
your test cases, and programming style. See the [style checking
tutorial](https://eecs280staff.github.io/tutorials/setup_style.html)
for the criteria and how to check your style automatically on CAEN.

### Checkpoint

This project is graded on an early checkpoint as well as the full submission. The checkpoint submission is worth 0.5% of your overall course grade. The full submission is worth 9.5% of your overall course grade.

The checkpoint consists of everything except the [Euchre Game](#euchre-game) driver.

Submit these files to the [autograder](https://autograder.io).
  - `Card.cpp`
  - `Card_tests.cpp`
  - `Pack.cpp`
  - `Player.cpp`
  - `Player_tests.cpp`

There are no private tests and no style grading at the checkpoint.

Your checkpoint score does not change after the checkpoint deadline, even though we run the same public tests and [mutation tests](#unit-test-grading) at both the checkpoint and full submission.

After the checkpoint autograder closes, the full submission autograder will open.

### Testing

Run all the unit tests and system tests.  This includes the public tests we provided and the unit tests that you wrote.

```console
$ make test
```

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Run commands in parallel with `make -j`.
```console
$ make -j4 test
```
{: data-variant=&quot;no-line-numbers&quot; }
&lt;/div&gt;

### Unit Test Grading

We will autograde your `Card_tests.cpp` and `Player_tests.cpp` unit tests. Note that your player tests should only test the &quot;simple player&quot;, not the &quot;human player&quot;.

Your unit tests must use the [unit test framework](https://eecs280staff.github.io/unit_test_framework/).

A test suite must run in less than 5 seconds and contain 50 or fewer `TEST()` functions.  One test suite is one `_tests.cpp` file.

To grade your unit tests, we use a set of intentionally buggy instructor solutions.  You get points for catching the bugs.

1.  We compile and run your unit tests with a **correct solution**.
    - Tests that pass are **valid**.
    - Tests that fail are **invalid**, they falsely report a bug.
3.  We compile and run all of your **valid** tests against each **buggy solution**.
    - If any of your tests fail, you caught the bug.
    - You earn points for each bug that you catch.

### Requirements and Restrictions

It is our goal for you to gain practice with good C++ code, classes,
and polymorphism.


| DO | DO NOT |
| -- | ------ |
| Modify `.cpp` files | Modify `.hpp` files |
| Write helper functions in `Card.cpp` and `Pack.cpp` as non-member functions in the `.cpp` files and declare them `static` | Modify `.hpp` files |
| Use these libraries: `&lt;iostream&gt;`, `&lt;fstream&gt;`, `&lt;cstdlib&gt;`, `&lt;cassert&gt;`, `&lt;cstring&gt;`, `&lt;string&gt;`, `&lt;array&gt;`, `&lt;vector&gt;`, `&lt;sstream&gt;` &lt;br&gt;Use the `&lt;algorithm&gt;` library, but only for the `sort()` function. | Use other libraries. &lt;br&gt;&lt;br&gt;Use `&lt;algorithm&gt;` library for anything other than the `sort()` function. |
| `#include` a library to use its functions | Assume that the compiler will find the library for you (some do, some don&apos;t) |
| | `#include` an unnecessary `.hpp` file, such as `#include Pack.hpp` in either `Card.cpp` or in `Player.cpp` (This introduces undesirable dependencies, e.g. that the `Card`/`Player` ADTs require the `Pack` ADT to exist and be properly implemented.) |
| Use C++ strings | Use C-strings other than when checking `argv` |
| Send all output to standard out (AKA stdout) by using `cout` | Send any output to standard error (AKA stderr) by using `cerr` |
| `const` global variables | Global or static variables |
| Pass large structs or classes by reference | Pass large structs or classes by value |
| Pass by `const` reference when appropriate | &quot;I don&apos;t think I&apos;ll modify it ...&quot; |
| Variables on the stack | Dynamic memory (`new`, `malloc()`, etc.) outside of the `Player_factory`. |


## Acknowledgments

The original project was written by Andrew DeOrio, Fall 2013. The
project was modified to use C++ style object oriented programming and
the specification updated by the Fall 2015 staff.
</data>
      <data key="v_name">chunk-836e0dd33c346d6ab2b7bc8da851257d</data>
      <data key="v_id">n114</data>
    </node>
    <node id="n115">
      <data key="v_hash_id">chunk-97b512c3a5231e7c1ea317f1a9cf2152</data>
      <data key="v_content">---
layout: spec
---
EECS 280 Project 5: Text Editor
===============================
{: .primer-spec-toc-ignore }

Fall 2024 release.

Project due 8:00pm EST Monday November 25, 2024.

You may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)).

&lt;!-- ## Change Log --&gt;


## Introduction
The learning goals of this project include Container ADTs, Dynamic Memory, The Big Three, Linked Lists, and Iterators.  You will gain experience with `new` and `delete`, constructors and destructors, and the `List` data structure that is similar to `std::list` from the standard library.

When you&apos;re done, you&apos;ll have implemented the basic features of a text
editor that is usable through a terminal-based visual editor, similar
to other terminal editors such as
[Pico](https://en.wikipedia.org/wiki/Pico_(text_editor)),
[nano](https://en.wikipedia.org/wiki/GNU_nano),
[Emacs](https://en.wikipedia.org/wiki/Emacs), and
[vi](https://en.wikipedia.org/wiki/Vi_(text_editor)).

&lt;img src=&quot;img/femto-light.png#gh-light-mode-only&quot; width=&quot;600px&quot; class=&quot;no-border&quot; /&gt;
&lt;img src=&quot;img/femto-dark.png#gh-dark-mode-only&quot; width=&quot;600px&quot; class=&quot;no-border&quot; /&gt;

## Setup
Set up your visual debugger and version control, then submit to the autograder.

### Visual debugger
During setup, name your project `list-editor`. Use this starter files link: `https://eecs280staff.github.io/list-editor/starter-files.tar.gz`

| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |

You should end up with a folder with starter files that look like this.  You may have already renamed files like `List.hpp.starter` to `List.hpp`.
```console
$ ls
List.hpp.starter               e0.cpp
List_compile_check.cpp         femto.cpp
List_public_tests.cpp          line.cpp
List_tests.cpp.starter         line_test1.in
Makefile                       line_test1.out.correct
TextBuffer.hpp                 line_test2.in
TextBuffer_public_tests.cpp    line_test2.out.correct
TextBuffer_tests.cpp.starter   unit_test_framework.hpp
```
{: data-variant=&quot;no-line-numbers&quot; }

Here&apos;s a short description of each starter file.

| File(s) | Description |
| ------- | ----------- |
| `List.hpp.starter` | Starter code for the `List` class template. |
| `List_tests.cpp.starter` | Starter code for your `List` unit tests. |
| `List_compile_check.cpp` | Compile check test for `List`. |
| `List_public_tests.cpp` | A very small set of test cases for `List`. |
| `Makefile` | Helper commands for building. |
| `TextBuffer.hpp` | Interface specification for the `TextBuffer` class. |
| `TextBuffer_public_tests.cpp` | Public test cases for the `TextBuffer` class. |
| `TextBuffer_tests.cpp.starter` | Starter code for your `TextBuffer` unit tests. |
| `e0.cpp` | A basic visual editor for testing the `TextBuffer` class. |
| `femto.cpp` | A more functional visual editor that uses the `TextBuffer` class. |
| `line.cpp` | A simple command line tool to test the `TextBuffer` class. |
| `line_test1.in`&lt;br/&gt; `line_test1.out.correct`&lt;br/&gt; `line_test2.in`&lt;br/&gt; `line_test2.out.correct` | Input and correct output for system tests with `line.cpp`. |

### Version control
Set up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).

After you&apos;re done, you should have a local repository with a &quot;clean&quot; status and your local repository should be connected to a remote GitHub repository.
```console
$ git status
On branch main
Your branch is up-to-date with &apos;origin/main&apos;.

nothing to commit, working tree clean
$ git remote -v
origin	https://github.com/awdeorio/list-editor.git (fetch)
origin	https://github.com/awdeorio/list-editor.git (push)
```
{: data-variant=&quot;no-line-numbers&quot; }

You should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).
```console
$ head .gitignore
# This is a sample .gitignore file that&apos;s useful for C++ projects.
...
```
{: data-variant=&quot;no-line-numbers&quot; }

### Group registration
Register your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.


## Linked list
Start by following the instructions in the [Setup](#setup-1) section below. Then implement your doubly-linked list in `List.hpp`.  `List.hpp.starter` provides prototypes for each function.  Because `List` is a *templated*, function implementations go in `List.hpp`.  There is no `List.cpp`.

While the `List` from lecture was singly linked, this `List` is doubly
linked. This `List` also contains an iterator interface. The iterator
keeps track of both the current node as well as the `List` to which it
belongs - this allows us to go backwards from an end iterator by
looking up the last node in the `List`.

Do not modify the public interface of the `List` class.  Implement a doubly-linked list.  No arrays or vectors, etc. Manage memory allocation so that there are no memory leaks ([Leak checking tutorial](https://eecs280staff.github.io/tutorials/setup_leakcheck.html)).

You can compile and run the provided compile check and `List` tests as follows.
```console
$ make List_compile_check.exe
$ make List_public_tests.exe
$ ./List_public_tests.exe
```
{: data-variant=&quot;no-line-numbers&quot; }

Write tests for `List` in `List_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You&apos;ll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.
```console
$ make List_tests.exe
$ ./List_tests.exe
```
{: data-variant=&quot;no-line-numbers&quot; }

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Getting an error about `typename`?  Take a look at our [reference on Typename](typename.html).
&lt;/div&gt;

### Setup
Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):
-  `List.hpp.starter` -&gt; `List.hpp`
-  `List_tests.cpp.starter` -&gt; `List_tests.cpp`

Edit `List.hpp`, adding a function stub for each member function declared in `List.hpp`, either inside or outside the class definition: For example:

```c++
// Inside the class definition:
template &lt;typename T&gt;
class List {
  ...
  
  bool empty() const {
    assert(false);
  }

  ...
};

// Or, outside the class definition:
template&lt;typename T&gt;
bool List&lt;T&gt;::empty() const {
  assert(false);
}
```

The List tests should compile and run. The public tests will fail until you implement the functions.  The file for your test cases (`List_tests.cpp`) will pass because it initially only contains `ASSERT_TRUE(true)`.
```console
$ make List_public_tests.exe
$ ./List_public_tests.exe
$ make List_tests.exe
$ ./List_tests.exe
```
{: data-variant=&quot;no-line-numbers&quot; }

At this point, we haven&apos;t written the List Iterator, so `List_compile_check.exe` won&apos;t compile.  You&apos;ll need to take a look at the lecture about iterators and write your own tests.  After you do, use the provided compile check like this:
```console
$ make List_compile_check.exe
```
{: data-variant=&quot;no-line-numbers&quot; }

Configure your IDE to debug either the public tests or your own tests.

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;/th&gt;
  &lt;th&gt;
  Public tests
  &lt;/th&gt;
  &lt;th&gt;
  Your own tests
  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/List_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/List_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/List_public_tests.exe`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/List_tests.exe`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Xcode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `List_public_tests.cpp`, `List.hpp`
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `List_tests.cpp`, `List.hpp`
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `List_public_tests.cpp`
  - Exclude `List_compile_check.cpp`, `List_tests.cpp`, `TextBuffer_public_tests.cpp`, `TextBuffer_tests.cpp`, `e0.cpp`, `femto.cpp`, `line.cpp`, `main.cpp` (if present)
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `List_tests.cpp`
  - Exclude `List_compile_check.cpp`, `List_public_tests.cpp`, `TextBuffer_public_tests.cpp`, `TextBuffer_tests.cpp`, `e0.cpp`, `femto.cpp`, `line.cpp`, `main.cpp` (if present)
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

## TextBuffer

A *text buffer* holds an editable sequence of characters and at the same time
has the ability to report the current row and column (You can display
this information in Pico/nano with `Ctrl-C`, or in Emacs by typing
`M-x line-number-mode` and `M-x column-number-mode`.). The text buffer
keeps track of the current cursor position where all edits are done and
allows scrolling using the arrow keys to move the cursor
through the text.

In this section, you will implement the `TextBuffer`
class according the interface defined in the `TextBuffer.hpp` file.
The data representation of a `TextBuffer` is a doubly linked list
of characters (either your implementation from [part 1](#linked-list)
or `std::list` from the C++ standard library). The `TextBuffer` also
stores an iterator that indicates the current position of the cursor,
the current row and column position, and the index of the cursor with
respect to the entire buffer (i.e. how many characters from the start
to the cursor).

The definition of the ``TextBuffer`` class is shown
below:

```c++
class TextBuffer {
  using CharList = std::list&lt;char&gt;;
  using Iterator = std::list&lt;char&gt;::iterator;
private:
  CharList data;           // linked list that contains the characters
  Iterator cursor;         // current position within the list
  int row;                 // current row
  int column;              // current column
  int index;               // current index
  // ... public interface not shown
};
```

We use `CharList` as a *type alias* for either `List&lt;char&gt;`, or
`std::list&lt;char&gt;` (your choice -- the autograder will use
`std::list&lt;char&gt;` to avoid any issues with your `List`
implementation), representing a doubly-linked list of characters. The
following list contains the text ``spaces``:

&lt;img src=&quot;img/dll1.svg&quot; width=&quot;800px&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;

To use a linked list as a text buffer, we need to keep track of the
*cursor*, which represents the position where edits can be made in the
buffer. In many visual text editors, the cursor appears as a colored
rectangle, so that if the cursor was pointing to the node containing
the character `&apos;c&apos;`, we&apos;d see it displayed as

&lt;img src=&quot;img/spaces1.svg&quot; height=&quot;40px&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;

Pressing the left arrow key in a text editor moves the cursor one
character backward (to the left).

&lt;img src=&quot;img/spaces2.svg&quot; height=&quot;40px&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;

We can now draw the linked list corresponding to this text buffer
along with the cursor:

&lt;img src=&quot;img/dll2.svg&quot; width=&quot;800px&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;

Deletions in a text buffer take place at the cursor. If we
delete a character in the previous picture, it will remove the
character at the cursor:

&lt;img src=&quot;img/dll3.svg&quot; width=&quot;700px&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;

Insertions happen to the left of the cursor. If we next typed the
`i` key, that character would be entered in to the left of the
cursor.

&lt;img src=&quot;img/dll4.svg&quot; width=&quot;800px&quot; class=&quot;invert-colors-in-dark-mode&quot; /&gt;

One consequence of this design is that, in order for additions to be
made to the end of the buffer, the cursor needs to be able to go to
the right of all the text. In other words, it must be possible for the
`cursor` member variable to be equal to the end iterator for the
underlying list. Starting from the buffer above, we can see what that
looks like from the editor&apos;s point of view:

&lt;img src=&quot;img/spices_full.svg&quot; width=&quot;550px&quot;  class=&quot;invert-colors-in-dark-mode&quot; /&gt;

As a doubly-linked list, this final buffer looks like this:

&lt;img src=&quot;img/dll5.svg&quot; width=&quot;800px&quot;  class=&quot;invert-colors-in-dark-mode&quot; /&gt;

A new, empty text buffer containing no text starts with the cursor at
the end iterator.

### Rows and Columns

One thing we care a great deal about in a text editor is which
characters are newlines, because that is what lets us know our
position in the document: the row and column. In Emacs (and the
remaining tasks of this assignment), the first row is row 1, and the
first column is column 0. In these Emacs buffers, you can see the
(row, column) displayed in the lower-right corner:

&lt;img src=&quot;img/emacs-rowcol.png&quot;/&gt;

We can calculate the column of the cursor by working backwards until
we find a newline, and we can calculate the row of the cursor by
working backwards to the beginning of the buffer and counting the
newlines. Note that in the middle example, the cursor is atop a cell
containing a newline `\n`, but the cursor is at the end of
row 1, not the beginning of row 2.

By tracking the row and column in the data structure, we can report
this information to the user without ever having to recalculate the
row. It&apos;s good to avoid this, because calculating the ``row`` every
time an edit is made can be expensive to run. You should also keep
track of the ``column`` field but sometimes you might need to
recalculate this field depending on the type of edit. Any single row
is usually relatively short (80 columns maximum, if you&apos;re using good
style), so this should be fast. Specifically, we only need to
recalculate the column when we move left from the beginning of one
line to the end of the previous line.

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** The `TextBuffer` class has a private `compute_column`
member function that is intended to be a helper function for
`backward`. Implement `compute_column` before you start implementing
`backward`.
&lt;/div&gt;

In `TextBuffer.cpp`, efficiently implement the interface functions for manipulating editors
given in the definition of the ``TextBuffer`` class in
``TextBuffer.hpp``.

### Setup
Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):
-  `TextBuffer_tests.cpp.starter` -&gt; `TextBuffer_tests.cpp`

Create a new file `TextBuffer.cpp`. Add function stubs for all the
functions in `TextBuffer.hpp`. Remember to `#include
&quot;TextBuffer.hpp&quot;`.

### Testing the TextBuffer

The `TextBuffer` tests should compile and run once you have created
`TextBuffer.cpp` and added function stubs. The public tests will fail
until you implement the functions. The file for your test cases
(`TextBuffer_tests.cpp`) will pass because it initially only contains
`ASSERT_TRUE(true)`.

```console
$ make TextBuffer_public_tests.exe
$ ./TextBuffer_public_tests.exe
$ make TextBuffer_tests.exe
$ ./TextBuffer_tests.exe
```
{: data-variant=&quot;no-line-numbers&quot; }

### Interactive Testing

You can also test your `TextBuffer` implementation interactively by
compiling and running the provided `line.cpp`, which visualizes the
contents of a text buffer. Make sure your code passes the tests in `TextBuffer_public_tests.cpp` (see above) before using the interactive tests in `line.cpp`.

```console
$ make line.exe
$ ./line.exe
LINE Is Not an Editor -- it is a linear visualization of a TextBuffer.
The &apos;&lt;&apos; character mimics a call to backward()
The &apos;&gt;&apos; character mimics a call to forward()
The &apos;#&apos; character mimics a call to remove()
The &apos;^&apos; character mimics a call to up()
The &apos;!&apos; character mimics a call to down()
The &apos;[&apos; character mimics a call to move_to_row_start()
The &apos;]&apos; character mimics a call to move_to_row_end()
The &apos;@&apos; character mimics a call to insert() with a newline
All other characters just mimic insert() with that character

Give initial input (empty line quits):

```
{: data-variant=&quot;no-line-numbers&quot; }

Try entering `steady^&lt;&lt;&lt;&lt;^&gt;&gt;^&gt;&gt;^@&lt;&lt;@^^` as the initial input. Here are
the first few lines of the result:

```console
Give initial input (empty line quits):
steady^&lt;&lt;&lt;&lt;^&gt;&gt;^&gt;&gt;^@&lt;&lt;@^^
STARTING
start : |       :(1,0 )
add   : s|      :(1,1 )
add   : st|     :(1,2 )
add   : ste|    :(1,3 )
add   : stea|   :(1,4 )
add   : stead|  :(1,5 )
add   : steady| :(1,6 )
up    : steady| :(1,6 )
left  : stead|y :(1,5 )
left  : stea|dy :(1,4 )
```

The special commands directly invoke the corresponding member
functions in the `TextBuffer` class. If an operation cannot be
performed (e.g., invoking the `up()` member function to move the
cursor up a line when it is already at the first row), the function
should leave the text buffer **unchanged** instead of raising an error
or assertion violation.

We have provided two test cases that use `line.exe`, which you can
run as follows:

``` console
$ ./line.exe &lt; line_test1.in &gt; line_test1.out
$ diff -qB line_test1.out line_test1.out.correct
$ ./line.exe &lt; line_test2.in &gt; line_test2.out
$ diff -qB line_test2.out line_test2.out.correct
```
{: data-variant=&quot;no-line-numbers&quot; }

Alternatively, use

``` console
$ make test
```
{: data-variant=&quot;no-line-numbers&quot; }

to run all `List` and `TextBuffer` tests.

### Visual Text Editors

The starter files include two visual frontends, `e0` and `femto`, that use your
`TextBuffer` class to implement a fully functional, terminal-based editor. You
may use these to stress test your `TextBuffer` implementation, but we recommend
you ensure your code passes both the `TextBuffer_public_tests` and `line` interactive
tests described above before testing with either editor.

&lt;div class=&quot;primer-spec-callout warning&quot; markdown=&quot;1&quot;&gt;
You may need to install the
[ncurses](https://en.wikipedia.org/wiki/Ncurses) library before you
can use the visual editors. On WSL, run:

```console
$ sudo apt install libncurses5-dev
```
{: data-variant=&quot;no-line-numbers&quot; }

On macOS, run:

```console
$ brew install ncurses
```
{: data-variant=&quot;no-line-numbers&quot; }

Close your terminal and reopen your terminal.
&lt;/div&gt;

The first visual editor is called *E0*, and you can compile and run it
as follows:

```console
$ make e0.exe
$ ./e0.exe
```
{: data-variant=&quot;no-line-numbers&quot; }

This will launch a visual editor that will allow you to type text, use
delete or backspace to remove characters, and use the arrow and
home/end keys to navigate the text. The key combination `Ctrl-X` exits
the editor.

&lt;img src=&quot;img/e0-light.png#gh-light-mode-only&quot; width=&quot;640px&quot; class=&quot;no-border&quot; /&gt;
&lt;img src=&quot;img/e0-dark.png#gh-dark-mode-only&quot; width=&quot;640px&quot; class=&quot;no-border&quot; /&gt;

The second visual editor is called *FEMTO*, and it provides much of
the functionality of terminal editors such as 
[Pico](https://en.wikipedia.org/wiki/Pico_(text_editor)). Use the following
to compile and run it:

```console
$ make femto.exe
$ ./femto.exe
```
{: data-variant=&quot;no-line-numbers&quot; }

You can also specify a filename at the command line. For instance, we
can examine the visual editor&apos;s own source code with

```console
$ ./femto.exe femto.cpp
```
{: data-variant=&quot;no-line-numbers&quot; }

You should see something like the following:

&lt;img src=&quot;img/femto-light.png#gh-light-mode-only&quot; width=&quot;720px&quot; class=&quot;no-border&quot; /&gt;
&lt;img src=&quot;img/femto-dark.png#gh-dark-mode-only&quot; width=&quot;720px&quot; class=&quot;no-border&quot; /&gt;

You can scroll between pages with the page-up and page-down keys (or
just the up and down keys at the top and bottom rows), and you can use
the special commands listed at the bottom - for example, `^X` means
the combination `Ctrl-X`, which you can use to exit.

## Submission and grading

Submit these files to the [autograder](https://autograder.io).
  - `List.hpp`
  - `List_tests.cpp`
  - `TextBuffer.cpp`

This project will be autograded for correctness, comprehensiveness of
your test cases, and programming style. See the [style checking
tutorial](https://eecs280staff.github.io/tutorials/setup_style.html)
for the criteria and how to check your style automatically on CAEN.

### Testing

Check for memory leaks using the [Leak checking tutorial](https://eecs280staff.github.io/tutorials/setup_leakcheck.html).

Run all the unit tests and system tests.  This includes the public tests we provided and the unit tests that you wrote.

```console
$ make test
```
{: data-variant=&quot;no-line-numbers&quot; }

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Run commands in parallel with `make -j`.
```console
$ make -j4 test
```
{: data-variant=&quot;no-line-numbers&quot; }
&lt;/div&gt;


### Unit Test Grading

We will autograde your `List` unit tests. We will **not** grade your
`TextBuffer` tests.

Your unit tests must use the [unit test framework](https://eecs280staff.github.io/unit_test_framework/).

A test suite must complete less than 5 seconds and contain 50 or fewer `TEST()` items.  One test suite is one `_tests.cpp` file.

To grade your unit tests, we use a set of intentionally buggy instructor solutions.  You get points for catching the bugs.

1.  We compile and run your unit tests with a **correct solution**.
    - Tests that pass are **valid**.
    - Tests that fail are **invalid**, they falsely report a bug.
3.  We compile and run all of your **valid** tests against each **buggy solution**.
    - If any of your tests fail, you caught the bug.
    - You earn points for each bug that you catch.

### Requirements and restrictions

It is our goal for you to gain practice with good C++ code, classes,
and dynamic memory.

| DO                                                                                                                                                              | DO NOT                                                                                                                |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| Modify `.cpp` files and `List.hpp` | Modify the signature of any public functions in `List.hpp` or `TextBuffer.hpp`  |
| For `List`, make helper member functions private | Modify the public interface of `List` or `TextBuffer` |
| Use any part of the STL except for containers in your `List` implementation | Use STL containers in your implementation of `List` |
| `#include` a library to use its functions | Assume that the compiler will find the library for you (some do, some don&apos;t) |
| Use C++ strings  | Use C-strings |
| Pass large structs or classes by reference | Pass large structs or classes by value |
| Pass by const reference when appropriate | &quot;I don&apos;t think I&apos;ll modify it ...&quot; |
| Use the [Address Sanitizer](https://eecs280staff.github.io/tutorials/setup_asan.html) to check for memory errors | &quot;It&apos;s probably fine...&quot; |

## Acknowledgments

This project has been adapted from the course 15-122 (Principles of
Imperative Computation) offered at Carnegie Mellon University, which
is taught in a safe subset of C called *C0*. This project was ported to
C++ by Saquib Razak.

This document is licensed under a [Creative Commons Attribution-NonCommercial 4.0 License](https://creativecommons.org/licenses/by-nc/4.0/). You&apos;re free to copy and share this document, but not to sell it.  You may not share source code provided with this document.
</data>
      <data key="v_name">chunk-97b512c3a5231e7c1ea317f1a9cf2152</data>
      <data key="v_id">n115</data>
    </node>
    <node id="n116">
      <data key="v_hash_id">chunk-b49f13e04395d1d33b9ff49fe35c9778</data>
      <data key="v_content">---
layout: spec
latex: true
---

EECS 280 Project 1: Statistics
==============================
{: .primer-spec-toc-ignore }

Due 8pm ET Mon Jan 27, 2025.  This is an individual project.

Winter 2025 release.

&lt;div class=&quot;primer-spec-callout info&quot;&gt;
  &lt;p&gt;&lt;strong&gt;IMPORTANT&lt;/strong&gt; If you are retaking the course, please note the project has changed significantly this term. While we always suggest students retaking the course redo the entire project from scratch (as it is helpful practice), we nevertheless want to emphasize you must work from a fresh set of starter files.&lt;/p&gt;
&lt;/div&gt;

## Introduction

Statistical analysis is a key tool in many fields, from the natural and medical sciences to social sciences and business. It&apos;s used to summarize data, make inferences about populations, and test hypotheses. The intersection of statistical analysis and computation also underlies many emerging fields like machine learning and data science.

In this project, you&apos;ll implement a program that computes descriptive statistics and performs two-sample analysis on a given data set. 

For example, consider data from [How Couples Meet and Stay Together (HCMST)](https://exhibits.stanford.edu/data/catalog/ns183dp7831), a study of how Americans meet their spouses and romantic partners. We can investigate the age (`ppage`) of survey respondents depending on whether or not they met their partner online (`q24_met_online`).

As shown below, our program displays descriptive statistics for respondents&apos; age in the two groups. It also runs a 95% confidence interval procedure for the difference in means between the groups, meaning there is a 95% chance the interval computed from the sample contains the true value of the difference in means among the overall population. Overall, we can be reasonbly confident the mean age of people who met their partner online is several years younger than those who did not.

```console
$ ./two_sample.exe HCMST_ver_3.04.tsv q24_met_online 1 0 ppage
reading column q24_met_online from HCMST_ver_3.04.tsv
reading column ppage from HCMST_ver_3.04.tsv
Group A: ppage | q24_met_online = 1
count = 270
sum = 10687
mean = 39.5815
stdev = 12.2103
median = 40.5
min = 19
max = 86
  0th percentile = 19
 25th percentile = 29
 50th percentile = 40.5
 75th percentile = 49
100th percentile = 86

Group B: ppage | q24_met_online = 0
count = 2664
sum = 125721
mean = 47.1926
stdev = 16.1446
median = 46
min = 19
max = 95
  0th percentile = 19
 25th percentile = 35
 50th percentile = 46
 75th percentile = 58
100th percentile = 95

Confidence interval for mean(ppage | A) - mean(ppage | B):
  95% [-9.31595, -6.05068]

```
{: data-variant=&quot;no-line-numbers&quot; }

## Learning Goals

The learning goals of this project include C++ fundamentals, control-flow structures, vectors, procedural abstraction, and unit testing. It&apos;s also a chance to get used to the C++ toolchain and review your 100-level programming skills. No prior knowledge of probability or statistics is required or expected for this project.

## Setup

Set up your project in your visual debugger.  We recommend VS Code because it&apos;s easier to use.  Many people use Visual Studio (Windows) or XCode (macOS).

During setup, name your project `stats`. Use this starter files link: `https://eecs280staff.github.io/stats/starter-files.tar.gz`

| [VS Code Tutorial (recommended)](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio Tutorial](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode Tutorial](https://eecs280staff.github.io/tutorials/setup_xcode.html) |

If you created a `main.cpp` while following the setup tutorial, delete it. You&apos;ll use the provided starter code for `two_sample.cpp` instead. You should end up with a folder with starter files that looks like this. (You may have already renamed files like `two_sample.cpp.starter` to `two_sample.cpp`.)

```console
$ ls
Makefile          library.cpp  stats_public_tests.cpp
cats.csv          library.hpp  stats_tests.cpp.starter
cats.out.correct  stats.hpp    two_sample.cpp.starter
```
{: data-variant=&quot;no-line-numbers&quot;}

Here&apos;s a short description of each file in this project.

| File | Description |
|----- |---- |
| `Makefile` | Helper commands for building and testing |
| `stats.hpp` | Function prototypes for statistics library |
| `stats.cpp` | Function implementations for statistics library |
| `stats_public_tests.cpp` | Public tests for the statistics library |
| `stats_tests.cpp` | Your tests for the statistics library |
| `library.cpp` | Provided code implementations |
| `library.hpp` | Provided code function prototypes |
| `two_sample.cpp` | Two-sample analysis program |
| `cats.csv` | A small dataset for testing the analysis program |
| `cats.out.correct` | Correct outputs of analysis program on cats.csv |

&lt;div class=&quot;primer-spec-callout warning&quot; markdown=&quot;1&quot;&gt;
**Pitfall:** Make sure you have set up your visual debugger before continuing.

| [VS Code Tutorial (recommended)](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio Tutorial](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode Tutorial](https://eecs280staff.github.io/tutorials/setup_xcode.html) |

&lt;/div&gt;

## Statistics Background
This section provides an introduction to the statistical analyses you&apos;ll implement in this project.


### Descriptive Statistics
Descriptive statistics are computed properties that quantitatively summarize the underlying distribution of measured data. For example, the *mean* of a data set is a measure of its central tendency whereas the *standard deviation* measures how spread out the data are. Details of several descriptive statistics are given in the [Statistics Functions](#statistics-functions) section below.

### Sampling
We often estimate qualities of a large *population* by measurement of a relatively small *sample*. For instance, we might want to know how many US residents are currently in a relationship, the distribution of age among these people, and whether they met their partner online or in-person. Rather than ask over 300 million people these questions, we might survey a subset of a few thousand people.

There are many essential considerations for proper survey procedure. For example, obtaining a random, unbiased sample of survey participants is important to ensure the sample is representative of the overall population. On the other hand, special attention (e.g. oversampling) may be needed to ensure underrepresented groups are not marginalized. Survey designers should mitigate potential threats to validity such as response bias (e.g. survey answers may be affected by perceived social desirability of answers). These considerations are important, but beyond the scope of this project.

### Two-Sample Analysis
We may also want to compare two different samples via statistical analysis and make inferences about the underlying populations they represent. We might survey different populations entirely separately, or partition a data set into subgroups based on specific criteria. For example, we might filter responses to the HCMST survey based on whether people met their partner online or not, yielding two samples representing distinct populations. Then, we could compute the mean age for each sample, as well as the difference between those means, finding that to be approximately 7.6 years older for the sample of people who did not meet their partner online.

However, inferences drawn from samples must be qualified in a way that accounts for the probability the observed difference is due to random chance (i.e. the uncertainty introduced by sampling). It would not be responsible to simply report the 7.6 point estimate as the difference in means among the underlying populations.

#### Bootstrap Confidence Intervals
Instead of reporting a single estimate based on a sample, we instead set up a procedure for computing a range of possible values (i.e. lower and upper bounds) defining a *confidence interval* at a particular *confidence level* of X%. The interpretation is as follows: *If we collected many samples (i.e. ran the survey many times), X% of the time the computed confidence interval would contain the true underlying value among the population*.

Of course, it&apos;s not practical to actually conduct the survey many times, so we instead use an approach called *bootstrap resampling*. The essential idea is that we simulate taking several samples by instead re-sampling (with replacement) from one original sample.

For example, assume the original sample contained individuals [A, B, C, D]. Bootstrap resamples of this could be [A, C, C, D] or [A, A, A, B]. Each approximates a plausible sample we could have drawn from the underlying population (i.e. a resample of [A, A, A, B] approximates a sample that happened to have more people like A and less like C or D).

We can compute the statistic of interest (e.g. the difference in means) for many resamples to obtain an approximate *sampling distribution* from which we can compute a confidence interval.

Let&apos;s apply this to our running example. We start with the original two samples of people who did or did not meet their partner online. Then, we repeat this process 1000 times:
1. Generate a bootstrap resample for each of the two original samples.
2. Compute the difference in means between the two resamples.
3. Record the computed value.

Finally, we determine the range containing the middle 95% of the values computed via resampling and report this as the 95% confidence interval.

The starter code for `two_sample.cpp` provides much of the overall structure for computing bootstrap confidence intervals and includes comments to guide you through implementing the rest.

You might also find this [video](https://www.youtube.com/watch?v=Xz0x-8-cgaQ) on bootstrapping helpful, which covers the same basic ideas described above. While there are many approaches to find confidence intervals, we chose bootstrapping for this project due to its uniquely computational approach that is well-suited for a programming project.

## Statistics Library

The `stats.hpp` file specifies a general-purpose statistics library, including declarations and RME interface specifications of several functions for computing descriptive statistics and filtering data. You&apos;ll write implementations for each of these functions in `stats.cpp`.

The data sets are stored as a `std::vector&lt;double&gt;`. If you haven&apos;t used vectors in C++ before, check out our [Vector Reference](vector.html).  C++ vectors are similar to Java ArrayLists, Javascript arrays, and Python lists.

### Setup

Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):

-  `stats_tests.cpp.starter` -&gt; `stats_tests.cpp`

Add a new file `stats.cpp` containing a &quot;function stub&quot; for each prototype in `stats.hpp`, as shown below. Adding stubs ensures the program can compile, even though not everything is finished yet. The `assert(false);` in each is a placeholder that triggers an error if an unfinished function were to run - you should remove them once you implement each function.

```c++
// stats.cpp
#include &quot;stats.hpp&quot;
#include &lt;cassert&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // sort
#include &lt;cmath&gt; // sqrt, modf

using namespace std;

int count(vector&lt;double&gt; v) {
  assert(false);
}

double sum(vector&lt;double&gt; v) {
  assert(false);
}

double mean(vector&lt;double&gt; v) {
  assert(false);
}

double median(vector&lt;double&gt; v) {
  assert(false);
}

double min(vector&lt;double&gt; v) {
  assert(false);
}

double max(vector&lt;double&gt; v) {
  assert(false);
}

double stdev(vector&lt;double&gt; v) {
  assert(false);
}

double percentile(vector&lt;double&gt; v, double p) {
  assert(false);
}

vector&lt;double&gt; filter(vector&lt;double&gt; v,
                      vector&lt;double&gt; criteria,
                      double target) {
  assert(false);
}
```
{: data-title=&quot;stats.cpp&quot; }

Once you&apos;ve added the stubs, you can compile and run the public tests.

```console
$ make stats_public_tests.exe
$ ./stats_public_tests.exe
```

The tests should compile successfully but won&apos;t pass until you&apos;ve implemented each function.

&lt;div class=&quot;primer-spec-callout warning&quot; markdown=&quot;1&quot;&gt;
**Pitfall:** Do not include a `main()` function in your `stats.cpp` file.  Remember, `stats.cpp` is a library of functions that another module like `two_sample.cpp` will use.
&lt;/div&gt;

### Statistics Functions

This section provides background for each statistical method and tips for implementation.

#### General Tips

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Your implementation of some functions may require sorting the input vector. You can use the `std::sort()` function from the `&lt;algorithm&gt;` library for this. Here&apos;s an example:

```c++
vector &lt;double&gt; v; // assume v contains some data
std::sort(v.begin(), v.end());
```
&lt;/div&gt;

&lt;div class=&quot;primer-spec-callout warning&quot; markdown=&quot;1&quot;&gt;
**Pitfall:** If you&apos;re getting errors like this, check out the [Comparisons tutorial](comparisons.html).

```
error: comparison between signed and unsigned integer expressions
```
&lt;/div&gt;

#### `count()`, `sum()`, `mean()`

The `count()` function returns the number of values in a data set.

The `sum()` function computes the *sum* of the values in a data set.

The `mean()` function computes the *arithmetic mean* of a data set:

  $$
  \bar{x} = \frac{1}{n}\left(\sum_{i=1}^n x_i\right) = \frac{x_1 + x_2 + \dots + x_n}{n}
  $$

Here, $$\bar{x}$$ denotes the mean, $$x_i$$ denotes the value of the $$i$$th data point, and $$n$$ is the sample size.

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Call `count()` and `sum()` as helper functions in your implementation of `mean()`.
&lt;/div&gt;

#### `median()`

Computes the *median*, which is the &quot;middle&quot; value in a data set. In other words, it is the value for which half the data points lie below the value, and half lie above it. If the number of data values $$n$$ is odd, this is just the middle value when the data set is sorted. If the number of data values is even, then it is the average of the two values in the middle.

#### `min()`, `max()`
These functions return the *minimum* and *maximum* values in the data set.

#### `stdev()`

The `stdev()` function computes the *standard deviation*, which is a measure of the &quot;spread&quot; among data values. For instance, while the data sets $$(2, 2, 2)$$ and $$(1, 2, 3)$$ have the same mean of 2, the latter set has a higher standard deviation than the former one since the values are more spread apart. We specifically use the [corrected sample standard deviation](https://en.wikipedia.org/wiki/Standard_deviation#Corrected_sample_standard_deviation), which is defined as:

  $$
  s_x = \sqrt{\frac{1}{n-1}\sum_{i=1}^n(x_i-\bar{x})^2}
  $$

&lt;div class=&quot;primer-spec-callout warning&quot; markdown=&quot;1&quot;&gt;
**Pitfall:** Make sure that your code is doing floating-point rather than integer division.

``` c++
double x = 1 / 4;    // integer division: x is 0
double y = 1.0 / 4;  // floating-point division: y is 0.25
```
&lt;/div&gt;

When writing `stdev()`, use the [`sqrt()` function](https://cplusplus.com/reference/cmath/sqrt/), which calculates a square root.

```c++
#include &lt;cmath&gt;
// ...
cout &lt;&lt; &quot;the square root of 4 is &quot; &lt;&lt; sqrt(4) &lt;&lt; &quot;\n&quot;;
```

#### `percentile()`

A call to `percentile(data, p)` computes the $$ p^{th} $$ *percentile* for a fractional value $$0 \le p \le 1$$, which is the threshold below which a portion $$p$$ of the data occurs. For example, `percentile(data, 0.3)` returns the value below which 30% of the data occur.

We use the percentile formula that is implemented in many software packages, which estimates the percentile $$v_p$$ for a fraction $$p$$ as follows:

  1. Compute the *rank*, which is the approximate position in the (&lt;mark&gt;sorted&lt;/mark&gt;) data set corresponding to the fraction:

     $$
     rank = p(n-1) + 1\text{, for $0 \le p \le 1$}
     $$

  2. Split the rank into its integer and decimal components $$k$$ and $$d$$ respectively, so that

     $$
     rank = k + d\text{, where $k$ is an integer and $0 \le d &lt; 1$}
     $$

  3. Then the percentile $$v_p$$ is

     $$
     v_p = v_k + d(v_{k+1} - v_k)\text{, for $1 \le k \le n$}
     $$

     where $$v_k$$ is the $$k$$th data point from the sorted data set. Essentially, $$v_p$$ is the weighted average of the $$k$$th and $$(k+1)$$th data points in the &lt;mark&gt;sorted&lt;/mark&gt; set, with the weight of each value determined by the decimal component $$d$$: a weight of $$d$$ for the $$(k+1)$$th value and a weight of $$1-d$$ for the $$k$$th value.

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Use the [`modf()` function](http://www.cplusplus.com/reference/cmath/modf/) to break a double into its integral and fractional parts.

```c++
#include &lt;cmath&gt;
// ...
double pi = 3.14159265;
double intpart = 0;
double fractpart = 0;
fractpart = modf(pi, &amp;intpart);
// intpart is now 3, factpart is now 0.14159265
```
&lt;/div&gt;

&lt;div class=&quot;primer-spec-callout warning&quot; markdown=&quot;1&quot;&gt;
**Pitfall:** The formula here and the worked example below use indices that start with 1. You will need to adapt them for `vector` indexing, which starts at 0.
&lt;/div&gt;

&lt;div class=&quot;primer-spec-callout warning&quot; markdown=&quot;1&quot;&gt;
**Pitfall:** Consider an example dataset with 5 elements. For p=1, the above formula gives:
$$
v_{1.0} = v_5 + 0(v_6-v_5)
$$

This includes a nonexistent datapoint - $$v_6$$! Mathematically, everything works out because it gets multiplied by 0. However, you must ensure your implementation code never even attempts to access out-of-bounds data, which can cause undefined behavior, including a program crash (regardless of whether it would be canceled out later in the formula).
&lt;/div&gt;

**Worked Example of Percentile Computation**  
Suppose that our data set consists of the values $$35, 20, 15, 50, 40$$. What is the 40th percentile from this data set?

First, we sort the values to obtain the ordered sequence

$$
(v_1, v_2, v_3, v_4, v_5) = (15, 20, 35, 40, 50)
$$

Then, we calculate the rank for $$p = 0.4$$:

$$
rank = 0.4(5 - 1) + 1 = 2.6
$$

Splitting this into integer and decimal components, we have

$$
rank = k + d = 2 + 0.6
$$

We then calculate the percentile as

$$
v_{0.4} = v_k + d(v_{k+1}-v_k) = v_2 + 0.6(v_3-v_2) = 20 + 0.6(35-20) = 29
$$

Thus, the 40th percentile is 29.


#### `filter()`

The `filter()` function separates out the portion of a data set where some measured criterion has a particular value. For example:

```c++
// Data set of temperatures measured at different locations.
// e.g. the first measurement was at location 0 with temperature 15.5
vector&lt;double&gt; locations = {0, 1, 0, 1, 1, 2, 2, 0, 1};
vector&lt;double&gt; temps = {15.5, 23.1, 7.8, 19.2, 22.6, 4.6, 1.9, 14.3, 18.0};

// Filter to the temperature measurements at location 1
vector&lt;double&gt; temps_1 = filter(temps, locations, 1);
// temps_1 is {23.1, 19.2, 22.6, 18.0}
```

### Testing

There are two sets of unit tests for the stats module.

**1. Public Tests in `stats_public_tests.cpp`**  
A minimal set of public tests that we provide (and that match the ones on the autograder). Passing these is a good first target, but is generally not sufficient to ensure correctness. Compile and run the public stats tests with:

```console
$ make stats_public_tests.exe
$ ./stats_public_tests.exe
```

**2. Your Tests in `stats_tests.cpp`**  
Write your own comprehensive set of unit tests in `stats_tests.cpp` for each of the statistics functions declared in `stats.hpp`. Use `assert()` to verify the results of the function are as expected when called on a variety of inputs, including any relevant special cases. Keep your tests organized by splitting them into separate helper functions, as in the provided example in the `stats_tests.cpp` starter file.

Compile and run your tests with:

```console
$ make stats_tests.exe
$ ./stats_tests.exe
```

You will submit `stats_tests.cpp` to the autograder. You must write at least one test for each function in `stats.hpp`, but it&apos;s a good idea to write more. Generally speaking, your tests should not produce output to `cout` - the autograder will ignore such output, and you should use `assert()` to verify expected behavior.

&lt;div class=&quot;primer-spec-callout warning&quot; markdown=&quot;1&quot;&gt;
**Pitfall:** Due to rounding errors, two floating point numbers we expect to be equal may be slightly different. This might happen while testing `stdev()`. Check out the [Floating-point Comparisons tutorial](comparisons.html#floating-point-comparisons).
&lt;/div&gt;

### Debugging

Use your IDE&apos;s visual debugger for either the public tests or your own tests.

For example, you might set a breakpoint in the unit test that is failing, before your function from `stats.cpp` is called. Then you can use the debugger to step into the function and see what&apos;s going wrong.

Here&apos;s a reminder of how to configure the debugger to launch either the public tests or your own tests:

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;/th&gt;
  &lt;th&gt;
  Public tests
  &lt;/th&gt;
  &lt;th&gt;
  Your own tests
  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  First, compile from the terminal using `make stats_public_tests.exe`.
  
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/stats_public_tests.exe`
  
  Click the run button in the debugging tab of the left side panel.
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  First, compile from the terminal using `make stats_tests.exe`.

  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/stats_tests.exe`
  
  Click the run button in the debugging tab of the left side panel.
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  First, compile from the terminal using `make stats_public_tests.exe`.
  
  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/stats_public_tests.exe`
  
  Click the run button in the debugging tab of the left side panel.
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  First, compile from the terminal using `make stats_tests.exe`.

  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/stats_tests.exe`
  
  Click the run button in the debugging tab of the left side panel.
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;XCode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `stats_public_tests.cpp`, `stats.cpp`, `library.cpp`

  Click the run button.
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `stats_tests.cpp`, `stats.cpp`, `library.cpp`

  Click the run button.
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `stats_public_tests.cpp`
  - Exclude `stats_tests.cpp`, `two_sample.cpp`, `main.cpp` (if present)

  Click the run button.
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `stats_tests.cpp`
  - Exclude `stats_public_tests.cpp`, `two_sample.cpp`, `main.cpp` (if present)

  Click the run button.
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

### Submit
Submit `stats.cpp` and `stats_tests.cpp` to the Autograder using the direct link in the [Submission and Grading section](#submission-and-grading).


## Analysis Program

Our statistical analysis program is run like this:

```console
$ ./two_sample.exe HCMST_ver_3.04.tsv q24_met_online 1 0 ppage
```

It takes command-line arguments for the data file name (`HCMST_ver_3.04.tsv`), a filter column name (`q24_met_online`), filter A/B values (`0` and `1`), and a data column name to analyze (`ppage`).

When run, it reads data from the specified file and columns and splits into groups on the filter column and A/B values. Then, it prints descriptive statistics for the data column on each group, as well as a 95% confidence interval for the difference in means between the two groups.

The program may also be run for testing purposes with no command-line arguments provided:

```console
$ ./two_sample.exe
```

In this case, the program uses default arguments of `cats.csv`, `food`, `1`, `2`, and `weight`, performing an analysis of the weights of cats in the provided `cats.csv` sample data set according to which brand of cat food (i.e. #1 or #2) they eat.

### Setup

Rename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):

-  `two_sample.cpp.starter` -&gt; `two_sample.cpp`

If you created a `main.cpp` while following the setup tutorial, you should delete it.

### Data Sets

The analysis program can be run with any input data file in a standard delimited format (e.g. a `.csv` comma-separated value file or `.tsv` tab-separated value file) with a header row containing column names.

#### Sample Data Set: Cats
We&apos;ve provided a small data set in `cats.csv` for testing purposes:

```csv
name,food,weight
Fluffy,1,9.6
Socks,1,11.5
Mittens,1,9.9
Felix,1,10.1
Luna,1,11.2
Simba,2,9.2
Nala,2,7.8
Oliver,2,12.3
Bella,2,10.1
Milo,2,10.9
```

When the program is run without command-line arguments, it defaults to use this data set, analyzing the weights of group A (fed food #1) and group B (fed food #2). The correct program output for this case is provided in `cats.out.correct`.


#### Real Data Set: HCMST

[How Couples Meet and Stay Together (HCMST)](https://exhibits.stanford.edu/data/catalog/ns183dp7831) is a study of how Americans meet their spouses and romantic partners.

Want to try it out with real data from the [How Couples Meet and Stay Together](https://exhibits.stanford.edu/data/catalog/ns183dp7831) study?
1.  Use the following `wget` link to download the data in tsv format: `https://eecs280staff.github.io/stats/data/HCMST_ver_3.04.tsv`.
2.  The variables in the study are the first line of the tsv file.
3.  Another file called the codebook describes the variables. It can be accessed here: [https://stacks.stanford.edu/file/druid:ns183dp7831/HCMST_codebook_3_04.pdf](https://stacks.stanford.edu/file/druid:ns183dp7831/HCMST_codebook_3_04.pdf).

### Overview

Complete the code in `two_sample.cpp` to implement the two-sample analysis program. The starter code handles several tasks for you, including reading command-line arguments, reading data from an input file, and the high-level structure of the two-sample analysis. You should spend some time reading through the file to familiarize yourself with the provided code.

You will need to implement the following functions in `two_sample.cpp`:
- `print_descriptive_stats()`: Prints descriptive statistics for a given data set.
- `mean_diff_sampling_distribution()`: Returns an approximation of the sampling distribution of the difference in means between two groups, computed using bootstrap resampling.
- `confidence_interval()`: Returns a confidence interval for a given data set and interval width.

Note the provided file contains `// TODO` comments and `assert(false);` placeholders for each function you need to implement. You should remove these as you complete each function. We have also provided `// HINT` comments with specific guidance.

### Program Walkthrough

Let&apos;s walk through complete example of the two-sample analysis program. First, we&apos;ll compile and run the program at the command line.

```console
$ make two_sample.exe
$ ./two_sample.exe
```

Next, let&apos;s walk through the program and its output, step-by-step.

&lt;div class=&quot;primer-spec-callout info&quot; markdown=&quot;1&quot;&gt;
**Pro-tip:** Note the spacing and formatting of the output in the example below. Your program should match this format exactly.
&lt;/div&gt;

The program starts in `main()`. Since no command-line arguments are provided, the program defaults to using `cats.csv` for the filename, `food` for the filter column, `1`/`2` for the A/B criteria, and `weight` for the data column. These are passed into the `two_sample_analysis()` function.

The `two_sample_analysis()` function calls `extract_columns()` to read from the input file, which prints an informational message.

```console
reading column food from cats.csv
reading column weight from cats.csv
```
{: data-variant=&quot;no-line-numbers&quot; }

It then filters into groups A and B. It prints a header for group A, calls your `print_descriptive_stats()` function on group A, and prints an extra blank line. Then it does the same for group B.

```console
Group A: weight | food = 1
count = 5
sum = 52.3
mean = 10.46
stdev = 0.838451
median = 10.1
min = 9.6
max = 11.5
  0th percentile = 9.6
 25th percentile = 9.9
 50th percentile = 10.1
 75th percentile = 11.2
100th percentile = 11.5

Group B: weight | food = 2
count = 5
sum = 50.3
mean = 10.06
stdev = 1.70088
median = 10.1
min = 7.8
max = 12.3
  0th percentile = 7.8
 25th percentile = 9.2
 50th percentile = 10.1
 75th percentile = 10.9
100th percentile = 12.3

```
{: data-variant=&quot;no-line-numbers&quot; }

It then computes a 95% confidence interval for the difference in means between groups A and B by calling your `mean_diff_sampling_distribution()` and `confidence_interval()` functions. Then it prints a header and the confidence interval.

```console
Confidence interval for mean(weight | A) - mean(weight | B):
  95% [-0.28, 1.2005]
```
{: data-variant=&quot;no-line-numbers&quot; }

### Testing

Ensure you&apos;ve saved all files and compiled your most recent code.

```console
$ make two_sample.exe
```

Run the program (which defaults to using the `cats.csv` sample data set) and save the output to a file with [output redirection](https://eecs280staff.github.io/tutorials/cli.html#output-redirection-).
```console
$ ./two_sample.exe &gt; cats.out
```
{: data-variant=&quot;no-line-numbers&quot; }

Compare saved output (`cats.out`) with the instructor-provided correct output (`cats.out.correct`). If the `diff` command finishes with no output, that means the files are identical.
```console
$ diff cats.out cats.out.correct
```
{: data-variant=&quot;no-line-numbers&quot; }

You may also open `cats.out` in your editor for manual inspection or use the [`cat`](https://eecs280staff.github.io/tutorials/cli.html#cat) command to print it at the terminal. (Note that it&apos;s simply a coincidence the command is also called `cat`.)

You can also use the `Makefile` to [run all tests](#testing-2).
```console
$ make test
```

### Debugging

Use your IDE&apos;s visual debugger to track down issues in your implementation of `two_sample.cpp`.

For example, if your printed descriptive statistics don&apos;t match, you might set a breakpoint shortly before the first mismatched line. Or, if the confidence interval is computed incorrectly, you can strategically set a breakpoint in-between various steps of the algorithm to check at which point something goes wrong.

Here&apos;s a reminder of how to configure the debugger to launch the two-sample analysis program:

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (macOS)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  First, compile from the terminal using `make two_sample.exe`.

  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/two_sample.exe`

  Click the run button in the debugging tab of the left side panel.
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;VS Code (Windows)&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  First, compile from the terminal using `make two_sample.exe`.

  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: &lt;br&gt;
  `${workspaceFolder}/two_sample.exe`

  Click the run button in the debugging tab of the left side panel.
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;XCode&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): &lt;br&gt;
  `two_sample.cpp`, `stats.cpp`, `library.cpp`

  Click the run button.
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;
  &lt;b&gt;Visual Studio&lt;/b&gt;
  &lt;/td&gt;
  &lt;td markdown=&quot;1&quot;&gt;
  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: &lt;br&gt;
  - Include `two_sample.cpp`
  - Exclude `stats_public_tests.cpp`, `stats_tests.cpp`, `main.cpp` (if present)

  Click the run button.
  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

If you choose to run the program with custom command-line arguments, you&apos;ll need to configure them in your visual debugger ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)). For example, for the HCMST example in the project introduction, you would use the following arguments: `HCMST_ver_3.04.tsv q24_met_online 1 0 ppage`.

## Submission and Grading

Submit `stats.cpp`, `stats_tests.cpp`, and `two_sample.cpp` to the autograder using this direct autograder link: [https://autograder.io/web/project/3033](https://autograder.io/web/project/3033).

We will grade your code on functional correctness and the presence of test cases.

### Testing
Run all the public tests locally, including the public stats tests, your stats unit tests, and the two-sample analysis on the cats data set.

```console
$ make test
```

### Requirements and Restrictions

Use only the provided `bootstrap_resample()` function declared in `library.hpp` to perform resampling with replacement and ensure you pass in the current 0-indexed iteration number - this is necessary to ensure consistent pseudorandom number generation for autograding purposes.


## Acknowledgments
The original project was written by Andrew DeOrio, Spring 2015. It was revised in Fall 2024 by James Juett and Amir Kamil.

This project is based on research work by Rosenfeld, Michael J., Reuben J. Thomas, and Maja Falcon. 2015. How Couples Meet and Stay Together, Waves 1, 2, and 3: Public version 3.04, plus wave 4 supplement version 1.02 and wave 5 supplement version 1.0 [Computer files]. Stanford, CA: Stanford University Libraries.

This document is licensed under a [Creative Commons Attribution-NonCommercial 4.0 License](https://creativecommons.org/licenses/by-nc/4.0/). You&apos;re free to copy and share this document, but not to sell it. You may not share source code provided with this document.
</data>
      <data key="v_name">chunk-b49f13e04395d1d33b9ff49fe35c9778</data>
      <data key="v_id">n116</data>
    </node>
    <node id="n117">
      <data key="v_hash_id">entity-7a0b0e80e11f353ae325b56d1f61d2ed</data>
      <data key="v_content">2014 12 21</data>
      <data key="v_name">entity-7a0b0e80e11f353ae325b56d1f61d2ed</data>
      <data key="v_id">None</data>
    </node>
    <node id="n118">
      <data key="v_hash_id">entity-1ff1de774005f8da13f42943881c655f</data>
      <data key="v_content">24</data>
      <data key="v_name">entity-1ff1de774005f8da13f42943881c655f</data>
      <data key="v_id">None</data>
    </node>
    <node id="n119">
      <data key="v_hash_id">entity-e4da3b7fbbce2345d7772b0674a318d5</data>
      <data key="v_content">5</data>
      <data key="v_name">entity-e4da3b7fbbce2345d7772b0674a318d5</data>
      <data key="v_id">None</data>
    </node>
    <node id="n120">
      <data key="v_hash_id">entity-39acc79ec6bbea05785935f78694cbf7</data>
      <data key="v_content">add and discard</data>
      <data key="v_name">entity-39acc79ec6bbea05785935f78694cbf7</data>
      <data key="v_id">None</data>
    </node>
    <node id="n121">
      <data key="v_hash_id">entity-2b1a4376899f34470d55f0188a1299e1</data>
      <data key="v_content">add card</data>
      <data key="v_name">entity-2b1a4376899f34470d55f0188a1299e1</data>
      <data key="v_id">None</data>
    </node>
    <node id="n122">
      <data key="v_hash_id">entity-94aa35cad37ce1331aca36e62bace79a</data>
      <data key="v_content">andrew deorio</data>
      <data key="v_name">entity-94aa35cad37ce1331aca36e62bace79a</data>
      <data key="v_id">None</data>
    </node>
    <node id="n123">
      <data key="v_hash_id">entity-65ce540dcd07a28ad3c458a51d1cf43f</data>
      <data key="v_content">awdeorio umich edu</data>
      <data key="v_name">entity-65ce540dcd07a28ad3c458a51d1cf43f</data>
      <data key="v_id">None</data>
    </node>
    <node id="n124">
      <data key="v_hash_id">entity-c506ff134babdd6e68ab3e6350e95305</data>
      <data key="v_content">bool</data>
      <data key="v_name">entity-c506ff134babdd6e68ab3e6350e95305</data>
      <data key="v_id">None</data>
    </node>
    <node id="n125">
      <data key="v_hash_id">entity-1a78f5ca98f29692a8d507230ec483b1</data>
      <data key="v_content">deal</data>
      <data key="v_name">entity-1a78f5ca98f29692a8d507230ec483b1</data>
      <data key="v_id">None</data>
    </node>
    <node id="n126">
      <data key="v_hash_id">entity-c8d46d341bea4fd5bff866a65ff8aea9</data>
      <data key="v_content">game</data>
      <data key="v_name">entity-c8d46d341bea4fd5bff866a65ff8aea9</data>
      <data key="v_id">None</data>
    </node>
    <node id="n127">
      <data key="v_hash_id">entity-39f4d41531680f49906ca3b6413bd76c</data>
      <data key="v_content">get name</data>
      <data key="v_name">entity-39f4d41531680f49906ca3b6413bd76c</data>
      <data key="v_id">None</data>
    </node>
    <node id="n128">
      <data key="v_hash_id">entity-e8b934f17e411f9580154c2f79b58c44</data>
      <data key="v_content">humanplayer</data>
      <data key="v_name">entity-e8b934f17e411f9580154c2f79b58c44</data>
      <data key="v_id">None</data>
    </node>
    <node id="n129">
      <data key="v_hash_id">entity-2b608943ef7e59271a84a9c4d495bcff</data>
      <data key="v_content">lead card</data>
      <data key="v_name">entity-2b608943ef7e59271a84a9c4d495bcff</data>
      <data key="v_id">None</data>
    </node>
    <node id="n130">
      <data key="v_hash_id">entity-abbfbc8f4949901fe6228be798d7c7db</data>
      <data key="v_content">less than max hand size cards</data>
      <data key="v_name">entity-abbfbc8f4949901fe6228be798d7c7db</data>
      <data key="v_id">None</data>
    </node>
    <node id="n131">
      <data key="v_hash_id">entity-32593ef00b6ed40963198b262c452090</data>
      <data key="v_content">make trump</data>
      <data key="v_name">entity-32593ef00b6ed40963198b262c452090</data>
      <data key="v_id">None</data>
    </node>
    <node id="n132">
      <data key="v_hash_id">entity-672de85f03d3a4595c46029b2c3624d0</data>
      <data key="v_content">max hand size</data>
      <data key="v_name">entity-672de85f03d3a4595c46029b2c3624d0</data>
      <data key="v_id">None</data>
    </node>
    <node id="n133">
      <data key="v_hash_id">entity-6fc32be8f2e05e347545806f8f08087e</data>
      <data key="v_content">pack size</data>
      <data key="v_name">entity-6fc32be8f2e05e347545806f8f08087e</data>
      <data key="v_id">None</data>
    </node>
    <node id="n134">
      <data key="v_hash_id">entity-aa398ae3f410205bffa17821f6279229</data>
      <data key="v_content">play card</data>
      <data key="v_name">entity-aa398ae3f410205bffa17821f6279229</data>
      <data key="v_id">None</data>
    </node>
    <node id="n135">
      <data key="v_hash_id">entity-14cdbe06e02c6515ba49cd21939c5996</data>
      <data key="v_content">play hand</data>
      <data key="v_name">entity-14cdbe06e02c6515ba49cd21939c5996</data>
      <data key="v_id">None</data>
    </node>
    <node id="n136">
      <data key="v_hash_id">entity-25669f202c06ffb83fa7c0ca1dd6e335</data>
      <data key="v_content">player factory</data>
      <data key="v_name">entity-25669f202c06ffb83fa7c0ca1dd6e335</data>
      <data key="v_id">None</data>
    </node>
    <node id="n137">
      <data key="v_hash_id">entity-a2bbabfe7b1dd886a0c32b57bd8a94f9</data>
      <data key="v_content">players</data>
      <data key="v_name">entity-a2bbabfe7b1dd886a0c32b57bd8a94f9</data>
      <data key="v_id">None</data>
    </node>
    <node id="n138">
      <data key="v_hash_id">entity-65dc5d2a03aac87b199cba2986986d05</data>
      <data key="v_content">rank</data>
      <data key="v_name">entity-65dc5d2a03aac87b199cba2986986d05</data>
      <data key="v_id">None</data>
    </node>
    <node id="n139">
      <data key="v_hash_id">entity-644c45fc2b003bf415a3fb655412508d</data>
      <data key="v_content">shuffle</data>
      <data key="v_name">entity-644c45fc2b003bf415a3fb655412508d</data>
      <data key="v_id">None</data>
    </node>
    <node id="n140">
      <data key="v_hash_id">entity-8dbdda48fb8748d6746f1965824e966a</data>
      <data key="v_content">simple</data>
      <data key="v_name">entity-8dbdda48fb8748d6746f1965824e966a</data>
      <data key="v_id">None</data>
    </node>
    <node id="n141">
      <data key="v_hash_id">entity-5739ae1cdbd6d607fbb928e9dcf1167c</data>
      <data key="v_content">simpleplayer</data>
      <data key="v_name">entity-5739ae1cdbd6d607fbb928e9dcf1167c</data>
      <data key="v_id">None</data>
    </node>
    <node id="n142">
      <data key="v_hash_id">entity-5c3ba4a6b4c7dbe9803f7d8f0e6e49a7</data>
      <data key="v_content">std  istream</data>
      <data key="v_name">entity-5c3ba4a6b4c7dbe9803f7d8f0e6e49a7</data>
      <data key="v_id">None</data>
    </node>
    <node id="n143">
      <data key="v_hash_id">entity-01a7d2375dd54511eee969950bdcb267</data>
      <data key="v_content">std  vector</data>
      <data key="v_name">entity-01a7d2375dd54511eee969950bdcb267</data>
      <data key="v_id">None</data>
    </node>
    <node id="n144">
      <data key="v_hash_id">entity-9cf5af279482cc1b8cffc17b00ee1186</data>
      <data key="v_content">suit</data>
      <data key="v_name">entity-9cf5af279482cc1b8cffc17b00ee1186</data>
      <data key="v_id">None</data>
    </node>
    <node id="n145">
      <data key="v_hash_id">entity-b326b5062b2f0e69046810717534cb09</data>
      <data key="v_content">true</data>
      <data key="v_name">entity-b326b5062b2f0e69046810717534cb09</data>
      <data key="v_id">None</data>
    </node>
    <node id="n146">
      <data key="v_hash_id">chunk-440f590c41049beebc81c813ab95b98d</data>
      <data key="v_content">===== FILE: Card.hpp =====
#ifndef CARD_HPP
#define CARD_HPP
/* Card.hpp
 *
 * Represents a single playing card
 *
 * by Andrew DeOrio
 * awdeorio@umich.edu
 * 2014-12-21
 */

#include &lt;iostream&gt;

// Represent a Card&apos;s Rank.
// Rank is a type that can represent the specific values
// listed in the definition below, but no others. (In memory
// the Rank values are represented as integers from 0 to 12.)
// Use the values as constants, for example:
//   Rank r1 = FOUR;
//   Rank r2 = NINE;
// Ranks may be compared (this compares the underlying int values):
//   if (r1 &lt; r2) { // this condition is true
// Overloaded &lt;&lt; and &gt;&gt; operators are also defined farther below to
// enable stream input/output for Rank objects:
//   cout &lt;&lt; r1 &lt;&lt; endl; // prints &quot;Four&quot;
//   cin &gt;&gt; r2 &lt;&lt; endl;  // reads a string from cin and updates r2
// Because the underlying representation of the enum is an integer,
// objects of type Rank are ok to pass/return by value.
enum Rank {
  TWO     = 0,
  THREE   = 1,
  FOUR    = 2,
  FIVE    = 3,
  SIX     = 4,
  SEVEN   = 5,
  EIGHT   = 6,
  NINE    = 7,
  TEN     = 8,
  JACK    = 9,
  QUEEN   = 10,
  KING    = 11,
  ACE     = 12,
};

//REQUIRES str represents a valid rank (&quot;Two&quot;, &quot;Three&quot;, ..., &quot;Ace&quot;)
//EFFECTS returns the Rank corresponding to str, for example &quot;Two&quot; -&gt; TWO
Rank string_to_rank(const std::string &amp;str);

//EFFECTS Prints Rank to stream, for example &quot;Two&quot;
std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, Rank rank);

//REQUIRES If any input is read, it must be a valid rank
//EFFECTS Reads a Rank from a stream, for example &quot;Two&quot; -&gt; TWO
std::istream &amp; operator&gt;&gt;(std::istream &amp;is, Rank &amp;rank);

// Represent a Card&apos;s suit
enum Suit {
  SPADES   = 0,
  HEARTS   = 1,
  CLUBS    = 2,
  DIAMONDS = 3,
};

//REQUIRES str represents a valid suit (&quot;Spades&quot;, &quot;Hearts&quot;, &quot;Clubs&quot;, or &quot;Diamonds&quot;)
//EFFECTS returns the Suit corresponding to str, for example &quot;Clubs&quot; -&gt; CLUBS
Suit string_to_suit(const std::string &amp;str);

//EFFECTS Prints Suit to stream, for example &quot;Spades&quot;
std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, Suit suit);

//REQUIRES If any input is read, it must be a valid suit
//EFFECTS Reads a Suit from a stream, for example &quot;Spades&quot; -&gt; SPADES
std::istream &amp; operator&gt;&gt;(std::istream &amp;is, Suit &amp;suit);


class Card {
public:

  //EFFECTS Initializes Card to the Two of Spades
  Card();

  //EFFECTS Initializes Card to specified rank and suit
  Card(Rank rank_in, Suit suit_in);

  //EFFECTS Returns the rank
  Rank get_rank() const;

  //EFFECTS Returns the suit.  Does not consider trump.
  Suit get_suit() const;

  //EFFECTS Returns the suit
  //HINT: the left bower is the trump suit!
  Suit get_suit(Suit trump) const;

  //EFFECTS Returns true if card is a face card (Jack, Queen, King or Ace)
  bool is_face_or_ace() const;

  //EFFECTS Returns true if card is the Jack of the trump suit
  bool is_right_bower(Suit trump) const;

  //EFFECTS Returns true if card is the Jack of the next suit
  bool is_left_bower(Suit trump) const;

  //EFFECTS Returns true if the card is a trump card.  All cards of the trump
  // suit are trump cards.  The left bower is also a trump card.
  bool is_trump(Suit trump) const;

private:
  Rank rank;
  Suit suit;

  // This &quot;friend declaration&quot; allows the implementation of operator&gt;&gt;
  // to access private member variables of the Card class.
  friend std::istream &amp; operator&gt;&gt;(std::istream &amp;is, Card &amp;card);
};

//EFFECTS Prints Card to stream, for example &quot;Two of Spades&quot;
std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, const Card &amp;card);

//EFFECTS Reads a Card from a stream in the format &quot;Two of Spades&quot;
//NOTE The Card class declares this operator&gt;&gt; &quot;friend&quot; function,
//     which means it is allowed to access card.rank and card.suit.
std::istream &amp; operator&gt;&gt;(std::istream &amp;is, Card &amp;card);

//EFFECTS Returns true if lhs is lower value than rhs.
//  Does not consider trump.
bool operator&lt;(const Card &amp;lhs, const Card &amp;rhs);

//EFFECTS Returns true if lhs is lower value than rhs or the same card as rhs.
//  Does not consider trump.
bool operator&lt;=(const Card &amp;lhs, const Card &amp;rhs);

//EFFECTS Returns true if lhs is higher value than rhs.
//  Does not consider trump.
bool operator&gt;(const Card &amp;lhs, const Card &amp;rhs);

//EFFECTS Returns true if lhs is higher value than rhs or the same card as rhs.
//  Does not consider trump.
bool operator&gt;=(const Card &amp;lhs, const Card &amp;rhs);

//EFFECTS Returns true if lhs is same card as rhs.
//  Does not consider trump.
bool operator==(const Card &amp;lhs, const Card &amp;rhs);

//EFFECTS Returns true if lhs is not the same card as rhs.
//  Does not consider trump.
bool operator!=(const Card &amp;lhs, const Card &amp;rhs);

//EFFECTS returns the next suit, which is the suit of the same color
Suit Suit_next(Suit suit);

//EFFECTS Returns true if a is lower value than b.  Uses trump to determine
// order, as described in the spec.
bool Card_less(const Card &amp;a, const Card &amp;b, Suit trump);

//EFFECTS Returns true if a is lower value than b.  Uses both the trump suit
//  and the suit led to determine order, as described in the spec.
bool Card_less(const Card &amp;a, const Card &amp;b, const Card &amp;led_card, Suit trump);

#endif // CARD_HPP
</data>
      <data key="v_name">chunk-440f590c41049beebc81c813ab95b98d</data>
      <data key="v_id">None</data>
    </node>
    <node id="n147">
      <data key="v_hash_id">chunk-cbb8e23873fbc6002fc735dce5b6fc73</data>
      <data key="v_content">===== FILE: Player.cpp =====
#include &quot;Player.hpp&quot;

class SimplePlayer : public Player {
    public:
     //EFFECTS: Creates a SimplePlayer with the given name
     SimplePlayer(const std::string &amp;name);
   
     //EFFECTS: Returns player&apos;s name
     const std::string &amp; get_name() const;
   
     //REQUIRES player has less than MAX_HAND_SIZE cards
     //EFFECTS  adds Card c to Player&apos;s hand
     void add_card(const Card &amp;c);
   
     //REQUIRES round is 1 or 2
     //EFFECTS If Player wishes to order up a trump suit then return true and
     //  change order_up_suit to desired suit.  If Player wishes to pass, then do
     //  not modify order_up_suit and return false.
     // In making trump, a Simple Player considers the upcard, which player dealt, and whether it is the first or second round of making trump. A more comprehensive strategy would consider the other players’ responses, but we will keep it simple.
     // During round one, a Simple Player considers ordering up the suit of the upcard, which would make that suit trump. They will order up if that would mean they have two or more cards that are either face or ace cards of the trump suit (the right and left bowers, and Q, K, A of the trump suit, which is the suit proposed by the upcard). (A Simple Player does not consider whether they are the dealer and could gain an additional trump by picking up the upcard.)
     // During round two, a Simple Player considers ordering up the suit with the same color as the upcard, which would make that suit trump. They will order up if that would mean they have one or more cards that are either face or ace cards of the trump suit in their hand (the right and left bowers, and Q, K, A of the order-up suit). For example, if the upcard is a Heart and the player has the King of Diamonds in their hand, they will order up Diamonds. The Simple Player will not order up any other suit. If making reaches the dealer during the second round, we invoke screw the dealer, where the dealer is forced to order up. In the case of screw the dealer, the dealer will always order up the suit with the same color as the upcard.
     bool make_trump(const Card &amp;upcard, bool is_dealer,
                     int round, Suit &amp;order_up_suit) const;
   
     //REQUIRES Player has at least one card
     //EFFECTS  If the trump suit is ordered up during round one, the dealer picks up the upcard. The dealer then discards the lowest card in their hand, even if this is the upcard, for a final total of five cards. (Note that at this point, the trump suit is the suit of the upcard.)
     void add_and_discard(const Card &amp;upcard);
   
     //REQUIRES Player has at least one card
     //EFFECTS  Leads one Card from Player&apos;s hand according to their strategy
     //  &quot;Lead&quot; means to play the first Card in a trick.  The card
     //  is removed the player&apos;s hand.
     //  When a Simple Player leads a trick, they play the highest non-trump card in their hand. If they have only trump cards, they play the highest trump card in their hand.
     Card lead_card(Suit trump);
   
     //REQUIRES Player has at least one card
     //EFFECTS  Plays one Card from Player&apos;s hand according to their strategy.
     //  The card is removed from the player&apos;s hand.
     //  When playing a card, Simple Players use a simple strategy that considers only the suit that was led. A more complex strategy would also consider the cards on the table.
     //  If a Simple Player can follow suit, they play the highest card that follows suit. Otherwise, they play the lowest card in their hand.
     Card play_card(const Card &amp;led_card, Suit trump);
   
    private:
     std::string name;
     std::vector&lt;Card&gt; hand;
   };

// The Human Player reads input from the human user. You may assume all user input is correctly formatted and has correct values. You may also assume the user will follow the rules of the game and not try to cheat.
class HumanPlayer: public Player {
    public:
    //EFFECTS: Creates a SimplePlayer with the given name
    HumanPlayer(const std::string &amp;name);
  
    //EFFECTS: Returns player&apos;s name
    const std::string &amp; get_name() const;
  
    //REQUIRES player has less than MAX_HAND_SIZE cards
    //EFFECTS  adds Card c to Player&apos;s hand
    void add_card(const Card &amp;c);
  
    //REQUIRES round is 1 or 2
    //EFFECTS  If Player wishes to order up a trump suit then return true and
  //  change order_up_suit to desired suit.  If Player wishes to pass, then do
  //  not modify order_up_suit and return false.
  //  When making trump reaches a Human Player, first print the Player’s hand. Then, prompt the user for their decision to pass or order up. The user will then enter one of the following: “Spades”, “Hearts”, “Clubs”, “Diamonds”, or “pass” to either order up the specified suit or pass. This procedure is the same for both rounds of making trump.
    bool make_trump(const Card &amp;upcard, bool is_dealer,
                    int round, Suit &amp;order_up_suit) const;
  
    //REQUIRES Player has at least one card
    //EFFECTS  Player adds one card to hand and removes one card from hand.
    //  If a Human Player is the dealer and someone orders up during the first round of making, the Human Player will pick up the upcard and discard a card of their choice. Print the Player’s hand and an option to discard the upcard. Then, prompt the user to select a card to discard. The user will then enter the number corresponding to the card they want to discard (or -1 if they want to discard the upcard).
    void add_and_discard(const Card &amp;upcard);
  
    //REQUIRES Player has at least one card
    //EFFECTS  Leads one Card from Player&apos;s hand according to their strategy
    //  &quot;Lead&quot; means to play the first Card in a trick.  The card
    //  is removed the player&apos;s hand.
    //  When it is the Human Player’s turn to lead or play a trick, first print the Player’s hand. Then, prompt the user to select a card. The user will then enter the number corresponding to the card they want to play.
    Card lead_card(Suit trump);
  
    //REQUIRES Player has at least one card
    //EFFECTS  Plays one Card from Player&apos;s hand according to their strategy.
    //  The card is removed from the player&apos;s hand.
    //   When it is the Human Player’s turn to lead or play a trick, first print the Player’s hand. Then, prompt the user to select a card. The user will then enter the number corresponding to the card they want to play.
    Card play_card(const Card &amp;led_card, Suit trump);
  
   private:
    std::string name;
    std::vector&lt;Card&gt; hand;
   };</data>
      <data key="v_name">chunk-cbb8e23873fbc6002fc735dce5b6fc73</data>
      <data key="v_id">None</data>
    </node>
    <node id="n148">
      <data key="v_hash_id">chunk-d3068af8a41db5b5e2a28cc5c3429139</data>
      <data key="v_content">===== FILE: Pack.hpp =====
#ifndef PACK_HPP
#define PACK_HPP
/* Pack.hpp
 *
 * Represents a pack of playing cards
 *
 * by Andrew DeOrio &lt;awdeorio@umich.edu&gt;
 * 2014-12-21
 */


#include &quot;Card.hpp&quot;
#include &lt;array&gt;
#include &lt;string&gt;

class Pack {
public:
  // EFFECTS: Initializes the Pack to be in the following standard order:
  //          the cards of the lowest suit arranged from lowest rank to
  //          highest rank, followed by the cards of the next lowest suit
  //          in order from lowest to highest rank, and so on. 
  // NOTE: The standard order is the same as that in pack.in.
  // NOTE: Do NOT use pack.in in your implementation of this function
  // NOTE: The pack is initially full, with no cards dealt.
  Pack();

  // REQUIRES: pack_input contains a representation of a Pack in the
  //           format required by the project specification
  // MODIFIES: pack_input
  // EFFECTS: Initializes Pack by reading from pack_input.
  // NOTE: The pack is initially full, with no cards dealt.
  Pack(std::istream&amp; pack_input);

  // REQUIRES: cards remain in the Pack
  // EFFECTS: Returns the next card in the pack and increments the next index
  Card deal_one();

  // EFFECTS: Resets next index to first card in the Pack
  void reset();

  // EFFECTS: Shuffles the Pack and resets the next index. This
  //          performs an in shuffle seven times. See
  //          https://en.wikipedia.org/wiki/In_shuffle.
  void shuffle();

  // EFFECTS: returns true if there are no more cards left in the pack
  bool empty() const;

private:
  static const int PACK_SIZE = 24;
  std::array&lt;Card, PACK_SIZE&gt; cards;
  int next; //index of next card to be dealt
};

#endif // PACK_HPP
</data>
      <data key="v_name">chunk-d3068af8a41db5b5e2a28cc5c3429139</data>
      <data key="v_id">None</data>
    </node>
    <node id="n149">
      <data key="v_hash_id">chunk-3ab74c8ca013475310dc1899eeff8acb</data>
      <data key="v_content">===== FILE: euchre.cpp =====
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &quot;Card.hpp&quot;
#include &quot;Pack.hpp&quot;
#include &quot;Player.hpp&quot;
#include &lt;cstring&gt;

class Game {
    public:
     Game(/* ... */);
     void play();
   
    private:
     std::vector&lt;Player*&gt; players;
     Pack pack;
     // ...
   
     void shuffle();
     void deal(/* ... */);
     void make_trump(/* ... */);
     void play_hand(/* ... */);
     // ...
   };
   </data>
      <data key="v_name">chunk-3ab74c8ca013475310dc1899eeff8acb</data>
      <data key="v_id">None</data>
    </node>
    <node id="n150">
      <data key="v_hash_id">chunk-fc09063192413e935e726618a4f593d2</data>
      <data key="v_content">===== FILE: Card.cpp =====
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;array&gt;
#include &quot;Card.hpp&quot;

using namespace std;

/////////////// Rank operator implementations - DO NOT CHANGE ///////////////

constexpr const char *const RANK_NAMES[] = {
  &quot;Two&quot;,   // TWO
  &quot;Three&quot;, // THREE
  &quot;Four&quot;,  // FOUR
  &quot;Five&quot;,  // FIVE
  &quot;Six&quot;,   // SIX
  &quot;Seven&quot;, // SEVEN
  &quot;Eight&quot;, // EIGHT
  &quot;Nine&quot;,  // NINE
  &quot;Ten&quot;,   // TEN
  &quot;Jack&quot;,  // JACK
  &quot;Queen&quot;, // QUEEN
  &quot;King&quot;,  // KING
  &quot;Ace&quot;    // ACE
};

//REQUIRES str represents a valid rank (&quot;Two&quot;, &quot;Three&quot;, ..., &quot;Ace&quot;)
//EFFECTS returns the Rank corresponding to str, for example &quot;Two&quot; -&gt; TWO
Rank string_to_rank(const std::string &amp;str) {
  for(int r = TWO; r &lt;= ACE; ++r) {
    if (str == RANK_NAMES[r]) {
      return static_cast&lt;Rank&gt;(r);
    }
  }
  assert(false); // Input string didn&apos;t match any rank
  return {};
}

//EFFECTS Prints Rank to stream, for example &quot;Two&quot;
std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, Rank rank) {
  os &lt;&lt; RANK_NAMES[rank];
  return os;
}

//REQUIRES If any input is read, it must be a valid rank
//EFFECTS Reads a Rank from a stream, for example &quot;Two&quot; -&gt; TWO
std::istream &amp; operator&gt;&gt;(std::istream &amp;is, Rank &amp;rank) {
  string str;
  if(is &gt;&gt; str) {
    rank = string_to_rank(str);
  }
  return is;
}



/////////////// Suit operator implementations - DO NOT CHANGE ///////////////

constexpr const char *const SUIT_NAMES[] = {
  &quot;Spades&quot;,   // SPADES
  &quot;Hearts&quot;,   // HEARTS
  &quot;Clubs&quot;,    // CLUBS
  &quot;Diamonds&quot;, // DIAMONDS
};

//REQUIRES str represents a valid suit (&quot;Spades&quot;, &quot;Hearts&quot;, &quot;Clubs&quot;, or &quot;Diamonds&quot;)
//EFFECTS returns the Suit corresponding to str, for example &quot;Clubs&quot; -&gt; CLUBS
Suit string_to_suit(const std::string &amp;str) {
  for(int s = SPADES; s &lt;= DIAMONDS; ++s) {
    if (str == SUIT_NAMES[s]) {
      return static_cast&lt;Suit&gt;(s);
    }
  }
  assert(false); // Input string didn&apos;t match any suit
  return {};
}

//EFFECTS Prints Suit to stream, for example &quot;Spades&quot;
std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, Suit suit) {
  os &lt;&lt; SUIT_NAMES[suit];
  return os;
}

//REQUIRES If any input is read, it must be a valid suit
//EFFECTS Reads a Suit from a stream, for example &quot;Spades&quot; -&gt; SPADES
std::istream &amp; operator&gt;&gt;(std::istream &amp;is, Suit &amp;suit) {
  string str;
  if (is &gt;&gt; str) {
    suit = string_to_suit(str);
  }
  return is;
}


/////////////// Write your implementation for Card below ///////////////


// NOTE: We HIGHLY recommend you check out the operator overloading
// tutorial in the project spec before implementing
// the following operator overload functions:
//   operator&lt;&lt;
//   operator&gt;&gt;
//   operator&lt;
//   operator&lt;=
//   operator&gt;
//   operator&gt;=
//   operator==
//   operator!=
</data>
      <data key="v_name">chunk-fc09063192413e935e726618a4f593d2</data>
      <data key="v_id">None</data>
    </node>
    <node id="n151">
      <data key="v_hash_id">chunk-d37817a59bc77fa061992192db4501f8</data>
      <data key="v_content">===== FILE: Player.hpp =====
#ifndef PLAYER_HPP
#define PLAYER_HPP
/* Player.hpp
 *
 * Euchre player interface
 *
 * by Andrew DeOrio
 * awdeorio@umich.edu
 * 2014-12-21
 */


#include &quot;Card.hpp&quot;
#include &lt;string&gt;
#include &lt;vector&gt;

class Player {
 public:
  //EFFECTS returns player&apos;s name
  virtual const std::string &amp; get_name() const = 0;

  //REQUIRES player has less than MAX_HAND_SIZE cards
  //EFFECTS  adds Card c to Player&apos;s hand
  virtual void add_card(const Card &amp;c) = 0;

  //REQUIRES round is 1 or 2
  //MODIFIES order_up_suit
  //EFFECTS If Player wishes to order up a trump suit then return true and
  //  change order_up_suit to desired suit.  If Player wishes to pass, then do
  //  not modify order_up_suit and return false.
  virtual bool make_trump(const Card &amp;upcard, bool is_dealer,
                          int round, Suit &amp;order_up_suit) const = 0;

  //REQUIRES Player has at least one card
  //EFFECTS  Player adds one card to hand and removes one card from hand.
  virtual void add_and_discard(const Card &amp;upcard) = 0;

  //REQUIRES Player has at least one card
  //EFFECTS  Leads one Card from Player&apos;s hand according to their strategy
  //  &quot;Lead&quot; means to play the first Card in a trick.  The card
  //  is removed the player&apos;s hand.
  virtual Card lead_card(Suit trump) = 0;

  //REQUIRES Player has at least one card
  //EFFECTS  Plays one Card from Player&apos;s hand according to their strategy.
  //  The card is removed from the player&apos;s hand.
  virtual Card play_card(const Card &amp;led_card, Suit trump) = 0;

  // Maximum number of cards in a player&apos;s hand
  static const int MAX_HAND_SIZE = 5;

  // Needed to avoid some compiler errors
  // NOTE: Do NOT write a destructor in the Player subclasses. The compiler-generated ones will work fine.
  virtual ~Player() {}
};

//EFFECTS: Returns a pointer to a player with the given name and strategy
//To create an object that won&apos;t go out of scope when the function returns,
//use &quot;return new Simple(name)&quot; or &quot;return new Human(name)&quot;
//Don&apos;t forget to call &quot;delete&quot; on each Player* after the game is over
Player * Player_factory(const std::string &amp;name, const std::string &amp;strategy);

//EFFECTS: Prints player&apos;s name to os
std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, const Player &amp;p);
#endif // PLAYER_HPP
</data>
      <data key="v_name">chunk-d37817a59bc77fa061992192db4501f8</data>
      <data key="v_id">None</data>
    </node>
    <edge source="n25" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n31" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n31" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n108">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n108">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n58">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n58">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n76">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n76">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n45">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n45">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n44" target="n50">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n44" target="n50">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n44" target="n51">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n44" target="n51">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n22" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n22" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n17" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n17" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n39" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n39" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n108">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n25" target="n108">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n57" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n57" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n70">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n70">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n92">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n92">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n89">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n89">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n107">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n107">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n82">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n82">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n105">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n105">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n106">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n106">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n18" target="n80">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n18" target="n80">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n38" target="n54">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n38" target="n54">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n61">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n61">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n16">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n16">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n35" target="n100">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n35" target="n100">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n59" target="n98">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n59" target="n98">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n30">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n25" target="n30">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n21" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n21" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n5" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n5" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n6" target="n85">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n6" target="n85">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n2" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n2" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n3" target="n87">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n3" target="n87">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n90" target="n95">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n90" target="n95">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n69" target="n86">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n69" target="n86">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n48" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n48" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n55" target="n99">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n55" target="n99">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n47" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n47" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n108">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n108">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n32">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n32">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n56">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n56">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n60">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n60">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n1" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n1" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n41">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n41">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n110">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n110">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n36">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n36">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n11">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n11">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n10">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n10">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n66">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n66">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n73">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n73">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n96" target="n97">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n96" target="n97">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n12">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n12">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n74">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n74">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n68">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n68">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n28">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n28">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n67">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n67">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n0" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n0" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n4" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n4" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n15" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n15" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n20" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n20" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n43">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n43">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n46">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n46">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n49">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n49">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n52">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n52">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n34">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n34">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n64" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n64" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n53" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n53" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n53" target="n84">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n53" target="n84">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n24" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n24" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n19" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n19" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n71" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n71" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n62" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n62" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n26" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n26" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n88" target="n101">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n88" target="n101">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n23" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n23" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n33" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n33" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n63" target="n102">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n63" target="n102">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n40" target="n83">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n40" target="n83">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n40">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n40">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n79">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n79">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n75">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n75">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n93">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n93">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n14">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n14">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n94">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n94">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n94">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n94">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n39" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n45" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n51" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n22" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n17" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n50" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n44" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n76" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n58" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n108" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n31" target="n111">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n61" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n35" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n82" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n106" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n80" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n98" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n54" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n59" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n107" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n89" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n57" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n78" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n38" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n100" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n108" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n18" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n92" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n70" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n105" target="n112">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n99" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n55" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n109" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n86" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n6" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n3" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n5" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n103" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n95" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n30" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n77" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n47" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n90" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n69" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n21" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n87" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n85" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n104" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n2" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n48" target="n113">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n109" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n1" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n11" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n60" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n43" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n34" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n68" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n41" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n103" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n0" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n15" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n96" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n12" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n52" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n32" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n56" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n4" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n108" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n36" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n67" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n20" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n73" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n110" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n10" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n28" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n104" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n49" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n46" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n66" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n74" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n97" target="n114">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n35" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n109" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n62" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n71" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n103" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n84" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n88" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n30" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n100" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n102" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n77" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n23" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n19" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n64" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n26" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n63" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n104" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n91" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n24" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n33" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n53" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n101" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n115">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n14" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n93" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n40" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n83" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n79" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n75" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n94" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n108" target="n116">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n21" target="n64">
      <data key="e_weight">0.921124398708344</data>
    </edge>
    <edge source="n27" target="n29">
      <data key="e_weight">0.818811535835266</data>
    </edge>
    <edge source="n27" target="n29">
      <data key="e_weight">0.818811535835266</data>
    </edge>
    <edge source="n31" target="n32">
      <data key="e_weight">0.844643712043762</data>
    </edge>
    <edge source="n32" target="n56">
      <data key="e_weight">0.84928023815155</data>
    </edge>
    <edge source="n31" target="n32">
      <data key="e_weight">0.844643771648407</data>
    </edge>
    <edge source="n32" target="n57">
      <data key="e_weight">0.801032245159149</data>
    </edge>
    <edge source="n44" target="n45">
      <data key="e_weight">0.86137467622757</data>
    </edge>
    <edge source="n44" target="n45">
      <data key="e_weight">0.86137467622757</data>
    </edge>
    <edge source="n50" target="n51">
      <data key="e_weight">0.834864556789398</data>
    </edge>
    <edge source="n50" target="n51">
      <data key="e_weight">0.834864556789398</data>
    </edge>
    <edge source="n56" target="n57">
      <data key="e_weight">0.929422736167908</data>
    </edge>
    <edge source="n32" target="n56">
      <data key="e_weight">0.849280178546906</data>
    </edge>
    <edge source="n56" target="n57">
      <data key="e_weight">0.929422736167908</data>
    </edge>
    <edge source="n32" target="n57">
      <data key="e_weight">0.801032483577728</data>
    </edge>
    <edge source="n21" target="n64">
      <data key="e_weight">0.92112410068512</data>
    </edge>
    <edge source="n65" target="n67">
      <data key="e_weight">0.893831014633179</data>
    </edge>
    <edge source="n65" target="n67">
      <data key="e_weight">0.893831014633179</data>
    </edge>
    <edge source="n82" target="n107">
      <data key="e_weight">0.851265072822571</data>
    </edge>
    <edge source="n95" target="n97">
      <data key="e_weight">0.846633553504944</data>
    </edge>
    <edge source="n95" target="n96">
      <data key="e_weight">0.823036849498749</data>
    </edge>
    <edge source="n95" target="n96">
      <data key="e_weight">0.823036849498749</data>
    </edge>
    <edge source="n95" target="n97">
      <data key="e_weight">0.846633553504944</data>
    </edge>
    <edge source="n105" target="n106">
      <data key="e_weight">0.823283195495605</data>
    </edge>
    <edge source="n105" target="n106">
      <data key="e_weight">0.823283195495605</data>
    </edge>
    <edge source="n82" target="n107">
      <data key="e_weight">0.851265072822571</data>
    </edge>
    <edge source="n25" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n31" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n31" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n108">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n108">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n58">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n58">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n76">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n76">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n45">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n42" target="n45">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n44" target="n50">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n44" target="n50">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n44" target="n51">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n44" target="n51">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n22" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n22" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n17" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n17" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n39" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n39" target="n42">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n108">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n25" target="n108">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n57" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n57" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n70">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n70">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n78">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n92">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n92">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n89">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n89">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n107">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n107">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n82">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n82">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n105">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n105">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n106">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n106">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n18" target="n80">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n18" target="n80">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n38" target="n54">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n38" target="n54">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n61">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n16" target="n61">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n16">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n16">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n35" target="n100">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n35" target="n100">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n59" target="n98">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n59" target="n98">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n30">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n25" target="n30">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n21" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n21" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n5" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n5" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n6" target="n85">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n6" target="n85">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n2" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n2" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n81" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n3" target="n87">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n3" target="n87">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n90" target="n95">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n90" target="n95">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n69" target="n86">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n69" target="n86">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n48" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n48" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n55" target="n99">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n55" target="n99">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n47" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n47" target="n55">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n25" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n108">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n108">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n32">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n32">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n56">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n56">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n60">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n60">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n7" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n1" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n1" target="n27">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n41">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n41">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n110">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n110">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n36">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n36">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n11">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n11">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n10">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n10">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n66">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n65" target="n66">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n72" target="n73">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n73">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n96" target="n97">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n96" target="n97">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n12">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n12">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n74">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n74">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n68">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n68">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n28">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n28">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n67">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n67">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n0" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n0" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n4" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n4" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n15" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n15" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n20" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n20" target="n29">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n43">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n43">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n46">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n46">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n49">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n49">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n52">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n52">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n34">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n29" target="n34">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n64" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n64" target="n77">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n53" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n53" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n53" target="n84">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n53" target="n84">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n24" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n24" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n19" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n19" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n71" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n71" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n62" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n62" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n26" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n26" target="n88">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n88" target="n101">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n88" target="n101">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n104">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n103">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n8" target="n109">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n23" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n23" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n33" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n33" target="n91">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n63" target="n102">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n63" target="n102">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n40" target="n83">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n40" target="n83">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n40">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n40">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n79">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n79">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n75">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n75">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n93">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n93">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n14">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n14">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n94">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n37" target="n94">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n94">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n13" target="n94">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n138">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n9" target="n138">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n9" target="n144">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n9" target="n144">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n9" target="n122">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n122">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n122" target="n123">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n122" target="n123">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n9" target="n117">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n117">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n128">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n128">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n127" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n127" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n127" target="n128">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n127" target="n128">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n121" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n121" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n121" target="n128">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n121" target="n128">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n131" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n131" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n131">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n131">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n120" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n120" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n120" target="n128">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n120" target="n128">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n129" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n129" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n129">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n129">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n134" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n134" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n134">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n134">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n130" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n130" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n130">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n130">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n141">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n128">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n128">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n141" target="n144">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n141" target="n144">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n144">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n144">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n122">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n122">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n117">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n117">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n65">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n9" target="n65">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n65" target="n133">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n133">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n118" target="n133">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n118" target="n133">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n142">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n142">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n145">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n65" target="n145">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n65" target="n124">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n124">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n28" target="n126">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n28" target="n126">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n126">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n126">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n126">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n65" target="n126">
      <data key="e_weight">2</data>
    </edge>
    <edge source="n72" target="n126">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n126">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n143">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n143">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n137">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n137">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n139">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n139">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n125" target="n126">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n125" target="n126">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n131">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n131">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n135">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n135">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n72">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n72">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n122">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n122">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n132">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n132">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n119" target="n132">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n119" target="n132">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n72">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n72">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n140">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n140">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n41" target="n72">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n41" target="n72">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n136">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n136">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n127">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n127">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n121">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n121">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n131">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n131">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n120">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n120">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n129">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n129">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n134">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n134">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n138" target="n146">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n144" target="n146">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n122" target="n146">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n146">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n117" target="n146">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n123" target="n146">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n144" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n141" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n128" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n120" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n127" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n130" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n129" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n121" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n134" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n131" target="n147">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n122" target="n148">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n148">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n124" target="n148">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n118" target="n148">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n66" target="n148">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n145" target="n148">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n142" target="n148">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n117" target="n148">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n133" target="n148">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n148">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n126" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n28" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n139" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n137" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n125" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n143" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n135" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n131" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n65" target="n149">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n120" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n122" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n9" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n127" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n41" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n129" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n121" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n131" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n72" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n136" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n140" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n134" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n27" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n119" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n123" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n132" target="n151">
      <data key="e_weight">1</data>
    </edge>
    <edge source="n21" target="n64">
      <data key="e_weight">0.921124398708344</data>
    </edge>
    <edge source="n27" target="n29">
      <data key="e_weight">0.818811416625977</data>
    </edge>
    <edge source="n27" target="n29">
      <data key="e_weight">0.818811416625977</data>
    </edge>
    <edge source="n31" target="n32">
      <data key="e_weight">0.844643712043762</data>
    </edge>
    <edge source="n32" target="n56">
      <data key="e_weight">0.84928023815155</data>
    </edge>
    <edge source="n31" target="n32">
      <data key="e_weight">0.844643712043762</data>
    </edge>
    <edge source="n32" target="n57">
      <data key="e_weight">0.801032245159149</data>
    </edge>
    <edge source="n44" target="n45">
      <data key="e_weight">0.86137467622757</data>
    </edge>
    <edge source="n44" target="n45">
      <data key="e_weight">0.86137467622757</data>
    </edge>
    <edge source="n50" target="n51">
      <data key="e_weight">0.834864616394043</data>
    </edge>
    <edge source="n50" target="n51">
      <data key="e_weight">0.834864616394043</data>
    </edge>
    <edge source="n56" target="n57">
      <data key="e_weight">0.929422736167908</data>
    </edge>
    <edge source="n32" target="n56">
      <data key="e_weight">0.84928023815155</data>
    </edge>
    <edge source="n56" target="n57">
      <data key="e_weight">0.929422736167908</data>
    </edge>
    <edge source="n32" target="n57">
      <data key="e_weight">0.801032245159149</data>
    </edge>
    <edge source="n21" target="n64">
      <data key="e_weight">0.921124398708344</data>
    </edge>
    <edge source="n65" target="n67">
      <data key="e_weight">0.893831133842468</data>
    </edge>
    <edge source="n65" target="n67">
      <data key="e_weight">0.893831133842468</data>
    </edge>
    <edge source="n72" target="n137">
      <data key="e_weight">0.843048512935638</data>
    </edge>
    <edge source="n82" target="n107">
      <data key="e_weight">0.851265072822571</data>
    </edge>
    <edge source="n95" target="n97">
      <data key="e_weight">0.846633613109589</data>
    </edge>
    <edge source="n95" target="n96">
      <data key="e_weight">0.823036789894104</data>
    </edge>
    <edge source="n95" target="n96">
      <data key="e_weight">0.823036789894104</data>
    </edge>
    <edge source="n95" target="n97">
      <data key="e_weight">0.846633553504944</data>
    </edge>
    <edge source="n105" target="n106">
      <data key="e_weight">0.823283195495605</data>
    </edge>
    <edge source="n105" target="n106">
      <data key="e_weight">0.823283195495605</data>
    </edge>
    <edge source="n82" target="n107">
      <data key="e_weight">0.851265072822571</data>
    </edge>
    <edge source="n130" target="n132">
      <data key="e_weight">0.800003588199615</data>
    </edge>
    <edge source="n130" target="n132">
      <data key="e_weight">0.800003588199615</data>
    </edge>
    <edge source="n72" target="n137">
      <data key="e_weight">0.843048512935638</data>
    </edge>
  </graph>
</graphml>
