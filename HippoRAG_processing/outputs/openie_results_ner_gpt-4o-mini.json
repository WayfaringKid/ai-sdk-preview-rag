{"docs": [{"idx": "chunk-56f089ad684730c76782bd5994888a3a", "passage": "---\nlayout: spec\nmermaid: true\n---\n\nEECS 280 Project 2: Image Processing\n===================================\n{: .primer-spec-toc-ignore }\n\nDue 8:00pm EST Wednesday February 12th, 2025.  You may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)).\n\nWinter 2025 release.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**IMPORTANT**\nIf you are retaking the course, please note changes this term to the underlying implementation of the `Matrix` ADT that affect several parts of the project. While we always suggest students retaking the course redo the entire project from scratch (as it is helpful practice), we nevertheless want to highlight these changes to the project.\n</div>\n\n## Introduction\nBuild an image resizing program using a seam-carving algorithm.\n\nThe learning goals of this project include Testing, Debugging, Pointers, Strings, Streams, IO, and Abstract Data Types in C.  You'll gain practice with C-style pointers and structs.\n\nWhen you're done, you'll have a program that uses seam carving for content-aware resizing of images.  The algorithm works by finding and\nremoving \"seams\" in the image that pass through the least important\npixels. For a quick introduction, check out [this video](https://www.youtube.com/watch?v=6NcIJXTlugc).\n\n<table>\n<colgroup>\n<col style=\"width: 33%\" />\n<col style=\"width: 33%\" />\n<col style=\"width: 33%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center; vertical-align: bottom;\">\n  <img src=\"images/image11.png\" style=\"width: 100%\"/><br />\n  Original Image: 479x382\n</td>\n<td style=\"text-align: center; vertical-align: bottom;\">\n  <img src=\"images/image15.png\" style=\"width: 62.6%\"/><br />\n  Resized: 300x382\n</td>\n<td style=\"text-align: center; vertical-align: bottom;\">\n  <img src=\"images/image5.png\" style=\"width: 83.5%\"/><br />\n  Resized: 400x250\n</td>\n</tr>\n</tbody>\n</table>\n\n## Setup\n\nSet up your visual debugger and version control, then submit to the autograder.\n\n### Visual debugger\nDuring setup, name your project `p2-image-processing`. Use this starter files link: `https://eecs280staff.github.io/image-processing/starter-files.tar.gz`\n\n| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html) | [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |\n\nIf you created a `main.cpp` while following the setup tutorial, rename it to `resize.cpp`. Otherwise, create a new file `resize.cpp`.  You should end up with a folder with starter files that looks like this.  You may have already renamed files like `Matrix.cpp.starter` to `Matrix.cpp`.\n```console\n$ ls\nImage.cpp.starter            dog_4x5.correct.ppm\nImage.hpp                    dog_cost_correct.txt\nImage_public_test.cpp        dog_energy_correct.txt\nImage_test_helpers.cpp       dog_left.correct.ppm\nImage_test_helpers.hpp       dog_removed.correct.ppm\nImage_tests.cpp.starter      dog_right.correct.ppm\nMakefile                     dog_seam_correct.txt\nMatrix.cpp.starter           horses.ppm\nMatrix.hpp                   horses_300x382.correct.ppm\nMatrix_public_test.cpp       horses_400x250.correct.ppm\nMatrix_test_helpers.cpp      horses_cost_correct.txt\nMatrix_test_helpers.hpp      horses_energy_correct.txt\nMatrix_tests.cpp.starter     horses_left.correct.ppm\ncrabster.ppm                 horses_removed.correct.ppm\ncrabster_50x45.correct.ppm   horses_right.correct.ppm\ncrabster_70x35.correct.ppm   horses_seam_correct.txt\ncrabster_cost_correct.txt    jpeg.hpp\ncrabster_energy_correct.txt  processing.cpp.starter\ncrabster_left.correct.ppm    processing.hpp\ncrabster_removed.correct.ppm processing_public_tests.cpp\ncrabster_right.correct.ppm   resize.cpp\ncrabster_seam_correct.txt    unit_test_framework.hpp\ndog.ppm\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each starter file.\n\nFile | Description\n------- | -----------\n`Matrix.hpp` | Interface specification for the `Matrix` module.\n`Image.hpp`  | Interface specification for the `Image` module.\n`processing.hpp` | Specification of image processing functions that are pieces of the seam carving algorithm.\n`Matrix.cpp.starter` | Starter code for the `Matrix` module.\n`Image.cpp.starter` | Starter code for the `Image` module.\n`processing.cpp.starter` | Starter code for the `processing` module.\n`Matrix_tests.cpp.starter` | Starter code for unit testing the `Matrix` module.\n`Image_tests.cpp.starter` | Starter code for unit testing the `Image` module.\n`Matrix_public_test.cpp` | Public tests for the `Matrix` module.\n`Image_public_test.cpp` | Public tests for the `Image` module.\n`processing_public_tests.cpp` | Tests for the `processing` module and seam carving algorithm.\n`Matrix_test_helpers.hpp` <br>`Matrix_test_helpers.cpp` <br>`Image_test_helpers.hpp` <br>`Image_test_helpers.cpp` | Helper functions for unit tests\n`unit_test_framework.hpp` | A simple unit-testing framework\n`jpeg.hpp` | Code for reading and writing JPEG files\n`dog.ppm`, `crabster.ppm`, `horses.ppm` | Sample input image files.\nSeveral `_correct.txt` files. <br>Several `.correct.ppm` files. | Sample (correct) output files used by the `processing_public_tests` program.\n`Makefile` | Helper commands for building and submitting\n\n### Version control\nSet up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).\n\nAfter you're done, you should have a local repository with a \"clean\" status and your local repository should be connected to a remote GitHub repository.\n```console\n$ git status\nOn branch main\nYour branch is up-to-date with 'origin/main'.\n\nnothing to commit, working tree clean\n$ git remote -v\norigin\thttps://github.com/awdeorio/p2-image-processing.git (fetch)\norigin\thttps://githubcom/awdeorio/p2-image-processing.git (push)\n```\n\nYou should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#create-a-local-repository)).\n```console\n$ pwd\n/Users/awdeorio/src/eecs280/p2-image-processing\n$ head .gitignore\n# This is a sample .gitignore file that's useful for C++ projects.\n...\n```\n\n### Group registration\nRegister your partnership (or working alone) on the Autograder using the direct link in the [Submission and Grading section](#submission-and-grading).  Then, submit the code you have.\n\n## Matrix Module\n\nCreate a Matrix abstract data type (ADT).  Write implementations in `Matrix.cpp` for the functions declared in `Matrix.hpp`.\n\nRun the public Matrix tests.\n```console\n$ make Matrix_public_tests.exe\n$ ./Matrix_public_tests.exe\n```\n\nComplete the EECS 280 [Unit Test Framework Tutorial](https://eecs280staff.github.io/unit_test_framework/).\n\nWrite tests for `Matrix` in `Matrix_tests.cpp` using the unit test framework.  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make Matrix_tests.exe\n$ ./Matrix_tests.exe\n```\n\nSubmit `Matrix.cpp` and `Matrix_tests.cpp` to the Autograder using the link in the [Submission and Grading section](#submission-and-grading).\n\n### Setup\n\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Matrix.cpp.starter` -> `Matrix.cpp`\n-  `Matrix_tests.cpp.starter` -> `Matrix_tests.cpp`\n\nThe Matrix tests should compile and run.  Expect them to fail at this point because the `Matrix.cpp` starter code contains function stubs.\n```console\n$ make Matrix_public_tests.exe\n$ ./Matrix_public_tests.exe\n$ make Matrix_tests.exe\n$ ./Matrix_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Matrix_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Matrix_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Matrix_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Matrix_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>XCode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Matrix_public_test.cpp`, `Matrix.cpp`, `Matrix_test_helpers.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Matrix_tests.cpp`, `Matrix.cpp`, `Matrix_test_helpers.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Matrix_public_test.cpp`\n  - Exclude `Matrix_tests.cpp`, `Image_public_test.cpp`, `Image_tests.cpp`, `processing_public_tests.cpp`, `resize.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Matrix_tests.cpp`\n  - Exclude `Matrix_public_test.cpp`, `Image_public_test.cpp`, `Image_tests.cpp`, `processing_public_tests.cpp`, `resize.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Interface\n\nA matrix is a two-dimensional grid of elements. For this project,\nmatrices store integer elements and we will refer to locations by\nrow/column. For example, here's a 3x5 matrix.\n\n![](images/matrix3x5.svg){: .invert-colors-in-dark-mode }\n\nThe `Matrix.hpp` file defines a `Matrix` struct to represent matrices\nand specifies the interface for functions to operate on them.\nDimensions of 0 are not allowed.\n\nTo create a `Matrix`, first declare a variable and then use an\ninitializer function.\n\n```c++\nMatrix m; // create a Matrix object in local memory\nMatrix_init(&m, 100, 100); // initialize it as a 100x100 matrix\n```\n\nOnce a `Matrix` is initialized, it is considered valid. Now we can use\nany of the functions declared in `Matrix.hpp` to operate on it.\n\n```c++\nMatrix_fill(&m, 0); // fill with zeros\n\n// fill first row with ones\nfor (int c = 0; c < Matrix_width(m); ++c) {\n  *Matrix_at(&m, 0, c) = 1; // see description below\n}\n\nMatrix_print(&m, cout); // print matrix to cout\n```\n\nAccess to individual elements in a `Matrix` is provided through a\npointer to their location, which can be retrieved through a call to\n`Matrix_at`. To read or write the element, you just dereference the\npointer.\n\nThe RMEs in `Matrix.hpp` give a full specification of the interface for\neach `Matrix` function.\n\n### Implementation\nThe `Matrix` struct looks like this:\n\n```c++\nstruct Matrix {\n  int width;\n  int height;\n  std::vector<int> data;\n};\n```\n\n`Matrix` stores a 2D grid of numbers in an underlying one-dimensional\nvector, which in turn stores its elements in a one-dimensional array.\n\nInterface | Implementation\n--------- | --------------\n![](images/matrix3x5.svg){: .invert-colors-in-dark-mode } | ![](images/matrix3x5_impl.svg){: .invert-colors-in-dark-mode }\n\n<div class=\"primer-spec-callout info icon-info\" markdown=\"1\">\n**Pro-tip:** You will need to either create a vector with a given\nsize, or resize an existing vector to that size. Here are some ways to\ndo so:\n\n```c++\n// create a vector with 100 elements, all initialized to the value 0\n// primer-spec-highlight-start\nstd::vector<int> vec(100, 0);\n// primer-spec-highlight-end\n\n// modify an existing vector to have 200 elements with value 0\n// primer-spec-highlight-start\nvec.assign(200, 0);\n// primer-spec-highlight-end\n\n// replace an existing vector with a new one containing 50 elements,\n// all initialized to the value 0\n// primer-spec-highlight-start\nvec = std::vector<int>(50, 0);\n// primer-spec-highlight-end\n```\n</div>\n\nEach of the functions in the `Matrix` module takes a pointer to the\n`Matrix` that is supposed to be operated on. In your implementations\nof these functions, you should access the `width`, `height`, and\n`data` members of that `Matrix`, but this is the only place you may do\nso. To all other code, the individual members are an implementation\ndetail that should be hidden behind the provided interfaces for the\n`Matrix` module.\n\nYour `Matrix_at` functions will need to perform the appropriate\narithmetic to convert from a (row,column) pair to an index in the\nvector. *This function does not require a loop, and you'll find\nyour implementation will be very slow if you use a loop.*\n\nThere are two versions of the `Matrix_at` function to support element\naccess for both const and non-const matrices. The constness of the\npointer returned corresponds to the `Matrix` passed in. The\nimplementations for these will be identical.\n\nRemember that you may call any of the functions in a module as part of\nthe implementation of another, and in fact you should do this if it\nreduces code duplication. In particular, you can access the\n`data` member directly in the `Matrix_init`, `Matrix_at`, and `Matrix_fill` \nfunctions. However, other functions including `Matrix_fill_border`, \n`Matrix_min_value_in_row`, and `Matrix_column_of_min_value_in_row`\nwill be *easier* to write if they access elements by calling \n`Matrix_at()` as a helper function instead.\n\n<div class=\"primer-spec-callout info icon-info\" markdown=\"1\">\n**Pro-tip:**  Use `assert()` to check the conditions in the REQUIRES clause.  If other code breaks the interface, that's a bug and you want to know right away!  Here's an example.\n\n```c++\n// primer-spec-highlight-start\n// REQUIRES: mat points to a valid Matrix\n//           0 <= row && row < Matrix_height(&mat)\n//           0 <= column && column < Matrix_width(&mat)\n// primer-spec-highlight-end\n// EFFECTS:  Returns a pointer to the element in\n//           the Matrix at the given row and column.\nint* Matrix_at(Matrix* mat, int row, int column) {\n  // primer-spec-highlight-start\n  assert(0 <= row && row < mat->height);\n  assert(0 <= column && column < mat->width);\n  // primer-spec-highlight-end\n  // ...\n}\n```\n\nSome things can't be checked, for example that a pointer points to a valid `Matrix`.\n</div>\n\n### Testing\nTest your Matrix functions to ensure that your implementations conform to\nspecification in the RME.\n\nHeed the Small Scope Hypothesis. There is no need for large `Matrix` structs. (Other than an as edge case for max size.) Think about what makes tests meaningfully different.\n\nRespect the interfaces for the modules you are testing. Do not access member variables of the structs directly. Do not test inputs that break the REQUIRES clause for a function.\n```c++\nTEST(test_bad) {\n  Matrix mat;\n  const int width = 3;\n  const int height = 5;\n  const int value = 42;\n  Matrix_init(&mat, 3, 5);\n  Matrix_fill(&mat, value);\n\n  for(int r = 0; r < height; ++r) {\n    for(int c = 0; c < width; ++c) {\n      // primer-spec-highlight-start\n      ASSERT_EQUAL(mat.data[r][c], value);  // BAD! DO NOT access member directly\n      // primer-spec-highlight-end\n    }\n  }\n}\n```\n\nSometimes you need to use one Matrix one function while testing another.  For example, you need `Matrix_at` to test `Matrix_fill`.\n```c++\nTEST(test_fill_basic) {\n  Matrix mat;\n  const int width = 3;\n  const int height = 5;\n  const int value = 42;\n  Matrix_init(&mat, 3, 5);\n  // primer-spec-highlight-start\n  Matrix_fill(&mat, value);\n  // primer-spec-highlight-end\n\n  for(int r = 0; r < height; ++r) {\n    for(int c = 0; c < width; ++c) {\n      // primer-spec-highlight-start\n      ASSERT_EQUAL(*Matrix_at(&mat, r, c), value);\n      // primer-spec-highlight-end\n    }\n  }\n}\n```\n\nUse an `ostringstream` to test `Matrix_print()`.\n```c++\n#include <sstream>\n\nTEST(test_matrix_print) {\n  Matrix mat;\n  Matrix_init(&mat, 1, 1);\n\n  *Matrix_at(&mat, 0, 0) = 42;\n  ostringstream expected;\n  expected << \"1 1\\n\"\n           << \"42 \\n\";\n  ostringstream actual;\n  Matrix_print(&mat, actual);\n  ASSERT_EQUAL(expected.str(), actual.str());\n}\n```\n\nIn your `Matrix` tests, you may use the functions provided in `Matrix_test_helpers.hpp`.  Do not use `Image_test_helpers.hpp` in your `Matrix` tests.\n\n## Image Module\nCreate an Image abstract data type (ADT).  Write implementations in `Image.cpp` for the functions declared in `Image.hpp`.\n\nRun the public Image tests.\n```console\n$ make Image_public_tests.exe\n$ ./Image_public_tests.exe\n```\n\nWrite tests for `Image` in `Image_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make Image_tests.exe\n$ ./Image_tests.exe\n```\n\nSubmit `Image.cpp` and `Image_tests.cpp` to the Autograder using the link in the [Submission and Grading section](#submission-and-grading).\n\n### Setup\n\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n- `Image.cpp.starter` -> `Image.cpp`\n- `Image_tests.cpp.starter` -> `Image_tests.cpp`\n\nThe Image tests should compile and run.  Expect them to fail at this point because the `Image.cpp` starter code contains function stubs.\n```console\n$ make Image_public_tests.exe\n$ ./Image_public_tests.exe\n$ make Image_tests.exe\n$ ./Image_tests.exe\n```\n\nWrite tests for `Image` in `Image_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make Image_tests.exe\n$ ./Image_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th>\n  </th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Image_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Image_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Image_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Image_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>XCode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Image_public_test.cpp`, `Matrix.cpp`, `Image.cpp`, `Matrix_test_helpers.cpp`, `Image_test_helpers.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Image_tests.cpp`, `Matrix.cpp`, `Image.cpp`, `Matrix_test_helpers.cpp`, `Image_test_helpers.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build : <br>\n  - Include `Image_public_test.cpp`\n  - Exclude `Image_tests.cpp`, `Matrix_public_test.cpp`, `Matrix_tests.cpp`, `processing_public_tests.cpp`, `resize.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Image_tests.cpp`\n  - Exclude `Image_public_test.cpp`, `Matrix_public_test.cpp`, `Matrix_tests.cpp`, `processing_public_tests.cpp`, `resize.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Interface\nAn `Image` is similar to a `Matrix`, but contains `Pixel`s instead of\nintegers. Each `Pixel` includes three integers, which represent red,\ngreen, and blue (RGB) color components. Each component takes on an\nintensity value between 0 and 255. The `Pixel` type is considered\n\"Plain Old Data\" (POD), which means it doesn't have a separate\ninterface. We just use its member variables directly. Here is the\n`Pixel` struct and some examples:\n\n<table>\n<tr>\n<td rowspan=\"3\">\n<pre data-variant=\"legacy\">\nstruct Pixel {\n  int r;  // red\n  int g;  // green\n  int b;  // blue\n}\n</pre>\n</td>\n<td style=\"text-align: center;\">\n<img src=\"images/image20.png\" />\n<br>\n(255,0,0)\n</td>\n<td style=\"text-align: center;\">\n<img src=\"images/image18.png\" />\n<br>\n(0,255,0)\n</td>\n<td style=\"text-align: center;\">\n<img src=\"images/image3.png\" />\n<br>\n(0,0,255)\n</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">\n<img src=\"images/image24.png\" />\n<br>\n(0,0,0)\n</td>\n<td style=\"text-align: center;\">\n<img src=\"images/image19.png\" style=\"border:1px solid black\"/>\n<br>\n(255,255,255)\n</td>\n<td style=\"text-align: center;\">\n<img src=\"images/image8.png\" />\n<br>\n(100,100,100)\n</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">\n<img src=\"images/image2.png\" />\n<br>\n(101,151,183)\n</td>\n<td style=\"text-align: center;\">\n<img src=\"images/image25.png\" />\n<br>\n(124,63,63)\n</td>\n<td style=\"text-align: center;\">\n<img src=\"images/image14.png\" />\n<br>\n(163,73,164)\n</td>\n</tr>\n</table>\n\nBelow is a 5x5 image and its conceptual representation\nas a grid of pixels.\n\n![](images/dog_pixels.svg)\n\nDimensions of 0 are not allowed. To create an `Image`, first declare a\nvariable and then use an initializer function. There are several\ninitializer functions, but for now we'll just use the basic one.\n\n```c++\nImage img; // create an Image object in local memory\nImage_init(&img, 5, 5); // initialize it as a 5x5 image\n```\n\nOnce an `Image` is initialized, it is considered valid. Now we can use\nany of the functions declared in `Image.hpp` to operate on it.\n\n```c++\nPixel um_blue = { 0, 46, 98 };\nPixel um_maize = { 251, 206, 51 };\nImage_fill(&img, um_blue); // fill with blue\n\n// fill every other column with maize to make stripes\nfor (int c = 0; c < Image_width(&img); ++c) {\n  if (c % 2 == 0) { // only even columns\n    for (int r = 0; r < Image_height(&img); ++r) {\n      Image_set_pixel(&img, r, c, um_maize);\n    }\n  }\n}\n```\n\nTo read and write individual `Pixel`s in an `Image`, use the\n`Image_get_pixel` and `Image_set_pixel` functions, respectively.\n\nThe RMEs in `Image.hpp` give a full specification of the interface for\neach `Image` function.\n\n### PPM Format\n\nThe `Image` module also provides functions to read and write `Image`s\nfrom/to the PPM image format. Here's an example of an `Image` and its\nrepresentation in PPM.\n\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<th>Image</th>\n<th>Image Representation in PPM</th>\n</tr>\n<tr class=\"even\">\n<td><img src=\"images/image7.png\" /></td>\n<td>\n<pre data-variant=\"legacy\">\nP3\n5 5\n255\n0 0 0 0 0 0 255 255 250 0 0 0 0 0 0 \n255 255 250 126 66 0 126 66 0 126 66 0 255 255 250 \n126 66 0 0 0 0 255 219 183 0 0 0 126 66 0 \n255 219 183 255 219 183 0 0 0 255 219 183 255 219 183 \n255 219 183 0 0 0 134 0 0 0 0 0 255 219 183 \n</pre>\n</td>\n</tr>\n</tbody>\n</table>\n\nThe PPM format begins with these elements, each\nseparated by\n    whitespace:\n\n  - `P3` (Indicates it's a \"Plain PPM file\".)\n  - `WIDTH HEIGHT` (Image width and height, separated by whitespace.)\n  - `255` (Max value for RGB intensities. We'll always use 255.)\n\nThis is followed by the pixels in the image, listed with each row on a\nseparate line. A pixel is written as three integers for its RGB\ncomponents in that order, separated by whitespace.\n\nTo write an image to PPM format, use the `Image_print` function that\ntakes in a `std::ostream`. This can be used in conjunction with file\nI/O to write an image to a PPM file. **The `Image_print` function must\nproduce a PPM using whitespace in a very specific way** so that we can\nuse `diff` to compare your output PPM file against a correct PPM file.\nSee the RME for the full details.\n\nTo create an image by reading from PPM format, use the `Image_init`\nfunction that takes in a `std::istream`. This can be used in\nconjunction with file I/O to read an image from a PPM file. Because we\nmay be reading in images generated from programs that don't use\nwhitespace in the same way that we do, the `Image_init` function must\naccommodate any kind of whitespace used to separate elements of the\nPPM format (if you use C++ style I/O with `>>`, this should be no\nproblem). Other than variance in whitespace (not all PPM files put\neach row on its own line, for example), you may assume any input\nto this function is in valid PPM format. (Some PPM files may contain\n\"comments\", but you do not have to account for these.)\n\nSee [Working with PPM Files](ppm.html) for more\ninformation on working with PPM files and programs that can be used to\nview or create them on various platforms.\n\n### Implementation\n\nThe `Image` struct looks like this:\n\n```c++\nstruct Image {\n  int width;\n  int height;\n  Matrix red_channel;\n  Matrix green_channel;\n  Matrix blue_channel;\n};\n```\n\nThe Interface for `Image` makes it seem like we have a grid of\n`Pixel`s, but the `Image` struct actually stores the information for\nthe image in three separate `Matrix` structs, one for each of the RGB\ncolor channels. There are no `Pixel`s in the underlying\nrepresentation, so your `Image_get_pixel` function must pack the RGB\nvalues from each color `Matrix` into a `Pixel` to be returned.\nLikewise, `Image_set_pixel` must unpack RGB values from an input\n`Pixel` and store them into each `Matrix`.\n\nEach of the functions in the `Image` module takes a pointer to the\n`Image` that is supposed to be operated on. When you are writing\nimplementations for these functions, you may be tempted to access\nmembers of the `Matrix` struct directly (e.g.\n`img->red_channel.width`, `img->green_channel.data[x]`). Don't do it!\nThey aren't part of the interface for `Matrix`, and you should not use\nthem from the outside. Instead, use the `Matrix` functions that are\npart of the interface (e.g. `Matrix_width(&img->red_channel)`,\n`Matrix_at(&img->green_channel, r, c)`).\n\nIn your implementation of the `Image_init` functions, space for the\n`Matrix` members will have already been allocated as part of the\n`Image`. However, you still need to initialize these with a call to\n`Matrix_init` to ensure they are the right size!\n\nThe `Image` struct contains `width` and `height` members. These are\ntechnically redundant, since each of the `Matrix` members also keeps\ntrack of a width and height, but having them around should make the\nimplementations for your functions easier to read.\n\n### Respect the Interfaces!\n\nOur goal is to use several modules that work together through\nwell-defined interfaces, and to keep the implementations separate from\nthose interfaces. The interfaces consist of the functions we provide\nin the `.hpp` file for the module, but NOT the member variables of the\nstruct. The member variables are part of the implementation, not the\ninterface!\n\nThis means you may access member variables directly (i.e. using `.` or\n`->`) when you're writing code within their module, but never from the\noutside world! For example, let's consider the `Image` module. If I'm\nwriting the implementation of a function inside the module, like\n`Image_print`, it's fine to use the member variable `height` directly:\n\n```c++\nvoid Image_print(const Image *img, std::ostream& os) {\n  ...\n  // loop through all the rows\n  for (int r = 0; r < img->height; ++r) {\n    // do something\n  }\n  ...\n}\n```\n\nThis is fine, because we assume the person who implements the module\nis fully aware of all the details of how to use `height` correctly.\nHowever, if I'm working from the outside, then using member variables\ndirectly is very dangerous. This code won't work right:\n\n```c++\nint main() {\n  // Make a 400x300 image (sort of)\n  Image img;\n  img.width = 400;\n  img.height = 300;\n  // do something with img but it doesn't work :(\n  ...\n}\n```\n\nThe problem is that we \"forgot\" about initializing the width and\nheight of the `Matrix` structs that make up each color channel in the\nimage. Instead, we should have used the `Image_init` function from the\noutside, which takes care of everything for us.\n\nHere's the big idea - we don't want the \"outside world\" to have to\nworry about the details of the implementation, or even to know them at\nall. We want to support substitutability, so that the implementation\ncan change without breaking outside code (as long as it still conforms\nto the interface). Using member variables directly from the outside\nmesses this all up. Don't do it! It could break your code and this\nwill be tested on the autograder!\n\nAn exception to this rule is the `Pixel` struct. It's considered to be\na \"Plain Old Data\" (POD) type. In this case, the interface and the\nimplementation are the same thing. It's just an aggregate of three\nints to represent an RGB pixel - nothing more, nothing less.\n\nWe should note there are patterns used in C-style programming that\nhide away the definition of a struct's members and prevent us from\naccidentally accessing them outside the correct module. Unfortunately,\nthis causes complications that we don't have all the tools to deal\nwith yet (namely dynamic memory management). We'll also see that C++\nadds some built-in language mechanisms to control member\naccessibility. For now, you'll just have to be careful!\n\n### Copying Large Structs\n\nIn many cases you will find it useful to copy `Matrix` and `Image`\nstructs in your code. This is supported by the interface, so feel free\nto use it wherever useful. However, try to avoid making unnecessary\ncopies, as this can slow down your code.\n\nAs an example, let's say you wanted to add a border to a `Matrix` and\nprint it without changing the original. You could write this:\n\n```c++\n...\n// Assume we have a variable mat that points to a Matrix\n\n// Make a copy of mat and add the border. original remains unchanged\nMatrix mat_border = *mat; // need to dereference mat to copy it \nMatrix_fill_border(&mat_border, 0);\n\n// print the bordered version\nMatrix_print(&mat_border, os);\n...\n```\n\n### Testing\n\nRespect the interfaces for the modules you are testing. Do not access\nmember variables of the structs directly. Do not test inputs that\nbreak the REQUIRES clause for a function.\n\nYou may use stringstreams to simulate file input and/or output for your unit tests. You may also use the image files `dog.ppm`, `crabster.ppm`, and `horses.ppm`, but no others.\n\nIn your `Image` tests, you may use the functions provided in `Image_test_helpers.hpp`.  Do not use `Matrix_test_helpers.hpp` in your `Image` tests.\n\n## Processing Module\nThe `processing` module contains several functions that perform image\nprocessing operations. Some of these provide an interface for\ncontent-aware resizing of images, while others correspond to\nindividual steps in the seam carving algorithm.\n\nThe main interface for using content-aware resizing is through the\n`seam_carve`, `seam_carve_width` and `seam_carve_height` functions.\nThese functions use the seam carving algorithm to shrink either an\nimage's width or height in a context-aware fashion. The `seam_carve`\nfunction adjusts both width and height, but width is always done\nfirst. For this project, we only support shrinking an image, so the\nrequested width and height will always be less than or equal to the\noriginal values.\n\nWrite implementations in `processing.cpp` for the functions declared in `processing.hpp`.\n\nRun the public processing tests.\n```console\n$ make processing_public_tests.exe\n$ ./processing_public_tests.exe\n```\n\nSubmit `processing.cpp` to the Autograder using the link in the [Submission and Grading section](#submission-and-grading).\n\n### Setup\n\nRename this file ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n- `processing.cpp.starter` -> `processing.cpp`\n\nThe Processing tests should compile and run.  Expect them to fail at this point because the `processing.cpp` starter code contains function stubs.\n```console\n$ make processing_public_tests.exe\n$ ./processing_public_tests.exe\n```\n\nConfigure your IDE to debug public tests.\n\n<table>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/processing_public_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/processing_public_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>XCode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `processing_public_tests.cpp`, `Matrix.cpp`, `Image.cpp`, `processing.cpp`, `Matrix_test_helpers.cpp`, `Image_test_helpers.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `processing_public_tests.cpp`\n  - Exclude `Matrix_public_test.cpp`, `Matrix_tests.cpp`, `Image_public_test.cpp`, `Image_tests.cpp`, `resize.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Energy Matrix\n\n`compute_energy_matrix`: The seam carving algorithm works by removing seams that pass through\nthe least important pixels in an image. We use a pixel's energy as a\nmeasure of its importance.\n\nTo compute a pixel's energy, we look at its neighbors. We'll call them\nN (north), S (south), E (east), and W (west) based on their direction\nfrom the pixel in question (we'll call it X).\n\n![](images/energy_matrix.svg)\n\nThe energy of X is the sum of the squared differences\nbetween its N/S and E/W neighbors:\n\n```\nenergy(X) = squared_difference(N, S) + squared_difference(W, E)\n```\n\nThe static function `squared_difference` is provided as part of the\nstarter code. Do not change the implementation of the\n`squared_difference` function.\n\nTo construct the energy `Matrix` for the whole image, your function\nshould do the following:\n\n1.  Initialize the energy `Matrix` with the same size as the `Image`\n    and fill it with zeros.\n2.  Compute the energy for each non-border pixel, using the formula\n    above.\n3.  Find the maximum energy so far, and use it to fill in the border\n    pixels.\n\n### Cost Matrix\n\n`compute_vertical_cost_matrix`: Once the energy matrix has been computed, the next step is to find the\npath from top to bottom (i.e. a vertical seam) that passes through the\npixels with the lowest total energy (this is the seam that we would\nlike to remove).\n\nWe will begin by answering a related question - given a particular\npixel, what is the minimum energy we must move through to get to that\npixel via any possible path? We will refer to this as the cost of that\npixel. Our goal for this stage of the algorithm will be to compute a\nmatrix whose entries correspond to the cost of each pixel in the\nimage.\n\nNow, to get to any pixel we have to come from one of the three pixels\nabove it.\n\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><p><img src=\"images/image16.png\" class=\"invert-colors-in-dark-mode\" /><br />\nPixels above (3,2)</p></td>\n<td style=\"text-align: center;\"><p><img src=\"images/image1.png\" class=\"invert-colors-in-dark-mode\" /><br />\nPixels above (2,4)</p></td>\n</tr>\n</tbody>\n</table>\n\nWe would want to choose the least costly from those pixels, which\nmeans the minimum cost to get to a pixel is its own energy plus the\nminimum cost for any pixel above it. This is a recurrence relation.\nFor a pixel with row `r` and column `c`, the cost is:\n\n```\ncost(r, c) = energy(r, c) + min(cost(r-1, c-1),\n                                cost(r-1, c),\n                                cost(r-1, c+1))\n```\n\nUse the `Matrix_min_value_in_row` function to help with this equation.\nOf course, you need to be careful not to consider coming from pixels\noutside the bounds of the `Matrix`.\n\nWe could compute costs recursively, with\npixels in the first row as our base case, but this would involve a lot\nof repeated work since our subproblems will end up overlapping.\nInstead, let's take the opposite approach...\n\n1.  Initialize the cost `Matrix` with the same size as the energy\n    `Matrix`.\n2.  Fill in costs for the first row (index 0). The cost for these\n    pixels is just the energy.\n3.  Loop through the rest of the pixels in the `Matrix`, row by row,\n    starting with the second row (index 1). Use the recurrence above\n    to compute each cost. Because a pixel's cost only depends on other\n    costs in an earlier row, they will have already been computed and\n    can just be looked up in the `Matrix`.\n\n### Minimal Vertical Seam\n`find_minimal_vertical_seam`: The pixels in the bottom row of the image correspond to the possible\nendpoints for any seam, so we start with the one of those that is\nlowest in the cost matrix.\n\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><p><img src=\"images/image6.png\" class=\"invert-colors-in-dark-mode\" /><br />\nFirst, find the minimum cost pixel in the bottom row.</p></td>\n</tr>\n</tbody>\n</table>\n\nNow, we work our way up, considering where we would have come from in\nthe row above. In the pictures below, the blue box represents the\n\"pixels above\" in each step.\n\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><p><img src=\"images/image9.png\" class=\"invert-colors-in-dark-mode\" /><br />\nThen find the minimum cost pixel above.</p></td>\n<td style=\"text-align: center;\"><p><img src=\"images/image13.png\" class=\"invert-colors-in-dark-mode\" /><br />\nDon't look outside the bounds!</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><p><img src=\"images/image21.png\" class=\"invert-colors-in-dark-mode\" /></p>\n<p>For ties, pick the leftmost.</p></td>\n<td style=\"text-align: center;\"><p><img src=\"images/image17.png\" class=\"invert-colors-in-dark-mode\" /></p>\n<p>Repeat until you reach the top row.</p></td>\n</tr>\n</tbody>\n</table>\n\nYou will find the `Matrix_column_of_min_value_in_row` function useful\nhere. Each time you process a row, put the column number of the best\npixel in the seam vector, working your way from the back to front.\n(i.e. The last element corresponds to the bottom row.)\n\n![](images/seam.svg){: .invert-colors-in-dark-mode }\n\n### Removing a Vertical Seam\n\n`remove_vertical_seam`: \nThe seam vector passed into this function contains the column numbers\nof the pixels that should be removed in each row, in order from the\ntop to bottom rows. To remove the seam, copy the image one row at a\ntime, first copying the part of the row before the seam (green),\nskipping that pixel, and then copying the rest (orange).\n\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><p><img src=\"images/image12.png\" class=\"invert-colors-in-dark-mode\" /><br />\nOriginal</p></td>\n<td style=\"text-align: center;\"><p><img src=\"images/image23.png\" class=\"invert-colors-in-dark-mode\" /><br />\nSeam Removed</p></td>\n</tr>\n</tbody>\n</table>\n\nYou should copy into a smaller auxiliary `Image` and then back into\nthe original, because there is no way to change the width of an\nexisting image. Do not attempt to use `Image_init` to \"resize\" the\noriginal - it doesn't preserve existing data in an `Image`.\n\n### Seam Carving Algorithm\n\nWe can apply seam carving to the width of an image, the height, or both.\n\n#### `seam_carve_width`\n{: .primer-spec-toc-ignore }\n\nTo apply seam carving to the width, remove the minimal cost seam until the image has reached the appropriate width.\n\n1.  Compute the energy matrix\n2.  Compute the cost matrix\n3.  Find the minimal cost seam\n4.  Remove the minimal cost seam\n\n#### `seam_carve_height`\n{: .primer-spec-toc-ignore }\n\nTo apply seam carving to the height, just do the following:\n\n1.  Rotate the image left by 90 degrees\n2.  Apply `seam_carve_width`\n3.  Rotate the image right by 90 degrees\n\n#### `seam_carve`\n{: .primer-spec-toc-ignore }\n\nTo adjust both dimensions:\n\n1.  Apply `seam_carve_width`\n2.  Apply `seam_carve_height`\n\n### Testing\n\nWe have provided the `processing_public_tests.cpp` file that contains\na test suite for the seam carving algorithm that runs each of the\nfunctions in the `processing` module and compares the output to the\n\"`_correct`\" files included with the project.\n\nYou should write your own tests for the `processing` module, but you\ndo not need to turn them in. You may do this either by creating a copy\nof `processing_public_tests.cpp` and building onto it, or writing more\ntests from scratch. Pay attention to edge cases.\n\nUse the Makefile to compile the test with this command:\n\n```console\n$ make processing_public_tests.exe\n```\n{: data-variant=\"no-line-numbers\" }\n\nThen you can run the tests for the `dog`, `crabster`, and `horses`\nimages as follows:\n\n```console\n$ ./processing_public_tests.exe\n```\n{: data-variant=\"no-line-numbers\" }\n\nYou can also run the tests on just a single image:\n\n```console\n$ ./processing_public_tests.exe test1_dog\n$ ./processing_public_tests.exe test2_crabster\n$ ./processing_public_tests.exe test3_horses\n```\n\nWhen the test program runs, it will also write out image files\ncontaining the results from your functions before asserting that they\nare correct. You may find it useful to look at the results from your\nown code and visually compare them to the provided correct outputs\nwhen debugging the algorithm.\n\nThe seam carving tests work sequentially and stop at the first\ndeviation from correct behavior so that you can identify the point at\nwhich your code is incorrect.\n\n## Resize Program\n\nThe main resize program supports content-aware resizing of images via a command line interface. \n\nCreate a `resize.cpp` file and write your implementations of the driver program there.\n\nCompile and run the program.  The [interface](#interface-2) section explains each command line argument.\n```console\n$ make resize.exe\n$ ./resize.exe horses.ppm horses_400x250.ppm 400 250\n```\n{: data-variant=\"no-line-numbers\" }\n\n### Setup\n\nIf you created a `main.cpp` while following the setup tutorial, rename it to `resize.cpp`.  Otherwise, create a new file `resize.cpp` ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#add-new-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#add-new-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#add-new-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#add-new-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#touch)).\n\nAdd \"hello world\" code if you haven't already.\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n  cout << \"Hello World!\\n\";\n}\n```\n\nThe resize program should compile and run.\n```console\n$ make resize.exe\n$ ./resize.exe\nHello World!\n```\n\nConfigure your IDE to debug the resize program.\n\n<table>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/resize.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/resize.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>XCode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `resize.cpp`, `Matrix.cpp`, `Image.cpp`, `processing.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `resize.cpp`\n  - Exclude `Matrix_public_test.cpp`, `Matrix_tests.cpp`, `Image_public_test.cpp`, `Image_tests.cpp`, `processing_public_tests.cpp`, `main.cpp` (if present).\n  </td>\n</tr>\n</table>\n\nConfigure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)).  We recommend starting with the smallest input, `dog.ppm dog_4x5.out.ppm 4 5`.\n\nTo compile, run, and test the smallest input at the command line:\n```console\n$ make resize.exe\n$ ./resize.exe dog.ppm dog_4x5.out.ppm 4 5\n$ diff dog_4x5.out.ppm dog_4x5.correct.ppm\n```\n\n### Interface\n\nTo resize the file\n`horses.ppm` to be 400x250 pixels\nand store the result in the file\n`horses_400x250.ppm`, we\nwould use the following command:\n\n```console\n$ ./resize.exe horses.ppm horses_400x250.ppm 400 250\n```\n{: data-variant=\"no-line-numbers\" }\n\nIn particular, here's what each of those means:\n\nArgument | Meaning\n-------- | -------\n`horses.ppm` | The name of the input file from which the image is read.\n`horses_400x250.ppm` | The name of the output file to which the image is written.\n`400` | The desired width for the output image.\n`250` | The desired height for the output image. (Optional)\n\nThe program is invoked with three or four arguments. If\nno height argument is supplied, the original height is kept (i.e. only\nthe width is resized). If your program takes about 30 seconds for large\nimages, that's ok. There's a lot of computation involved.\n\n#### Error Checking\n\nThe program checks that the command line arguments obey\nthe following rules:\n\n  - There are 4 or 5 arguments, including the executable name itself\n    (i.e. `argv[0]`).\n  - The desired width is greater than 0 and less than or equal to the\n    original width of the input image.\n  - The desired height is greater than 0 and less than or equal to the\n    original height of the input image.\n\nIf any of these are violated, use the following lines of code\n(literally) to print an error message.\n\n```c++\ncout << \"Usage: resize.exe IN_FILENAME OUT_FILENAME WIDTH [HEIGHT]\\n\"\n     << \"WIDTH and HEIGHT must be less than or equal to original\" << endl;\n```\n\nYour program should then exit with a non-zero return value from\n`main`. Do **not** use the `exit` function in the standard library, as\nit does not clean up local objects.\n\nIf the input or output files cannot be opened, use the following lines\nof code (literally, except change the variable `filename` to whatever\nvariable you have containing the name of the problematic file) to\nprint an error message, and then return a non-zero value from `main`.\n\n```c++\ncout << \"Error opening file: \" << filename << endl;\n```\n{: data-variant=\"no-line-numbers\" }\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\nYou do not need to do any error checking for command line arguments or\nfile I/O other than what is described in this section. However, you must\nuse precisely the error messages given here in order to receive\ncredit.\n</div>\n\n### Implementation\n\nYour `main` function should not contain much code. It should just\nprocess the command line arguments, check for errors, and then call\nthe appropriate functions from the other modules to perform the\ndesired task.\n\n### Optional: Reading and Writing JPEG Files\n\nYour program must handle input and output files in the PPM format, but\nyou may optionally also implement support for files in the JPEG format.\nTo do so, follow these steps:\n\n1. Install the [libjpeg](https://libjpeg.sourceforge.net/) or\n   [libjpeg-turbo](https://libjpeg-turbo.org/) library. On MacOS, you\n   can run the following:\n\n   ```console\n   $ brew install jpeg-turbo\n   ```\n\n   On WSL or Linux, run the following:\n\n   ```console\n   $ sudo apt install libjpeg-turbo8-dev\n   ```\n\n2. Edit the `Makefile` and set `USE_LIBJPEG` to `true`:\n\n   ```make\n   USE_LIBJPEG ?= true\n   ```\n\n   On MacOS, you will also need to set `LIBJPEG_PATH`. Run the\n   following in the terminal:\n\n   ```console\n   $ brew info jpeg-turbo\n   ```\n\n   You should see output like the following:\n\n    ```text\n   ==> jpeg-turbo: stable 3.0.2 (bottled), HEAD\n   JPEG image codec that aids compression and decompression\n   https://www.libjpeg-turbo.org/\n   /opt/homebrew/Cellar/jpeg-turbo/3.0.2 (44 files, 3.4MB) *\n   ...\n   ```\n   {: data-variant=\"no-line-numbers\" }\n   {: data-highlight=\"4\" }\n\n   Set `LIBJPEG_PATH` to the path you see in the output, e.g.\n\n   ```make\n   LIBJPEG_PATH ?= /opt/homebrew/Cellar/jpeg-turbo/3.0.2\n   ```\n\n3. In `resize.cpp`, add the following `#include`. Do not add it in any other files.\n\n   ```c++\n   #include \"jpeg.hpp\"\n   ```\n\n   You can then make use of the following functions defined in\n   `jpeg.hpp`:\n\n   - `has_jpeg_extension()` determines whether a file name ends with\n      `.jpg` or `.jpeg`, ignoring capitalization \u2013 use this to\n      determine whether the files specified at the command line are\n      JPEG files\n   - `read_jpeg()` reads a JPEG image from a file into an `Image`\n     object\n   - `write_jpeg()` writes an image from an `Image` object into a JPEG\n     file\n\n   See the full documentation of each function in `jpeg.hpp`.\n\n4. Once you are sure that your program is working, you may wish to\n   compile with optimization enabled to make it run significantly\n   faster:\n\n   ```console\n   $ make clean\n   $ make resize.exe CXXFLAGS=\"--std=c++17 -O3\"\n   ```\n\n   Even with optimizations enabled, seam carving is quite expensive.\n   We recommend using input images that are no larger than 1000x1000\n   pixels.\n\n## Submission and Grading\nSubmit to the autograder using this direct autograder link: [https://autograder.io/web/project/3030](https://autograder.io/web/project/3030).\n  - `Matrix.cpp`\n  - `Matrix_tests.cpp`\n  - `Image.cpp`\n  - `Image_tests.cpp`\n  - `processing.cpp`\n  - `resize.cpp`\n\nThis project will be autograded for correctness, comprehensiveness of\nyour test cases, and programming style. See the [style checking\ntutorial](https://eecs280staff.github.io/tutorials/setup_style.html)\nfor the criteria and how to check your style automatically on CAEN.\n\n### Testing\n\nRun all the unit tests and system tests.  This includes the public tests we provided and the unit tests that you wrote.\n\n```console\n$ make test\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Run commands in parallel with `make -j`.\n```console\n$ make -j4 test\n```\n{: data-variant=\"no-line-numbers\" }\n</div>\n\n### Unit Test Grading\n\nWe will autograde your `Matrix` and `Image` unit tests.\n\nYour unit tests must use the [unit test framework](https://eecs280staff.github.io/unit_test_framework/).\n\nA test suite must complete less than 5 seconds and contain 50 or fewer `TEST()` items.  One test suite is one `_test.cpp` file.\n\nTo grade your unit tests, we use a set of intentionally buggy instructor solutions.  You get points for catching the bugs.\n\n1.  We compile and run your unit tests with a **correct solution**.\n    - Tests that pass are **valid**.\n    - Tests that fail are **invalid**, they falsely report a bug.\n3.  We compile and run all of your **valid** tests against each **buggy solution**.\n    - If any of your tests fail, you caught the bug.\n    - You earn points for each bug that you catch.\n\n### Requirements and Restrictions\nIt is our goal for you to gain practice with good C-style object-based\nprogramming and proper use of pointers and structs. Here are\nsome (mandatory) guidelines.\n\n| DO | DO NOT |\n| -- | ------ |\n| Use *either* traversal by pointer or traversal by index, as necessary | |\n| Modify `.cpp` files | Modify `.hpp` files |\n| Put any extra helper functions in the `.cpp` files and declare them `static` | Modify `.hpp` files |\n| | `#include` a `.hpp` file from a module that does not require the code in the `.hpp` file (e.g. including `Image.hpp` from `Matrix.cpp`), as this introduces an incorrect dependency between modules |\n| `#include` a library to use its functions | Assume that the compiler will find the library for you (some do, some don't) |\n| Pass large structs or classes by pointer | Pass large structs or classes by value |\n| Pass by pointer-to-const when appropriate | \"I don't think I'll modify it ...\" |\n\n\n### Diagnosing Slow Code\nIf your code runs too slowly (especially on larger images like the \"horses\"\nexample), a tool called `perf` can analyze which parts of your code take\nthe most time. See the [Perf Tutorial](perf.html) for details.\n\n### Undefined Behavior\nIf your code produces different results on different machine (e.g.\nyour computer vs. the autograder), the likely source is undefined behavior.\nRefer to the [Sanitizers Tutorial](https://eecs280staff.github.io/tutorials/setup_asan.html)\nfor how to use the Address Sanitizer (ASAN) to check for undefined behavior.\n\n## Reach Goals\nOptionally check out the project [reach goals](extra.html).  Reach goals are entirely optional.\n\n\n## Acknowledgments\nThis project was written by James Juett, Winter 2016 at the University\nof Michigan. It was inspired by Josh Hug's \"Nifty Assignment\" at\nSIGCSE 2015.\n", "extracted_entities": ["EECS 280", "Image Processing", "February 12th, 2025", "Winter 2025", "Matrix", "C++", "PPM", "JPEG", "libjpeg", "libjpeg-turbo", "dog.ppm", "crabster.ppm", "horses.ppm"], "extracted_triples": [["EECS 280", "is a course on", "Image Processing"], ["Image Processing", "due on", "February 12th, 2025"], ["Image Processing", "released in", "Winter 2025"], ["Matrix", "is an abstract data type in", "C++"], ["Image Processing", "uses", "PPM format"], ["Image Processing", "uses", "JPEG format"], ["libjpeg", "is a library for", "JPEG"], ["libjpeg-turbo", "is a library for", "JPEG"], ["dog.ppm", "is a sample input file for", "Image Processing"], ["crabster.ppm", "is a sample input file for", "Image Processing"], ["horses.ppm", "is a sample input file for", "Image Processing"]]}, {"idx": "chunk-ebb71aa553680fa66eb7ba7ab0a35328", "passage": "---\nlayout: spec\nlatex: true\nmermaid: true\n---\n\nEECS 280 Project 4: Machine Learning\n====================================\n{: .primer-spec-toc-ignore }\n\nWinter 2025 release.\n\nProject due 8:00pm EST Friday March 28, 2024.\n\nYou may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)).\n\n## Introduction\n\nAutomatically identify the subject of posts from the EECS 280 Piazza using natural language processing and machine learning techniques.\n\nThe learning goals of this project include using container ADTs, such as sets and maps. You will also gain experience designing and implementing a substantial application program.\n\nFor example, your program will be able to read a Piazza post like this and figure out that it's about Project 3: Euchre.\n\n<img src=\"images/image28.png\" width=\"640px\" />\n\n\n## Setup\nSet up your visual debugger and version control, then submit to the autograder.\n\n### Visual debugger\nDuring setup, name your project `ml-classifier`. Use this starter files link: `https://eecs280staff.github.io/ml-classifier/starter-files.tar.gz`\n\n| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |\n\nYou should end up with a folder with starter files that look like this. You may also have a `main.cpp` file after following the setup tutorial, which you should rename to `classifier.cpp`. If not, you will create a `classifier.cpp` file in the [Classifier](#classifier) section.\n```console\n$ ls\nMakefile\t\t\t\t\t\ttrain_small.csv\ncsvstream.hpp\t\t\t\t\ttrain_small_train_only.out.correct\ninstructor_student.out.correct\tw14-f15_instructor_student.csv\nprojects_exam.out.correct\t\tw16_instructor_student.csv\nsp16_projects_exam.csv\t\t\tw16_projects_exam.csv\ntest_small.csv\t\t\t\t\tw16_projects_exam_train_only.out.correct\ntest_small.out.correct\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each starter file.\n\n| File(s) | Description |\n| ------- | ----------- |\n| `csvstream.hpp` | Library for reading CSV files. |\n| `train_small.csv`<br> `test_small.csv`<br> `test_small.out.correct`<br> `train_small_train_only.out.correct` | Sample input and output for the classifier. |\n| `sp16_projects_exam.csv`<br> `w14-f15_instructor_student.csv`<br> `w16_instructor_student.csv`<br> `w16_projects_exam.csv`<br>`w16_projects_exam_train_only.out.correct`<br> `instructor_student.out.correct`<br> `projects_exam.out.correct` | Piazza data input from past terms, with correct output. |\n| `Makefile` | Helper commands for building. |\n\n### Version control\nSet up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).\n\nAfter you're done, you should have a local repository with a \"clean\" status and your local repository should be connected to a remote GitHub repository.\n```console\n$ git status\nOn branch main\nYour branch is up-to-date with 'origin/main'.\n\nnothing to commit, working tree clean\n$ git remote -v\norigin\thttps://github.com/awdeorio/ml-classifier.git (fetch)\norigin\thttps://githubcom/awdeorio/ml-classifier.git (push)\n```\n\nYou should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).\n```console\n$ head .gitignore\n# This is a sample .gitignore file that's useful for C++ projects.\n...\n```\n\n### Group registration\nRegister your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.\n\n\n## ML and NLP Background\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Skim this section the first time through.  Refer back to it while you're coding the [Classifier](#classifier).\n</div>\n\n### Machine Learning and Classification\n\nThe goal for this project is to write an intelligent program that can\n**classify** Piazza posts according to topic. This task is easy for humans -\nwe simply read and understand the content of the post, and the topic is\nintuitively clear. But how do we compose an algorithm to do the same? We\ncan't just tell the computer to \"look at it\" and understand. This is\ntypical of problems in artificial intelligence and natural language\nprocessing.\n\n![](images/image28.png)\n\nWe know this is about Euchre, but how can we write an algorithm that\n\"knows\" that?\n\nWith a bit of introspection, we might realize each individual word is a\nbit of evidence for the topic about which the post was written. Seeing a\nword like \"card\" or \"spades\" leads us toward the Euchre\nproject. We judge a potential label for a post based on how likely it is\ngiven all the evidence. Along these lines, information about how common\neach word is for each topic essentially constitutes our classification\nalgorithm.\n\nBut we don't have that information (i.e. that algorithm). You could try\nto sit down and write out a list of common words for each project, but\nthere's no way you'll get them all. For example, the word \"lecture\"\nappears much more frequently in posts about exam preparation. This makes\nsense, but we probably wouldn't come up with it on our own. And what if\nthe projects change? We don't want to have to put in all that work\nagain.\n\nInstead, let's write a program to comb through Piazza posts from\nprevious terms (which are already tagged according to topic) and learn\nwhich words go with which topics. Essentially, the result of our program\nis an algorithm! This approach is called (supervised) machine learning.\nOnce we've trained the classifier on some set of Piazza posts, we can\napply it to new ones written in the future.\n\n![](images/image29.png){: .invert-colors-in-dark-mode }\n\nAt a high level, the classifier we'll implement works by assuming a\nprobabilistic model of how Piazza posts are composed, and then finding\nwhich label (e.g. our categories of  \"euchre\", \"exam\", etc.) is the most\nprobable source of a particular post.\n\nAll the details of natural language processing (NLP) and machine\nlearning (ML) techniques you need to implement the project are described\nhere. You are welcome to consult other resources, but there are many\nkinds of classifiers that have subtle differences. The classifier we\ndescribe here is a simplified version of a \"Multi-Variate Bernoulli\nNaive Bayes Classifier\". If you find other resources, but you're not\nsure they apply, make sure to check them against this specification.\n\n[This document](naive_bayes.html) provides a more complete description\nof the way the classifier works, in case you're interested in the math\nbehind the formulas here.\n\n### Piazza Dataset\n\nFor this project, we retrieved archived Piazza posts from EECS 280 in\npast terms. We will focus on two different ways to divide Piazza posts\ninto labels (i.e. categories).\n\n- By **topic**. Labels: \"exam\", \"calculator\", \"euchre\", \"image\", \"recursion\",\n  \"statistics\"\n\n  Example: Posts extracted from `w16_projects_exam.csv`\n\n  | label | content |\n  | ----- | ------- |\n  | exam | will final grades be posted within 72 hours |\n  | calculator | can we use the friend class list in stack |\n  | euchre | weird problem when i try to compile euchrecpp |\n  | image | is it normal for the horses tests to take 10 minutes |\n  | recursion | is an empty tree a sorted binary tree |\n  | statistics | are we supposed to have a function for summary |\n  | ... | ... |\n\n- By **author**. Labels: \"instructor\", \"student\"\n\n  Example: Posts extracted from `w14-f15_instructor_student.csv`\n\n  | label | content |\n  | ----- | ------- |\n  | instructor | disclaimer not actually a party just extra OH |\n  | student | how can you use valgrind with calccpp |\n  | student | could someone explain to me what the this keyword means |\n  | ... | ... |\n\nThe Piazza datasets are Comma Separated Value (CSV) files. The label for\neach post is found in the \"tag\" column, and the content in the\n\"content\" column. There may be other columns in the CSV file; your\ncode should ignore all but the \"tag\" and \"content\" columns. **You may\nassume all Piazza files are formatted\ncorrectly, and that post content and labels only contain lowercase\ncharacters, numbers, and no punctuation.** You must use the\n`csvstream.hpp` library (see\n[https://github.com/awdeorio/csvstream](https://github.com/awdeorio/csvstream) for\ndocumentation) to read CSV files in your application. The\n`csvstream.hpp` file itself is included with the starter code.\n\n**Your classifier should not hardcode any labels. Instead, it should use\nthe exact set of labels that appear in the training data.**\n\n<div id=\"splitting-a-whitespace-delimited-string\" class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Here's how to split a string into words. You may use this code as given.\n```c++\n// EFFECTS: Return a set of unique whitespace delimited words\nset<string> unique_words(const string &str) {\n  istringstream source(str);\n  set<string> words;\n  string word;\n  while (source >> word) {\n    words.insert(word);\n  }\n  return words;\n}\n```\n</div>\n\nWe have included several Piazza datasets with the project:\n  - `train_small.csv` - Made up training data intended for small-scale\n    testing.\n  - `test_small.csv` - Made up test data intended for small-scale\n    testing.\n  - `w16_projects_exam.csv` - (Train) Real posts from W16 labeled by\n    topic.\n  - `sp16_projects_exam.csv` - (Test) Real posts from Sp16 labeled by\n    topic.\n  - `w14-f15_instructor_student.csv` - (Train) Real posts from four\n    terms labeled by author.\n  - `w16_instructor_student.csv` - (Test) Real posts from W16 Piazza\n    labeled by author.\n\nFor the real datasets, we have indicated which are intended for training\nvs. testing.\n\n### Bag of Words Model\n\nWe will treat a Piazza post as a \"**bag of words**\" - each post is simply characterized by which words it includes. The ordering of words is ignored, as are multiple occurrences of the same word. These two posts would be considered equivalent:\n- \"the left bower took the trick\"\n- \"took took trick the left bower bower\"\n\nThus, we could imagine the post-generation process as a person sitting down and going through every possible word and deciding which to toss into a bag.\n\n#### Conditional Probability\n\nWe write $$ P(A) $$ to denote the probability (a number\nbetween 0 and 1) that some event $$ A $$ will occur.\n$$ P(A \\mid B) $$ denotes the probability that event\n$$ A $$ will occur given that we already know event\n$$ B $$ has occurred. For example,\n$$ P(bower \\mid euchre) \\approx 0.007 $$. This means that if a Piazza post is about the\neuchre project, there is a 0.7% chance it will contain the word bower\n(we should say \"at least once\", technically, because of the bag of words\nmodel).\n\n### Training\n\nBefore the classifier can make predictions, it needs to be trained on a\nset of previously labeled Piazza posts (e.g. `train_small.csv` or\n`w16_projects_exam.csv`). Your application should process each post in\nthe training set, and record the following information:\n\n  - The total number of posts in the entire training set.\n  - The number of unique words in the entire training set. (The\n    **vocabulary size**.)\n  - For each word $$ w $$, the number of posts in the\n    entire training set that contain $$ w $$.\n  - For each label $$ C $$, the number of posts with that\n    label.\n  - For each label $$ C $$ and word\n    $$ w $$, the number of posts with label\n    $$ C $$ that contain $$ w $$.\n\n### Prediction\n\nHow do we predict a label for a new post?\n\nGiven a new Piazza post $$ X $$, we must determine the\nmost probable label $$ C $$, based on what the classifier\nhas learned from the training set. A measure of the likelihood of $$ C $$ is\nthe **log-probability score** given the post:\n\n$$\n\\ln P(C) + \\ln P(w_1 \\mid C) + \\ln P(w_2 \\mid C) + \\cdots + \\ln P(w_n \\mid C)\n$$\n\n**Important**: Because we're using the bag-of-words model, the words $$ w_1, w_2, \\ldots, w_n $$ in this formula are only the [unique\nwords](#splitting-a-whitespace-delimited-string) in the\npost, not including duplicates\\! To ensure consistent results, make\nsure to add the contributions from each word in alphabetic order.\n\nThe classifier should predict whichever label has the highest\nlog-probability score for the post. If multiple labels are tied, predict\nwhichever comes first alphabetically.\n\n$$ \\ln P(C) $$ is the **log-prior** probability of label\n$$ C $$ and is a reflection of how common it is:\n\n$$\n\\ln P(C) = \\ln \\left( \\frac{\\text{number of training posts with label } C}{\\text{number of training posts}} \\right)\n$$\n\n$$ \\ln P(w \\mid C) $$ is the **log-likelihood** of a word\n$$ w $$ given a label $$ C $$, which is a\nmeasure of how likely it is to see word $$ w $$ in posts\nwith label $$ C $$. The regular formula for\n$$ \\ln P(w \\mid C) $$ is:\n\n$$\n\\ln P(w \\mid C) = \\ln \\left( \\frac{\\text{number of training posts with label } C \\text{ that contain } w}{\\text{number of training posts with label } C} \\right)\n$$\n\nHowever, if $$ w $$ was never seen in a post with label\n$$ C $$ in the training data, we get a log-likelihood of\n$$ -\\infty $$, which is no good. Instead, use one of these two alternate formulas:\n\n---\n\n$$\n\\ln P(w \\mid C) = \\ln \\left( \\frac{\\text{number of training posts that contain } w}{\\text{number of training posts}} \\right)\n$$\n\n(Use when $$ w $$ does not occur in posts labeled $$ C $$ but does occur in the training data overall.)\n\n---\n\n$$\n\\ln P(w \\mid C) = \\ln \\left( \\frac{1}{\\text{number of training posts}} \\right)\n$$\n\n(Use when $$ w $$ does not occur anywhere at all in the\ntraining set.)\n\n---\n\n\n## Classifier\n\nWrite the classifier in `classifier.cpp` using the [bag of words model](#bag-of-words-model).\n\nRun the classifier on a small dataset.\n```console\n$ ./classifier.exe train_small.csv test_small.csv\n```\n\n### Setup\n\nIf you created a `main.cpp` while following the setup tutorial, rename it to `classifier.cpp` if you have not already done so.  Otherwise, create a new file `classifier.cpp` ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#add-new-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#add-new-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#add-new-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#add-new-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#touch)).\n\nAdd \"hello world\" code if you haven't already.\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n  cout << \"Hello World!\\n\";\n}\n```\n\nThe classifier program should compile and run.\n```console\n$ make classifier.exe\n$ ./classifier.exe\nHello World!\n```\n\nConfigure your IDE to debug the classifier program.\n\n<table>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/classifier.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/classifier.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `classifier.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `classifier.cpp`\n  - Exclude any other tests\n  </td>\n</tr>\n</table>\n\nConfigure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)). We recommend starting with the smallest input in train-only mode, `train_small.csv`.\n\nTo compile and run the smallest input at the command line:\n```console\n$ make classifier.exe\n$ ./classifier.exe train_small.csv\n```\n\n### Command Line Interface\n\nHere is the usage message for the top-level application:\n```console\n$ ./classifier.exe\nUsage: classifier.exe TRAIN_FILE [TEST_FILE]\n```\n\nThe classifier application always requires a file for training, and it optionally takes a file for testing. The training file must have at least one post, but the test file may have no posts. You may assume all files are in the correct format, with a header that has at least the \"tag\" and \"content\" columns.\n\nUse the provided small-scale files for initial testing and to check your output formatting:\n\n```console\n$ ./classifier.exe train_small.csv\n$ ./classifier.exe train_small.csv test_small.csv\n```\n\nCorrect output is in `train_small_train_only.out.correct` and\n`test_small.out.correct`. The output format is discussed in detail below.\n\n#### Error Checking\n\nThe program checks that the command line arguments obey the following\nrule:\n\n- There are 2 or 3 arguments, including the executable name itself\n  (i.e. `argv[0]`).\n\nIf this is violated, print out the usage message and then quit\nby returning a non-zero value from `main`. **Do not use the `exit`\nlibrary function, as this fails to clean up local objects.**\n\n```c++\ncout << \"Usage: classifier.exe TRAIN_FILE [TEST_FILE]\" << endl;\n```\n{: data-variant=\"no-line-numbers\" }\n\nIf any file cannot be opened, print out the following message, where\n`filename` is the name of the file that could not be opened, and quit by\nreturning a non-zero value from `main`.\n\n```c++\ncout << \"Error opening file: \" << filename << endl;\n```\n{: data-variant=\"no-line-numbers\" }\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** The `csvstream` constructor will throw a `csvstream_exception` containing the correct error message if a file cannot be opened. The example at [https://github.com/awdeorio/csvstream#error-handling](https://github.com/awdeorio/csvstream#error-handling) shows how to handle the exception with a `try`/`catch` block.\n</div>\n\nYou do not need to do any error checking for command-line arguments or\nfile I/O other than what is described on this page. However, you must\nuse precisely the error messages given here in order to receive credit.\n(**Just literally use the code given here to print them.**)\n\nAs mentioned earlier, you may assume all Piazza data files are in the\ncorrect format.\n\n### Design\n\nHere is some high-level guidance:\n\n1.  First, your application should read posts from a file (e.g.\n    `train_small.csv`) and use them to train the classifier. After\n    training, your classifier abstraction should store the information\n    mentioned in the [Training](#training) section.\n2.  Your classifier should be able to compute the log-probability\n    score of a post (i.e. a collection of words) given a particular\n    label. To predict a label for a new post, it should choose the label\n    that gives the highest log-probability score.  See the [Prediction](#prediction) section.\n3.  Read posts from a file (e.g. `test_small.csv`) to use as testing\n    data. For each post, predict a label using your classifier.\n\nSome of these steps have output associated with them. See the \"output\"\nsection below for the details.\n\nThe structure\nof your classifier application, including which procedural abstractions\nand/or ADTs to use for the classifier, is entirely up to you. Make sure\nyour decisions are informed by carefully considering the classifier and\ntop-level application described in this specification.\n\nWe **strongly** suggest you make a class to represent the classifier - the\nprivate data members for the class should keep track of the classifier\nparameters learned from the training data, and the public member\nfunctions should provide an interface that allows you to train the\nclassifier and make predictions for new piazza posts.\n\nYou should write RMEs and appropriate comments to describe the\ninterfaces for the abstractions you choose (ADTs, classes, functions,\netc.). You should also write unit tests to verify each component works\non its own.\n\nYou are welcome to use any part of the C++ standard library in your top-level classifier\napplication. See our [C++ Standard Library Containers](containers.html) reference for a description of several containers and examples of how to use them. In particular, `std::map` and `std::set` will be\nuseful for this project.\n\n### Example\n\nWe've provided full example output for a small input (`train_small.csv` and `test_small.csv`).  The output is in `test_small.out.correct`.  The output in train-only mode is in `train_small_train_only.out.correct`, here we've indicated train-only output with \"(TRAIN-ONLY)\".  Some lines are indented by two spaces.\n\nTo run this example at the command line in train-only mode:\n```console\n$ make classifier.exe\n$ ./classifier.exe train_small.csv\n```\n\nTo run with test data and generate predictions:\n```console\n$ ./classifier.exe train_small.csv test_small.csv\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Debug output differences with `diff -y -B`, which shows differences side-by-side and ignores whitespace.  We'll use the `less` pager so we can scroll through the long terminal output.  Press `q` to quit.\n```console\n$ make classifier.exe\n$ ./classifier.exe train_small.csv > train_small_train_only.out\n$ diff -y -B train_small_train_only.out train_small_train_only.out.correct | less  # q to quit\n```\n</div>\n\nAdd this line at the beginning of your `main` function to set floating\npoint precision:\n\n```c++\ncout.precision(3);\n```\n{: data-variant=\"no-line-numbers\" }\n\nFirst, print information about the training data:\n\n- (TRAIN-ONLY) Line-by-line, the label and content for each training document.\n  ```\n  training data:\n    label = euchre, content = can the upcard ever be the left bower\n    label = euchre, content = when would the dealer ever prefer a card to the upcard\n    label = euchre, content = bob played the same card twice is he cheating\n    ...\n    label = calculator, content = does stack need its own big three\n    label = calculator, content = valgrind memory error not sure what it means\n  ```\n  {: data-variant=\"no-line-numbers\" }\n- The number of training posts.\n  ```\n  trained on 8 examples\n  ```\n  {: data-variant=\"no-line-numbers\" }\n- (TRAIN-ONLY) The vocabulary size (the number of unique words in all training content).\n  ```\n  vocabulary size = 49\n  ```\n  {: data-variant=\"no-line-numbers\" }\n- An extra blank line\n\nIn train-only mode, also print information about the classifier\ntrained on the training posts. Whenever classes or words are listed,\nthey are in alphabetic order.\n\n- (TRAIN-ONLY) The classes in the training data, and the number of examples for each.\n  ```\n  classes:\n    calculator, 3 examples, log-prior = -0.981\n    euchre, 5 examples, log-prior = -0.47\n  ```\n  {: data-variant=\"no-line-numbers\" }\n- (TRAIN-ONLY) For each label, and for each word that occurs for that label: The\n  number of posts with that label that contained the word, and the\n  log-likelihood of the word given the label.\n  ```\n  classifier parameters:\n    calculator:assert, count = 1, log-likelihood = -1.1\n    calculator:big, count = 1, log-likelihood = -1.1\n    ...\n    euchre:twice, count = 1, log-likelihood = -1.61\n    euchre:upcard, count = 2, log-likelihood = -0.916\n    ...\n   ```\n   {: data-variant=\"no-line-numbers\" }\n- (TRAIN-ONLY) An extra blank line\n\nFinally, if a test file is provided, use the classifier to predict\nclasses for each example in the testing data. Print information about\nthe test data as well as these predictions.\n\n- Line-by-line, the \"correct\" label, the predicted label and its log-probability\n  score, and the content for each test. Insert a blank line after each for\n  readability.\n  ```\n  test data:\n    correct = euchre, predicted = euchre, log-probability score = -13.7\n    content = my code segfaults when bob is the dealer\n\n    correct = euchre, predicted = calculator, log-probability score = -12.5\n    content = no rational explanation for this bug\n\n    correct = calculator, predicted = calculator, log-probability score = -13.6\n    content = countif function in stack class not working\n  ```\n  {: data-variant=\"no-line-numbers\" }\n- The number of correct predictions and total number of test posts.\n  ```\n  performance: 2 / 3 posts predicted correctly\n  ```\n  {: data-variant=\"no-line-numbers\" }\n\nThe last thing printed should be a newline character.\n\n### Accuracy\n\nIn case you're curious, here's the accuracy for the large datasets. Not too bad!\n\n|                               Command                                |  Accuracy   |\n| -------------------------------------------------------------------- | ----------- |\n| `./classifier.exe w16_projects_exam.csv sp16_projects_exam.csv`              | 245 / 332   |\n| `./classifier.exe w14-f15_instructor_student.csv w16_instructor_student.csv` | 2602 / 2988 |\n\n### Efficiency\n\nWhile efficiency is not a primary goal for this project, you should\naim for your code to run the largest test case above in no more than a\nminute. Some common causes of slowdown you should avoid:\n\n- Processing a post more than once (including reading it more than\n  once or saving all the data in a vector).\n- Iterating over a map to find something rather than using `[]` or `find()`.\n- Passing strings, pairs, or containers by value.\n- Iterating by value in a range-based for loop.\n\nRefer to the [Project 2 perf\ntutorial](https://eecs280staff.github.io/p2-cv/perf.html)\nfor instructions on how to use the `perf` tool to identify slow\nfunctions.\n\n## Submission and Grading\n\nSubmit these files to the [autograder](https://autograder.io).\n  - `classifier.cpp`\n\nThis project will be autograded for correctness and programming style. See the [style checking\ntutorial](https://eecs280staff.github.io/p1-stats/setup_style.html)\nfor the criteria and how to check your style automatically on CAEN.\n\n### Testing\n\nRun all the tests.  For this project, the tests only consist of system tests.\n\n```console\n$ make test\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Run commands in parallel with `make -j`.\n```console\n$ make -j4 test\n```\n{: data-variant=\"no-line-numbers\" }\n</div>\n\n### Requirements and Restrictions\n\n| DO | DO NOT |\n| -- | ------ |\n| Put all top-level application code in `classifier.cpp`. | Create additional files other than `classifier.cpp`. |\n| Create any ADTs or functions you wish for your top-level classifier application. | Write everything in the `main()` function. |\n| Use any part of the C++ standard library for your top level classifier application, including `map` and `set`. | Write your own implementation of maps and sets -- they will likely be too slow. |\n| Follow course style guidelines. | Use non-const static or global variables. |\n| [Check for undefined behavior](https://eecs280staff.github.io/p1-stats/setup_asan.html#p1-stats) using address sanitizer and other tools | \"It runs fine on my machine!\" |\n\n\n## Acknowledgments\n\nAndrew DeOrio and James Juett wrote the original project and specification. Amir Kamil contributed to code structure, style, and implementation details. This project was developed for EECS 280, Fall 2016 at the University of Michigan. The classifer was forked into a separate project in Fall 2024.\n", "extracted_entities": ["EECS 280", "Winter 2025", "March 28, 2024", "Piazza", "Project 3", "Euchre", "train_small.csv", "test_small.csv", "w16_projects_exam.csv", "sp16_projects_exam.csv", "w14-f15_instructor_student.csv", "w16_instructor_student.csv", "csvstream.hpp", "Makefile", "Multi-Variate Bernoulli Naive Bayes Classifier", "C++", "GitHub", "Valgrind"], "extracted_triples": [["EECS 280", "has project", "Project 3"], ["EECS 280", "is scheduled for", "Winter 2025"], ["Project 3", "is due on", "March 28, 2024"], ["Piazza", "is used for", "EECS 280"], ["Project 3", "is about", "Euchre"], ["train_small.csv", "is a dataset for", "classifier"], ["test_small.csv", "is a dataset for", "classifier"], ["w16_projects_exam.csv", "is a dataset for", "classifier"], ["sp16_projects_exam.csv", "is a dataset for", "classifier"], ["w14-f15_instructor_student.csv", "is a dataset for", "classifier"], ["w16_instructor_student.csv", "is a dataset for", "classifier"], ["csvstream.hpp", "is a library for", "reading CSV files"], ["Makefile", "contains", "helper commands for building"], ["Multi-Variate Bernoulli Naive Bayes Classifier", "is a type of", "classifier"], ["C++", "is the programming language for", "classifier"], ["GitHub", "is a platform for", "version control"], ["Valgrind", "is a tool for", "memory debugging"]]}, {"idx": "chunk-88c3276aa3d516a88e6627f42cbd462f", "passage": "---\nlayout: spec\nlatex: true\nmermaid: true\n---\n\nEECS 280 Project 6: Binary Search Trees and Maps\n================================================\n{: .primer-spec-toc-ignore }\n\nFall 2024 release.\n\nProject due 8:00pm EST Monday December 9, 2024.\n\nYou may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)). If you work alone, you must work alone on both the checkpoint and the full project. If you work with a partner, you must work with the same partner on the checkpoint and the full project. You may not work alone on the checkpoint and then add a partner for the full project.\n\n## Introduction\n\nIn this project, you implement a map container (similar to `std::map`) based on an underlying binary search tree data structure. The learning goals of this project include functors, templates, recursion, binary search trees, and associative containers.\n\n## Setup\nSet up your visual debugger and version control, then submit to the autograder.\n\n### Visual debugger\nDuring setup, name your project `bst-map`. Use this starter files link: `https://eecs280staff.github.io/bst-map/starter-files.tar.gz`\n\n| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |\n\nYou should end up with a folder with starter files that look like this.  You may have already renamed files like `Map.hpp.starter` to `Map.hpp`. You may also have a `main.cpp` file after following the setup tutorial. If so, delete the file.\n```console\n$ ls\nBinarySearchTree.hpp.starter\t\tMap_compile_check.cpp\nBinarySearchTree_compile_check.cpp\tMap_public_tests.cpp\nBinarySearchTree_public_tests.cpp\tMap_tests.cpp.starter\nBinarySearchTree_tests.cpp.starter\tTreePrint.hpp\nMakefile\t\t\t\t\t\t\tunit_test_framework.hpp\nMap.hpp.starter\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each starter file.\n\n| File(s) | Description |\n| ------- | ----------- |\n| `BinarySearchTree.hpp.starter` | Starter code for `BinarySearchTree`. |\n| `BinarySearchTree_tests.cpp.starter` | Your `BinarySearchTree` unit tests. |\n| `BinarySearchTree_public_tests.cpp` | A small test for `BinarySearchTree` |\n| `BinarySearchTree_compile_check.cpp` | Compile check test for `BinarySearchTree` |\n| `TreePrint.hpp` | Test helper function for printing trees. |\n| `Map.hpp.starter` | Starter code for `Map`. |\n| `Map_tests.cpp.starter` | Your `Map` unit tests. |\n| `Map_public_tests.cpp` | Your `Map` unit tests. |\n| `Map_compile_check.cpp` | Compile check test for `Map`. |\n| `Makefile` | Helper commands for building. |\n| `unit_test_framework.hpp` | A simple unit-testing framework. |\n\n### Version control\nSet up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).\n\nAfter you're done, you should have a local repository with a \"clean\" status and your local repository should be connected to a remote GitHub repository.\n```console\n$ git status\nOn branch main\nYour branch is up-to-date with 'origin/main'.\n\nnothing to commit, working tree clean\n$ git remote -v\norigin\thttps://github.com/awdeorio/bst-map.git (fetch)\norigin\thttps://githubcom/awdeorio/bst-map.git (push)\n```\n\nYou should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).\n```console\n$ head .gitignore\n# This is a sample .gitignore file that's useful for C++ projects.\n...\n```\n\n### Group registration\nRegister your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.\n\n\n## BinarySearchTree\n\nA binary search tree supports efficiently storing and searching for\nelements.\n\nWrite implementations in `BinarySearchTree.hpp` for each `_impl` function.  The file already contains function stubs and you should replace the `assert(false)` with your code.  For example:\n```c++\nstatic bool empty_impl(const Node *node) {\n  assert(false);  // Replace with your code\n}\n```\n{: data-title=\"BinarySearchTree.hpp\" }\n\nRun the public Binary Search Tree tests.\n```console\n$ make BinarySearchTree_compile_check.exe\n$ make BinarySearchTree_public_tests.exe\n$ ./BinarySearchTree_public_tests.exe\n```\n\nWrite tests for `BinarySearchTree` in `BinarySearchTree_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make BinarySearchTree_tests.exe\n$ ./BinarySearchTree_tests.exe\n```\n\nSubmit `BinarySearchTree.hpp` and `BinarySearchTree_tests.cpp` to the [autograder](https://autograder.io).\n\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `BinarySearchTree.hpp.starter` -> `BinarySearchTree.hpp`\n-  `BinarySearchTree_tests.cpp.starter` -> `BinarySearchTree_tests.cpp`\n\nThe BinarySearchTree tests should compile and run. The public tests and compile check will fail until you implement the functions.  The test you write (`BinarySearchTree_tests.cpp`) will pass because the starter file only contains `ASSERT_TRUE(true)`.\n```console\n$ make BinarySearchTree_compile_check.exe\n$ make BinarySearchTree_public_tests.exe\n$ ./BinarySearchTree_public_tests.exe\n$ make BinarySearchTree_tests.exe\n$ ./BinarySearchTree_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/BinarySearchTree_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/BinarySearchTree_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/BinarySearchTree_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/BinarySearchTree_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `BinarySearchTree_public_tests.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `BinarySearchTree_tests.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `BinarySearchTree_public_tests.cpp`\n  - Exclude any other tests\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `BinarySearchTree_tests.cpp`\n  - Exclude any other tests\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Template Parameters\n\n`BinarySearchTree` has two template parameters:\n\n  - `T` - The type of elements stored within the tree.\n  - `Compare` - The type of comparator object (a functor) that should be\n    used to determine whether one element is less than another. The\n    default type is `std::less<T>`, which compares two `T` objects with\n    the `<` operator. To compare elements in a different fashion, a\n    custom comparator type must be specified.\n\n### No Duplicates Invariant\n\nIn the context of this project, duplicate values are NOT allowed in a\nBST. This does not need to be the case, but it avoids some distracting\ncomplications.\n\n### Sorting Invariant\n\nA binary search tree is special in that the structure of the tree\ncorresponds to a sorted ordering of elements and allows efficient\nsearches (i.e. in logarithmic time).\n\nEvery node in a well-formed binary search tree must obey this sorting\ninvariant:\n\n- It represents an empty tree (i.e. a null `Node*`).\n\n\\- OR -\n\n- The left subtree obeys the sorting invariant, and every element in\n  the left subtree is less than the root element (i.e. this node).\n\n  \\- AND -\n\n  The right subtree obeys the sorting invariant, and the root element\n  (i.e. this node) is less than every element in the right subtree.\n\nPut briefly, go left and you'll find smaller elements. Go right and\nyou'll find bigger ones. For example, the following are all well-formed\nsorted binary trees:\n\n<!--\n```\n      4                1\n    /   \\             / \\\n   2      6               2\n  / \\    / \\             / \\\n 1   3  5   7               4\n/ \\ / \\/ \\ / \\             / \\\n```\n{: data-variant=\"no-line-numbers\" }\n-->\n\n```mermaid\nflowchart TB\n  %% Binary tree 2\n  subgraph tree2[\"Valid\"]\n    direction TB\n    tree2_1((1)) --> tree2_1_L((\" \")) & tree2_2((2))\n    tree2_2 --> tree2_2_L((\" \")) & tree2_4((4))\n    tree2_4 --> tree2_4_L((\" \")) & tree2_4_R((\" \"))\n  end\n\n  %% Binary tree 1\n  subgraph tree1[\"Valid\"]\n    direction TB\n    tree1_4((4)) --> tree1_2((2)) & tree1_6((6))\n    tree1_2 --> tree1_1((1)) & tree1_3((3))\n    tree1_1 --> tree1_1_L((\" \")) & tree1_1_R((\" \"))\n    tree1_3 --> tree1_3_L((\" \")) & tree1_3_R((\" \"))\n\n    tree1_6 --> tree1_5((5)) & tree1_7((7))\n    tree1_5 --> tree1_5_L((\" \")) & tree1_5_R((\" \"))\n    tree1_7 --> tree1_7_L((\" \")) & tree1_7_R((\" \"))\n  end\n```\n\nWhile the following are not:\n\n<!--\n```\n   1          1              4               3\n  / \\        / \\            /  \\            /  \\\n 2          2   3          3    6          2    7\n/ \\        / \\ / \\        / \\    \\        / \\\n                         2   1    7      1   5\n                        / \\ / \\  / \\    / \\ / \\\n```\n{: data-variant=\"no-line-numbers\" }\n-->\n\n```mermaid\nflowchart TB\n  %% Binary tree 4\n  subgraph tree4[\"Invalid\"]\n    direction TB\n    tree4_3((3)) --> tree4_2((2)) & tree4_7((7))\n    tree4_2 --> tree4_1((1)) & tree4_5((5))\n    tree4_1 --> tree4_1_L((\" \")) & tree4_1_R((\" \"))\n    tree4_5 --> tree4_5_L((\" \")) & tree4_5_R((\" \"))\n  end\n\n  %% Binary tree 3\n  subgraph tree3[\"Invalid\"]\n    direction TB\n    tree3_4((4)) --> tree3_3((3)) & tree3_6((6))\n    tree3_3 --> tree3_2((2)) & tree3_1((1))\n    tree3_2 --> tree3_2_L((\" \")) & tree3_2_R((\" \"))\n    tree3_1 --> tree3_1_L((\" \")) & tree3_1_R((\" \"))\n\n    tree3_6 --> tree3_7((7))\n    tree3_7 --> tree3_7_L((\" \")) & tree3_7_R((\" \"))\n  end\n\n  %% Binary tree 2\n  subgraph tree2[\"Invalid\"]\n    direction TB\n    tree2_1((1)) --> tree2_2((2)) & tree2_3((3))\n    tree2_2 --> tree2_2_L((\" \")) & tree2_2_R((\" \"))\n    tree2_3 --> tree2_3_L((\" \")) & tree2_3_R((\" \"))\n  end\n\n  %% Binary tree 1\n  subgraph tree1[\"Invalid\"]\n    direction TB\n    tree1_1((1)) --> tree1_2((2)) & tree1_1_R((\" \"))\n    tree1_2 --> tree1_2_L((\" \")) & tree1_2_R((\" \"))\n  end\n```\n\n**ProTip:** When writing tests for `check_sorting_invariant()`, you can use\nan iterator to break the invariant. For example:\n\n```cpp\nBinarySearchTree<int> b;\nb.insert(1);\nb.insert(0);\n// change first datum to 2, resulting in the first broken tree above\n*b.begin() = 2;\nASSERT_FALSE(b.check_sorting_invariant());\n```\n\n### Data Representation\n\nThe data representation for `BinarySearchTree` is a tree-like structure of\nnodes similar to that described in lecture. Each `Node` contains an\nelement and pointers to left and right subtrees. The structure is\nself-similar. A null pointer indicates an empty tree. **You must use this\ndata representation. Do not add member variables to `BinarySearchTree` or\n`Node`.**\n\n### Public Member Functions and Iterator Interface\n\nThe public member functions and iterator interface for\n`BinarySearchTree` are already implemented in the starter code. DO NOT\nmodify the code for any of these functions. They delegate the work to\nprivate, static implementation functions, which you will write.\n\n### Implementation Functions\n\nThe core of the implementation for `BinarySearchTree` is a collection of\nprivate, static member functions that operate on tree-like structures of\nnodes. **You are responsible for writing the implementation of several of\nthese functions.**\n\nTo disambiguate these implementation functions from the public interface\nfunctions, we have used names ending with `_impl`. (This is not\nstrictly necessary, because the compiler can differentiate them based on\nthe `Node*` parameter.)\n\nThere are a few keys to thinking about the implementation of these\nfunctions:\n\n  - **The functions have no idea that such a thing as the `BinarySearchTree`\n    class exists**, and they shouldn't. A \"tree\" is not a class, but\n    simply a tree-shaped structure of `Node`s. The parameter node points\n    to the root of these nodes.\n  - A recursive implementation depends on the idea of **similar subproblems**,\n    so a \"subtree\" is just as much a tree as the \"whole tree\". That means you\n    shouldn't need to think about \"where you came from\" in your implementation.\n  - Every function should have a **base case**! Start by writing this part.\n  - You only need to think about one \"level\" of recursion at a time.\n    Avoid thinking about the contents of subtrees and **take the recursive\n    leap of faith**.\n\nWe've structured the starter code so that the first bullet point above\nis actually enforced by the language. Because they are `static` member\nfunctions, they do not have access to a receiver object (i.e. there's no\n`this` pointer). That means it's actually impossible for these functions\nto try to do something bad with the `BinarySearchTree` object (e.g. trying\nto access the `root` member variable).\n\nInstead, the implementation functions are called from the regular member\nfunctions to perform specific operations on the underlying nodes and\ntree structure, and are passed only a pointer to the root `Node` of the\ntree/subtree they should work with.\n\nThe `empty_impl` function must run in constant time. It must must be able\nto determine and return its result immediately, without using either\niteration or recursion. The rest of the implementation functions must be\nrecursive. There are additional requirements on the kind of recursion\nthat must be used for some functions. See comments in the starter code\nfor details. **Iteration (i.e. using loops) is not allowed in any of the\n`_impl` functions**.\n\n#### Using the Comparator\n\nThe `_impl` functions that need to compare data take in a comparator\nparameter called `less`. Make sure to use `less` rather than the `<` operator\nto compare elements\\!\n\n#### The `insert_impl` Function\n\nThe key to properly maintaining the sorting invariant lies in the\nimplementation of the `insert_impl` function - this is essentially where\nthe tree is built, and this function will make or break the whole ADT.\nYour `insert_impl` function should follow this procedure:\n\n1.  Handle an originally empty tree as a special case.\n2.  Insert the element into the appropriate place in the tree, keeping\n    in mind the sorting invariant. You'll need to compare elements for\n    this, and to do so make sure to use the `less` comparator passed in as\n    a parameter.\n3.  Use the recursive leap of faith and call `insert_impl` itself on the\n    left or right subtree. Hint: You **do** need to use the return value of\n    the recursive call. (Why?)\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Important:** When recursively inserting an item into the left or right\nsubtree, be sure to replace the old left or right pointer of the current\nnode with the result from the recursive call. This is essential, because\nin some cases the old tree structure (i.e. the nodes pointed to by the\nold left or right pointer) is not reused. Specifically, if the subtree\nis empty, the only way to get the current node to \"know\" about the newly\nallocated node is to use the pointer returned from the recursive call.\n</div>\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Technicality:** In some cases, the tree structure may become unbalanced\n(i.e. too many nodes on one side of the tree, causing it to be much deeper\nthan necessary) and prevent efficient operation for large trees. You\ndon't have to worry about this.\n</div>\n\n### Testing\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** When writing tests for functions that return a `size_t` (which is an unsigned integer type), compare against an unsigned literal. For example:\n\n```cpp\nBinarySearchTree<int> b;\nASSERT_EQUAL(b.height(), 0u);\n```\n</div>\n\n## Map\n\nWrite a map abstract data type (ADT). Map is an *associative container*, and works just like `std::map`.\n\nWrite implementations at the end of `Map.hpp` for the functions declared at the beginning of `Map.hpp`. The most important functions are `find`, `insert`, and the `[]` operator.  \n\nYour implementations should not require much code. Reuse the functionality provided by `BinarySearchTree`.\n\nRun the public Map tests.\n```console\n$ make Map_compile_check.exe\n$ make Map_public_tests.exe\n$ ./Map_public_tests.exe\n```\n\nWrite tests for `Map` in `Map_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/). While you should write your own tests for `Map` to ensure that your implementation is correct, you do not have to submit your tests to the autograder.\n```console\n$ make Map_tests.exe\n$ ./Map_tests.exe\n```\n\nSubmit `Map.hpp` to the [autograder](https://autograder.io).  Don't forget to include the code you finished earlier, `BinarySearchTree.hpp` and `BinarySearchTree_tests.cpp`.\n\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Map.hpp.starter` -> `Map.hpp`\n-  `Map_tests.cpp.starter` -> `Map_tests.cpp`\n\nEdit `Map.hpp`, adding a function stub for every function prototype in `Map`.  Here are a few examples to get you started.  We're using `K`, `V`, and `C` as shorthands for `Key_type`, `Value_type`, and `Key_compare`.\n```c++\ntemplate <typename K, typename V, typename C>\nbool Map<K, V, C>::empty() const {\n  assert(false);\n}\n\ntemplate <typename K, typename V, typename C>\ntypename Map<K, V, C>::Iterator Map<K, V, C>::find(const K& k) const {\n  assert(false);\n}\n\ntemplate <typename K, typename V, typename C>\nV& Map<K, V, C>::operator[](const K& k) {\n  assert(false);\n}\n\ntemplate <typename K, typename V, typename C>\nstd::pair<typename Map<K, V, C>::Iterator, bool> Map<K, V, C>::insert(const Pair_type &val) {\n  assert(false);\n}\n```\n\nNow you should be able to compile and run the Map unit tests.  The public tests will fail until you implement the functions.\n```console\n$ make Map_compile_check.exe\n$ make Map_public_tests.exe\n$ ./Map_public_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.  Writing your own tests for Map is optional.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Map_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Map_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Map_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Map_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Map_public_tests.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Map_tests.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Map_public_tests.cpp`\n  - Exclude any other tests\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Map_tests.cpp`\n  - Exclude any other tests\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Map Examples\nA map is an *associative container*.  It stores two types, key and value.  Our map works just like `std::map`.\n```c++\nMap<string, double> words;\nstd::map<string, double> words;\n```\n{: data-variant=\"no-line-numbers\" }\n\nOne way to use a map is a lot like an array.\n```c++\nwords[\"hello\"] = 1;\n```\n{: data-variant=\"no-line-numbers\" }\n\nMaps store a `std::pair` type, which \"glues\" one key to one value. The computer science term is Tuple, a fixed-size heterogeneous container.\n```c++\npair<string, double> tuple;\ntuple.first = \"world\";\ntuple.second = 2;\nwords.insert(tuple);\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a more compact way to insert a pair.\n```c++\nwords.insert({\"pi\", 3.14159});\n```\n{: data-variant=\"no-line-numbers\" }\n\nThe range-for loop makes it easier to iterate over a map.\n```c++\nfor (const auto &kv : words) {\n  const auto &word = kv.first; //key\n  auto number = kv.second; //value\n  cout << word << \" \" << number << endl;\n}\n```\n{: data-variant=\"no-line-numbers\" }\n\nYou can check if a key is in the map.  The `find()` function returns an iterator.\n```c++\nauto found_it = words.find(\"pi\");\nif (found_it != words.end()) {\n  const auto &word = (*found_it).first; //key\n  auto number = (*found_it).second; //value\n  cout << \"found \" << word << \" \" << number << endl;\n}\n```\n{: data-variant=\"no-line-numbers\" }\n\nWhen using the `[]` notation, an element not found is automatically created.  If the value type of the map is numeric, it will always be `0` by default.\n```c++\ncout << \"bleh: \" << words[\"bleh\"] << endl;\n```\n{: data-variant=\"no-line-numbers\" }\n\n### Building on the BST\n\nThe operation of a map is quite similar to that of a BST. The additional\nconsideration for a map is that we want to store key-value pairs instead\nof single elements, but also have any comparisons (e.g. for searching)\nonly depend on the key and be able to freely change the stored values\nwithout messing up the BST sorting invariant. We can employ the has-a\npattern using a `BinarySearchTree` as the data representation for Map:\n\n- BST template parameter: `T`\n\n  Instantiate with: `Pair_type`\n\n  We've provided a using declaration in the starter code for `Pair_type`:\n\n  `using Pair_type = std::pair<Key_type, Value_type>;`\n\n  `std::pair` is basically like a struct that stores two objects together.\n   `Key_type` and `Value_type` are whatever template parameters were used to\n   instantiate `Map`.\n\n- BST template parameter: `Compare`\n\n  Instantiate with: `PairComp`\n\n  You'll need to define your own comparator by declaring a functor\n  type called `PairComp` (or whatever you want to call it) in your\n  `Map` class. The overloaded `()` operator should accept two objects of\n  `Pair_type` and return whether the key of the LHS is less than the\n  key of the RHS (according to `Key_compare`).\n\nFinally, we can even reuse the iterators from the BST class, since the\ninterface we want (based on `std::map`) calls for iterators to yield a\nkey-value pair when dereferenced. Since the element type `T` of the BST is\nour `Pair_type`, BST iterators will yield pairs and will work just fine.\nWe've provided this `using` declaration with the starter code to make\n`Map::Iterator` simply an alias for iterators from the corresponding BST:\n\n```c++\nusing Iterator = typename BinarySearchTree<Pair_type, PairComp>::Iterator;\n```\n{: data-variant=\"no-line-numbers\" }\n\n## Submission and Grading\n\nSubmit these files to the [autograder](https://autograder.io).\n  - `BinarySearchTree.hpp`\n  - `BinarySearchTree_tests.cpp`\n  - `Map.hpp`\n\nYou do not have to submit `Map_tests.cpp` to the autograder.\n\nThis project will be autograded for correctness, comprehensiveness of\nyour test cases, and programming style. See the [style checking\ntutorial](https://eecs280staff.github.io/p1-stats/setup_style.html)\nfor the criteria and how to check your style automatically on CAEN.\n\n### Testing\n\nRun all the unit tests.  This includes the public tests we provided and the unit tests that you wrote.\n\n```console\n$ make test\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Run commands in parallel with `make -j`.\n```console\n$ make -j4 test\n```\n{: data-variant=\"no-line-numbers\" }\n</div>\n\n### Unit Test Grading\n\nWe will autograde your `BinarySearchTree` unit tests.\n\nYour unit tests must use the [unit test framework](https://eecs280staff.github.io/unit_test_framework/).\n\nA test suite must complete less than 5 seconds and contain 50 or fewer `TEST()` items.  One test suite is one `_tests.cpp` file.\n\nTo grade your unit tests, we use a set of intentionally buggy instructor solutions.  You get points for catching the bugs.\n\n1.  We compile and run your unit tests with a **correct solution**.\n    - Tests that pass are **valid**.\n    - Tests that fail are **invalid**, they falsely report a bug.\n3.  We compile and run all of your **valid** tests against each **buggy solution**.\n    - If any of your tests fail, you caught the bug.\n    - You earn points for each bug that you catch.\n\n### Requirements and Restrictions\n\n| DO | DO NOT |\n| -- | ------ |\n| Create any private helper functions you want. | Modify the `BinarySearchTree` or `Map` public interfaces |\n| Use any part of the STL except for containers in your `BinarySearchTree` and `Map` implementations. | Use STL containers in your implementation of `BinarySearchTree` or `Map`. |\n| Use recursion for the BST `_impl` functions. | Use iteration for the BST `_impl` functions. |\n| Follow course style guidelines. | Use non-const static or global variables. |\n| [Check for undefined behavior](https://eecs280staff.github.io/p1-stats/setup_asan.html#p1-stats) using address sanitizer and other tools | \"It runs fine on my machine!\" |\n\n\n## Acknowledgments\n\nAndrew DeOrio and James Juett wrote the original project and specification. Amir Kamil contributed to code structure, style, and implementation details. This project was developed for EECS 280, Fall 2016 at the University of Michigan. The classifier portion was split into a separate project in Fall 2024.\n", "extracted_entities": ["EECS 280", "Fall 2024", "December 9, 2024", "std::map", "BinarySearchTree", "Map", "VS Code", "Visual Studio", "Xcode", "Autograder", "Unit Test Framework", "Pair_type", "Key_type", "Value_type", "Key_compare"], "extracted_triples": [["EECS 280", "is scheduled for", "Fall 2024"], ["Project", "due on", "December 9, 2024"], ["Project", "is about", "Binary Search Trees and Maps"], ["BinarySearchTree", "is similar to", "std::map"], ["Map", "is an", "associative container"], ["VS Code", "is a tool for", "setup"], ["Visual Studio", "is a tool for", "setup"], ["Xcode", "is a tool for", "setup"], ["Autograder", "is used for", "submitting code"], ["Unit Test Framework", "is used for", "testing"], ["Pair_type", "is a type of", "std::pair"], ["Key_type", "is a type used in", "Map"], ["Value_type", "is a type used in", "Map"], ["Key_compare", "is a type used in", "Map"]]}, {"idx": "chunk-836e0dd33c346d6ab2b7bc8da851257d", "passage": "---\nlayout: spec\nmermaid: true\n---\n\nEECS 280 Project 3: Euchre\n==========================\n{: .primer-spec-toc-ignore }\n\nWinter 2025 release.\n\nCheckpoint due 8:00pm EST Monday February 24, 2025.  See [Submission and Grading / Checkpoint](#checkpoint).\n\nFull project due 8:00pm EST Wednesday March 12, 2025.\n\nYou may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)). If you work alone, you must work alone on both the checkpoint and the full project. If you work with a partner, you must work with the same partner on the checkpoint and the full project. You may not work alone on the checkpoint and then add a partner for the full project.\n\n<!--\n## Change Log\n\n-->\n\n## Introduction\nEuchre (pronounced \"YOO-kur\") is a card game popular in Michigan.\n\nThe learning goals of this project include Abstract Data Types in C++, Derived Classes, Inheritance, and Polymorphism.  You'll gain practice with C++-style Object Oriented Programming (OOP) with classes and virtual functions.\n\nWhen you're done, you'll have a program that simulates a game of Euchre, supporting a AI player and a Human player.\n```console\n$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Simple Kunle Simple Liskov Simple\nHand 0\nIvan deals\nJack of Diamonds turned up\nJudea passes\nKunle passes\nLiskov passes\nHuman player Ivan's hand: [0] Nine of Diamonds\nHuman player Ivan's hand: [1] Ten of Diamonds\nHuman player Ivan's hand: [2] Jack of Hearts\nHuman player Ivan's hand: [3] Queen of Hearts\nHuman player Ivan's hand: [4] Ace of Clubs\nHuman player Ivan, please enter a suit, or \"pass\":\nDiamonds\nIvan orders up Diamonds\n...\n```\n{: data-variant=\"legacy\" }\n\n\n## Setup\nSet up your visual debugger and version control, then submit to the autograder.\n\n### Visual debugger\nDuring setup, name your project `p3-euchre`. Use this starter files link: `https://eecs280staff.github.io/euchre/starter-files.tar.gz`\n\n| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |\n\nIf you created a `main.cpp` while following the setup tutorial, rename it to `euchre.cpp`. Otherwise, create a new file `euchre.cpp`.  You should end up with a folder with starter files that looks like this.  You may have already renamed files like `Card.cpp.starter` to `Card.cpp`.\n```console\n$ ls\nCard.cpp.starter        Pack_public_tests.cpp     euchre_test00.out.correct\nCard.hpp                Pack_tests.cpp.starter    euchre_test01.out.correct\nCard_public_tests.cpp   Player.hpp                euchre_test50.in\nCard_tests.cpp.starter  Player_public_tests.cpp   euchre_test50.out.correct\nMakefile                Player_tests.cpp.starter  pack.in\nPack.hpp                euchre.cpp                unit_test_framework.hpp\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each starter file.\n\n| File(s) | Description |\n| ------- | ----------- |\n| `Card.hpp` | Abstraction representing a playing card. |\n| `Card.cpp.starter` | Starter code for the `Card`. |\n| `Card_tests.cpp` | Your `Card` unit tests. |\n| `Card_public_tests.cpp` | Compile check test for `Card.cpp`. |\n| `Pack.hpp` | Abstraction representing a pack cards. |\n| `Pack_tests.cpp` | Add your `Pack` unit tests to this file. |\n| `Pack_public_tests.cpp` | Compile check test for `Pack.cpp`. |\n| `Player.hpp` | Abstraction representing a euchre player. |\n| `Player_tests.cpp` | Your `Player` unit tests. |\n| `Player_public_tests.cpp` | Compile check test for `Player.cpp`. |\n| `pack.in` | Input file containing a Euchre deck. |\n| `Makefile` | Helper commands for building. |\n| `euchre_test00.out.correct` <br>`euchre_test01.out.correct` | Correct output for system tests with Simple player.  |\n| `euchre_test50.in` <br>`euchre_test50.out.correct` | Input and correct output for system tests with Human player. |\n| `unit_test_framework.hpp` | A simple unit-testing framework. |\n\n### Version control\nSet up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).\n\nAfter you're done, you should have a local repository with a \"clean\" status and your local repository should be connected to a remote GitHub repository.\n```console\n$ git status\nOn branch main\nYour branch is up-to-date with 'origin/main'.\n\nnothing to commit, working tree clean\n$ git remote -v\norigin\thttps://github.com/awdeorio/p3-euchre.git (fetch)\norigin\thttps://githubcom/awdeorio/p3-euchre.git (push)\n```\n\nYou should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).\n```console\n$ head .gitignore\n# This is a sample .gitignore file that's useful for C++ projects.\n...\n```\n\n### Group registration\nRegister your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.\n\n## EECS 280 Euchre Rules\n\nThere are many variants of Euchre. Our particular version is based on\na variety commonly played in Michigan with a few changes to make it\nfeasible as a coding project.\n\nOur step-by-step explanation of a game of \"EECS 280 Euchre\" can be found in a [YouTube video](https://www.youtube.com/watch?v=M0jGJ0NRcrc) and a [PDF](https://drive.google.com/file/d/14MSt1WdtnRbfgpPiMp9YuKn2wQ4Z83Ir/view?usp=sharing).\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Skim this section the first time through.  Refer back to it while you're coding.\n</div>\n\n### Players\n{:.primer-spec-toc-ignore}\n\nThere are four players numbered 0-3. If the players sat around the\ntable, it would look like this:\n\n![](images/image2.png){: .invert-colors-in-dark-mode }\n\nThere are two teams: players 0 and 2 are *partners*, as are 1 and 3.\nEach player has left and right *neighbors*. For example, 1 is to the\nleft of 0, and 3 is to the right of 0. That means 1 is 0's left\n*neighbor*, and 3 is 0's right *neighbor*.\n\n### The Cards\n{:.primer-spec-toc-ignore}\n\nEuchre uses a deck of 24 *playing cards*, each of which has two\nproperties: a *rank* and a *suit*. The ranks are 9, 10, *Jack*,\n*Queen*, *King*, and *Ace*, and the suits are *Spades*, *Hearts*,\n*Clubs*, and *Diamonds*. Each card is unique &mdash; there are no duplicates.\nThroughout this document, we sometimes refer to ranks or suits using\nonly the first letter of their name. Farther below, we describe how to\ndetermine the [ordering of the cards](#value-of-cards).\n\n### Playing the Game\n\nAt a high level, a game of Euchre involves several rounds, which are\ncalled *hands*. Each hand consists of the following phases.\n\nEach hand:\n\n1.  [Setup table](#setup-table)\n    1.  [Shuffle](#shuffle)\n    2.  [Deal](#deal)\n2.  [Making Trump](#making-trump)\n    1.  [Round One](#round-one)\n    2.  [Round Two](#round-two)\n3.  [Trick Taking](#trick-taking)\n4.  [Scoring](#scoring)\n\nWe describe each in more detail below.\n\n### Setup table\n\n#### Shuffle\n{:.primer-spec-toc-ignore}\n\nThe dealer shuffles the deck at the beginning of each hand. The\nalgorithm you will implement for shuffling is a variant of a riffle\nshuffle called an \"in shuffle\"\n([https://en.wikipedia.org/wiki/In\\_shuffle](https://en.wikipedia.org/wiki/In_shuffle)).\nCut the deck exactly in half and then interleave the two halves,\nstarting with the second half. Thus, the card originally at position\n12 goes to position 0, the one originally at position 0 goes to\nposition 1, the one originally at position 13 goes to position 2, and\nso on. Do this in-shuffle process 7 times.\n\nYou will also implement an option to run the game with shuffling\ndisabled - when this option is chosen, just reset the pack any time\nshuffling would be called for. This may make for easier testing and\ndebugging.\n\n#### Deal\n{:.primer-spec-toc-ignore}\n\nIn each hand, one player is designated as the *dealer* (if humans were\nplaying the game, the one who passes out the cards). In our game,\nplayer 0 deals during the first hand. Each subsequent hand, the role\nof dealer moves one player to the left.\n\nEach player receives five cards, dealt in alternating batches of 3 and 2.\nThat is, deal 3-2-3-2 cards then 2-3-2-3 cards, for a total of 5\ncards each. The player to the left of the dealer receives the first\nbatch, and dealing continues to the left until 8 batches have been\ndealt.\n\nFour cards remain in the deck after the deal. The next card in the\npack is called the upcard (it is turned face up, while the other cards\nare all face down). It plays a special role in the next phase. The\nthree remaining cards are not used for the current hand.\n\n### Making Trump\n\nDuring this phase, the trump suit is determined by whichever player\nchooses to *order up*.\n\n#### Round One\n{:.primer-spec-toc-ignore}\n\nThe suit of the *upcard* is used to propose a *trump* suit whose cards\nbecome more valuable during the upcoming hand. Players are given the\nopportunity to *order up* (i.e. select the suit of the upcard to be\nthe trump suit) or *pass*, starting with the player to the dealer's\nleft (also known as the *eldest hand*) and progressing once around the\ncircle to the left. If any player orders up, the upcard's suit becomes\ntrump and the dealer is given the option to replace one of their cards\nwith the upcard.\n\n#### Round Two\n{:.primer-spec-toc-ignore}\n\nIf all players *pass* during the first round, there is a second round\nof *making*, again beginning with the eldest hand. The upcard's suit\nis rejected and cannot be ordered up. Instead, the players may *order\nup* any suit other than the upcard's suit. The dealer does not have\nthe opportunity to pick up the upcard during round two.\n\nIf *making* reaches the dealer during the second round, a variant\ncalled *screw the dealer* is invoked: the dealer must order up a suit\nother than the rejected suit.\n\n(Note for pro Euchre players: for simplicity, we have omitted \"going\nalone\" in this version.)\n\n### Trick Taking\n\nOnce the trump has been determined, five *tricks* are played. For each\ntrick, players take turns laying down cards, and whoever played the\nhighest card *takes* the trick.\n\nDuring each trick, the player who plays first is called the *leader*.\nFor the first trick, the eldest hand leads.\n\nAt the beginning of each trick, the leader *leads* a card, which\naffects which cards other players are allowed to play, as well as the\nvalue of each card played (see below). Each other player must *follow\nsuit* (play a card with the same suit as the led card) if they are\nable, and otherwise may play any card (it is removed from their hand).\nPlay moves to the left around the table, with each player playing one\ncard.\n\nA trick is won by the player who played the highest valued card (see\nbelow to determine comparative values). The winner of the trick\n*leads* the next one.\n\n### Scoring\n\nThe team that takes the majority of tricks receives points for that hand.\n* If the team that ordered up the trump suit takes 3 or 4 tricks, they get 1 point.\n* If the team that ordered up the trump suit takes all 5 tricks, they get 2 points. This is called a *march*.\n* If the team that did not order up takes 3, 4, or 5 tricks, they receive 2 points. This is called *euchred*.\n\nTraditionally, the first side to reach 10 points wins the game. In\nthis project, the number of points needed to win is specified when the\nprogram is run.\n\n### Value of cards\n\nIn order to determine which of two cards is better, you must pay\nattention to the context in which they are being compared. There are\nthree separate contexts, which depend on whether or not a trump or led\nsuit is present.\n\nIn the simplest case, cards are ordered by rank (A \\> K \\> Q \\> J \\>\n10 \\> 9), with ties broken by suit (D \\> C \\> H \\> S).\n\nIf a *trump suit* is present, all trump cards are more valuable than\nnon-trump cards. That means a 9 of the trump suit will beat an Ace of\na non-trump suit. Additionally, two special cards called *bowers* take\non different values than normal.\n\n  - *Right Bower*: The Jack of the trump suit. This is the most\n    valuable card in the game.\n  - *Left Bower*: The Jack of the \"same color\" suit as trump is\n    **considered to be a trump** (regardless of the suit printed on\n    the card) and is the second most valuable card.\n\nThe suit of the left bower is called *next*, while the two suits of the opposite color are called *cross* suits.\n\nIf a *led suit* is present as well as a trump suit, the ordering is\nthe same except that all cards of the led suit are considered more\nvaluable than all non-trump-suit, non-led-suit cards. Note that it is\npossible for the trump suit and led suit to be the same.\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Pitfall:** The left bower is always considered the trump suit.  For example, if Diamonds is trump, the Jack of Hearts is also considered a Diamond, not a Heart.\n</div>\n\n![](images/image1.png)\n\nThe above shows card orderings in the possible contexts. Cards in\nhigher rows are greater than those in lower rows. Within rows, cards\nfarther to the left are greater. Note the right bower (blue outline)\nand left bower (red outline).\n\n### Euchre Glossary\n\n**Trump:** A suit whose cards are elevated above their normal rank\nduring play.\n\n**Right Bower:** The Jack card of the *Trump* suit, which is\nconsidered the highest-valued card in Euchre.\n\n**Left Bower:** The Jack from the other suit of the same color as the\n*Trump* suit, considered the second highest-valued card in Euchre. The\n*Left Bower* is also considered a *Trump* card.\n\n**Face or Ace:** The Jack, Queen, and King cards are generally pictured with people on them and are called \"face\" cards. These and the ace cards are more powerful than the 9 or 10 and factor into the simple player's strategy.\n\n**Next Suit:** The suit of the same color as trump.\n\n**Cross Suits:** The two suits of the opposite color as trump.\n\n**Making:** The process in which a trump card is chosen, consists of\ntwo rounds.\n\n**Eldest:** Player to the left of the dealer.\n\n**Upcard:** The up-facing card in front of the dealer that proposes\nthe trump suit.\n\n**Order Up:** Accepts the *Upcard* suit.\n\n**Pass:** Player rejects the suit and passes on the decision to the\nnext player.\n\n**Screw the Dealer:** When making* reaches the dealer on round two,\n*the dealer must *order up* a suit other than the rejected one.\n\n**Lead:** The first card played by the eldest* hand, regardless of who\n*is the maker.\n\n**Leader:** Person playing the lead* card in a trick, allowed to lead*\n*any card.\n\n**March:** When the side that made trump* wins all 5 tricks.\n\n**Euchred:** When the side that didn't make trump* wins 3, 4, or 5\n*tricks.\n\n\n## Card\n\nWrite an abstract data type (ADT) for a playing card.  Refer back to the [Value of cards section](#value-of-cards) while you're working on the card ADT.\n\nBefore getting started, take a look at the [Operator Overloading Tutorial](operator_overloading.html).  That will help you understand functions like:\n```c++\nbool operator<(const Card &lhs, const Card &rhs);\n```\n\nNext, see the short [Enumerated Type Tutorial](enum.html).  It explains code like this from `Card.hpp`.\n```c++\nenum Suit {\n  SPADES   = 0,\n  HEARTS   = 1,\n  CLUBS    = 2,\n  DIAMONDS = 3,\n};\n```\n\nWrite implementations in `Card.cpp` for the functions declared in\n`Card.hpp`.\n\nRun the public Card tests.\n```console\n$ make Card_public_tests.exe\n$ ./Card_public_tests.exe\n```\n\nWrite tests for `Card` in `Card_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make Card_tests.exe\n$ ./Card_tests.exe\n```\n\nSubmit `Card.cpp` and `Card_tests.cpp` to the [autograder](https://autograder.io).\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Compare the underlying numeric representation of an `enum`.\n```c++\nRank r = JACK;\nr == JACK; // true\n\nSuit s1 = SPADES;\nSuit s2 = DIAMONDS;\ns1 < s2;  // true\n```\n</div>\n\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Card.cpp.starter` -> `Card.cpp`\n-  `Card_tests.cpp.starter` -> `Card_tests.cpp`\n\nEdit `Card.cpp`, adding a function stub for each of the Card member functions in `Card.hpp`.\n```c++\nCard::Card() {\n  assert(false);\n}\n```\n{: data-title=\"Card.cpp\" }\n\nEdit `Card.cpp`, adding  function stubs for each of the non-member non-operator functions in `Card.hpp`.  Here are a few examples.\n```c++\nSuit Suit_next(Suit suit) {\n  assert(false);\n}\n\nbool Card_less(const Card &a, const Card &b, Suit trump) {\n  assert(false);\n}\n```\n{: data-title=\"Card.cpp\" }\n\nEdit `Card.cpp`, adding  function stubs for each of the overloaded operators in `Card.hpp`.  Here are a few examples.\n```c++\nstd::ostream & operator<<(std::ostream &os, const Card &card) {\n  assert(false);\n}\n\nbool operator<(const Card &lhs, const Card &rhs) {\n  assert(false);\n}\n\n```\n{: data-title=\"Card.cpp\" }\n\nThe Card tests should compile and run.  Expect them to fail at this point because the `Card.cpp` starter code contains function stubs.\n```console\n$ make Card_public_tests.exe\n$ ./Card_public_tests.exe\n$ make Card_tests.exe\n$ ./Card_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Card_public_tests.cpp`, `Card.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Card_tests.cpp`, `Card.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Card_public_tests.cpp`\n  - Exclude `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Card_tests.cpp`\n  - Exclude `Card_public_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Testing\nThis section contains a few tips for writing your own tests in `Card_tests.cpp`.\n\nHere's how to create a Card and check its rank and suit.\n```c++\nCard ace_hearts(ACE, HEARTS);\nASSERT_EQUAL(ace_hearts.get_rank(), ACE);\nASSERT_EQUAL(ace_hearts.get_suit(), HEARTS);\n```\n\nIn this example, the overloaded less-than operator runs: `bool operator<(const Card &lhs, const Card &rhs);`.  Notice that the suits are ordered to break ties (see the [Value of Cards](#value-of-cards) section).\n```c++\nCard ace_hearts(ACE, HEARTS);\nCard ace_diamonds(ACE, DIAMONDS);\nASSERT_TRUE(ace_hearts < ace_diamonds);\n```\n\n## Pack\n\nWrite an abstract data type (ADT) for a pack of playing cards.\n\nWrite implementations in `Pack.cpp` for the functions declared in\n`Pack.hpp`.\n\nRun the public Pack tests.\n```console\n$ make Pack_public_tests.exe\n$ ./Pack_public_tests.exe\n```\n\nWrite tests for `Pack` in `Pack_tests.cpp` using the unit test framework. While you should write your own tests for `Pack` to ensure that your implementation is correct, you do not have to submit your tests to the autograder.\n```console\n$ make Pack_tests.exe\n$ ./Pack_tests.exe\n```\n\nSubmit `Pack.cpp` to the [autograder](https://autograder.io).  Don't forget to include the code you finished earlier, `Card.cpp` and `Card_tests.cpp`.\n\n### Default constructor\n{: .primer-spec-toc-ignore }\n\nThe default `Pack` constructor initializes a full pack with cards in order from lowest to highest.\n```c++\nPack();\n```\n\nYou can take advantage of an `enum`'s underlying integer representation to loop over all its values.\n```c++\nfor (int s = SPADES; s <= DIAMONDS; ++s) {\n  Suit suit = static_cast<Suit>(s);\n}\n```\n\n### Stream input constructor\n{: .primer-spec-toc-ignore }\n\nA second `Pack` constructor reads a pack from stream input. [Later](#command-line-arguments), your `main` function will open an input file and then call this constructor on the input stream.\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Pack_tests.cpp.starter` -> `Pack_tests.cpp`\n\nCreate a new file `Pack.cpp`.  Add a function stub for every function prototype in `Pack.hpp`.  Remember to `#include \"Pack.hpp\"`.\n\nFor example:\n```c++\n#include \"Pack.hpp\"\nvoid Pack::reset() {\n  assert(false);\n  assert(next); // DELETEME: avoid error \"private field is not used\"\n}\n```\n{: data-title=\"Pack.cpp\" }\n\nThe Pack tests should compile and run.  Expect them to fail at this point because the `Pack.cpp` contains function stubs.\n```console\n$ make Pack_public_tests.exe\n$ ./Pack_public_tests.exe\n$ make Pack_tests.exe\n$ ./Pack_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Pack_public_tests.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Pack_tests.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Pack_public_tests.cpp`\n  - Exclude `Pack_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Pack_tests.cpp`\n  - Exclude `Pack_public_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Reading the Pack\n\nOne of the `Pack` constructors reads a pack from stream input. [Later](#interface), your `main` function will open an input file and then call this constructor on the input stream.\n```c++\nPack(std::istream& pack_input);\n```\n{: data-title=\"Pack.hpp\" }\n\nThe `pack.in` file provided with the project contains an example of the input format, with cards listed in \"new pack\" order:\n\n```\nNine of Spades\nTen of Spades\nJack of Spades\n...\nQueen of Diamonds\nKing of Diamonds\nAce of Diamonds\n```\n{: data-title=\"pack.in\" data-variant=\"no-line-numbers\" }\n\nYour implementation may assume any pack input is formatted correctly, with exactly 24\nunique and correctly formatted cards.\n\n## Player\n\nWe'll implement two players: a simple AI player and a human-controlled player that reads instructions from standard input (`cin`).  We have provided an abstract base class in `Player.hpp`.\n\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Player_tests.cpp.starter` -> `Player_tests.cpp`\n\nCreate a new file `Player.cpp`.  Add function stubs for the two \"vanilla\" functions in `Player.hpp`. Remember to `#include \"Player.hpp\"`. Later, you'll add new classes and member functions using derived classes, which you can ignore for now.\n```c++\n#include \"Player.hpp\"\nPlayer * Player_factory(const std::string &name, const std::string &strategy) {\n  assert(false);\n}\n\nstd::ostream & operator<<(std::ostream &os, const Player &p) {\n  assert(false);\n}\n```\n{: data-title=\"Player.cpp\" }\n\nThe Player tests should compile and run.  Expect them to fail at this point because the `Player.cpp` contains function stubs.\n```console\n$ make Player_public_tests.exe\n$ ./Player_public_tests.exe\n$ make Player_tests.exe\n$ ./Player_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Player_public_tests.cpp`, `Player.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Player_tests.cpp`, `Player.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Player_public_tests.cpp`\n  - Exclude `Player_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Player_tests.cpp`\n  - Exclude `Player_public_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Player factory\n\nSince the specific types of Players are hidden inside `Player.cpp`, we\nneed to write a *factory function* that returns a pointer to a\n`Player` with the correct dynamic type. We also need the pointed-to\nobjects to stick around after the factory function finishes, so we'll\ncreate the players using *dynamically allocated memory*. The prototype\nfor `Player_factory` can be found in `Player.hpp`, and the\nimplementation will go in `Player.cpp`.\n\n```c++\nPlayer * Player_factory(const std::string &name, \n                        const std::string &strategy) {\n  // We need to check the value of strategy and return \n  // the corresponding player type.\n  if (strategy == \"Simple\") {\n    // The \"new\" keyword dynamically allocates an object.\n    return new SimplePlayer(name);\n  }\n  // Repeat for each other type of Player\n  ...\n  // Invalid strategy if we get here\n  assert(false);\n  return nullptr;\n}\n```\n{: data-title=\"Player.cpp\" }\n\n### Simple Player\n\nImplement the Simple Player in `Player.cpp` by creating a class that derives from our `Player` abstract base class.  Override each Player function in `Player.cpp` for the functions declared in `Player.hpp`. \n\nMuch of the strategy for our Simple Player can be implemented using\nthe comparison functions provided by the Card interface.\n\nThe Simple Player should not print any output.\n\nRun the public Simple Player tests.\n```console\n$ make Player_public_tests.exe\n$ ./Player_public_tests.exe\n```\n\nWrite tests for the Simple Player in `Player_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make Player_tests.exe\n$ ./Player_tests.exe\n```\n\nSubmit `Player.cpp` and `Player_tests.cpp` to the [autograder](https://autograder.io).  Don't forget to include the code you finished earlier, `Card.cpp`, `Card_tests.cpp`, and `Pack.cpp`.\n\n#### Making\n{:.primer-spec-toc-ignore}\n\nIn making trump, a Simple Player considers the upcard, which player\ndealt, and whether it is the first or second round of making trump. A\nmore comprehensive strategy would consider the other players'\nresponses, but we will keep it simple.\n\nDuring round one, a Simple Player considers ordering up the suit\nof the upcard, which would make that suit trump. They will order up if\nthat would mean they have two or more cards that are either face or ace\ncards of the trump suit (the right and left bowers, and Q, K, A of\nthe trump suit, which is the suit proposed by the upcard). (A Simple\nPlayer does not consider whether they are the dealer and could gain an\nadditional trump by picking up the upcard.)\n\nDuring round two, a Simple Player considers ordering up the suit with\nthe same color as the upcard, which would make that suit trump. They\nwill order up if that would mean they have one or more cards that are either\nface or ace cards of the trump suit in their hand (the right and left bowers, and Q, K, A of the order-up\nsuit). For example, if the upcard is a Heart and the player has the\nKing of Diamonds in their hand, they will order up Diamonds. The\nSimple Player will not order up any other suit. If making reaches the\ndealer during the second round, we invoke *screw the dealer*, where\nthe dealer is forced to order up. In the case of screw the dealer, the\ndealer will always order up the suit with the same color as the\nupcard.\n\n#### Adding the Upcard and Discarding a Card\n{:.primer-spec-toc-ignore}\n\nIf the trump suit is ordered up during round one, the dealer picks up\nthe upcard. The dealer then discards the lowest card in their hand,\neven if this is the upcard, for a final total of five cards. (Note that\nat this point, the trump suit is the suit of the upcard.)\n\n#### Leading Tricks\n{:.primer-spec-toc-ignore}\n\nWhen a Simple Player leads a trick, they play the highest non-trump\ncard in their hand. If they have only trump cards, they play the\nhighest trump card in their hand.\n\n#### Playing Tricks\n{:.primer-spec-toc-ignore}\n\nWhen playing a card, Simple Players use a simple strategy that\nconsiders only the suit that was led. A more complex strategy would\nalso consider the cards on the table.\n\nIf a Simple Player can follow suit, they play the highest card that\nfollows suit. Otherwise, they play the lowest card in their hand.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Here's a nice way to remove a Card from a vector using [`vector::erase`](https://cplusplus.com/reference/vector/vector/erase/).\n```c++\nvector<Card> hand;  // Assume hand is full of cards\nhand.erase(hand.begin() + i);  // Remove card i\n```\n</div>\n\n### Human Player\n\nThe Human Player reads input from the human user. You may assume all\nuser input is correctly formatted and has correct values. You may also\nassume the user will follow the rules of the game and not try to\ncheat. See [Example With Human Players](#example-with-human-players) for\nexact output for a game with a human player.\n\nImplement the Human Player in `Player.cpp` by creating a class that derives from our `Player` abstract base class.  Override each Player function in `Player.cpp` for the functions declared in `Player.hpp`. \n\nThe tests in `Player_tests.cpp` and `Player_public_tests.cpp` test only the Simple Player.  You'll have to wait until you have a working Euchre game driver to test the Human player.\n\nSubmit `Player.cpp` again to the [autograder](https://autograder.io).  Don't forget to include the code you finished earlier, `Card.cpp`, `Card_tests.cpp`, `Pack.cpp`, and `Player_tests.cpp`.\n\n#### Making Trump\n{:.primer-spec-toc-ignore}\n\nWhen making trump reaches a Human Player, first print the Player's\nhand. Then, prompt the user for their decision to pass or order up. The user will\nthen enter one of the following: \"Spades\", \"Hearts\", \"Clubs\",\n\"Diamonds\", or \"pass\" to either order up the specified suit or pass.\nThis procedure is the same for both rounds of making trump.\n\nSample output code:\n```c++\nprint_hand();\ncout << \"Human player \" << name << \", please enter a suit, or \\\"pass\\\":\\n\";\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Add a private member function that prints out the human player's hand.\n```c++\nvoid print_hand() const {\n  for (size_t i=0; i < hand.size(); ++i)\n    cout << \"Human player \" << name << \"'s hand: \"\n         << \"[\" << i << \"] \" << hand[i] << \"\\n\";\n}\n```\n</div>\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Use the `string_to_suit()` function provided with the starter code.\n```c++\nstring decision;\ncin >> decision;\n\nif (decision != \"pass\") {\n  Suit ordered_up = string_to_suit(decision);\n  ...\n}\nelse {\n  ...\n}\n```\n</div>\n\n#### Adding the Upcard and Discarding\n{:.primer-spec-toc-ignore}\n\nIf a Human Player is the dealer and someone orders up during the first\nround of making, the Human Player will pick up the upcard and discard\na card of their choice. Print the Player's hand and an option to\ndiscard the upcard. Then, prompt the user to select a card to discard.\nThe user will then enter the number corresponding to the card they\nwant to discard (or -1 if they want to discard the upcard).\n\nSample output code:\n```c++\nprint_hand();\ncout << \"Discard upcard: [-1]\\n\";\ncout << \"Human player \" << name << \", please select a card to discard:\\n\";\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Make \"sorted card ordering\" a _representation invariant_ of your Human Player class and ensure that the hand is always kept in sorted order.\nFor consistency with autograder test cases, the cards in a human player's hand must always be printed in ascending order, as defined by the `<` operator in `Card.hpp`.\n\nUse the STL to sort a `vector<Card> hand`:\n```c++\n#include <algorithm>\n// ...\nstd::sort(hand.begin(), hand.end());\n```\n{: data-variant=\"no-line-numbers\" }\n\n**Pitfall:** Using `sort` on a member variable in a `const` member function leads to a confusing error, `no matching function for call to 'swap'`.  Instead, call `sort` when adding a card to the `hand`.\n```c++\nvoid Human::print_hand() const {\n  std::sort(hand.begin(), hand.end()); // Error!\n  // ...\n}\n```\n</div>\n\n#### Playing and Leading Tricks\n{:.primer-spec-toc-ignore}\n\nWhen it is the Human Player's turn to lead or play a trick, first\nprint the Player's hand. Then, prompt the user to select a card. The user\nwill then enter the number corresponding to the card they want to\nplay.\n\nSample output code:\n```c++\nprint_hand();\ncout << \"Human player \" << name << \", please select a card:\\n\";\n```\n\n\n## Euchre Game\n\nWrite the Euchre Game in `euchre.cpp` following the [EECS 280 Euchre Rules](#eecs-280-euchre-rules).\n\nRun a Euchre game with four players.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n\n### Setup\nMake sure you have created `euchre.cpp` ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#add-new-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#add-new-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#add-new-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#add-new-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#touch)).\n\nAdd \"hello world\" code if you haven't already.\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n  cout << \"Hello World!\\n\";\n}\n```\n\nThe euchre program should compile and run.\n```console\n$ make euchre.exe\n$ ./euchre.exe\nHello World!\n```\n\nConfigure your IDE to debug the euchre program.\n\n<table>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/euchre.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/euchre.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `euchre.cpp`, `Card.cpp`, `Pack.cpp`, `Player.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `euchre.cpp`\n  - Exclude `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `main.cpp` (if present)\n  </td>\n</tr>\n</table>\n\nConfigure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)).  We recommend starting with the euchre test 00: `pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple`\n\nTo compile and run a Euchre game with four players.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n\n### Interface\n\nThe Euchre game driver takes several command line arguments, for example:\n\n```console\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each command line argument.\n\n| `./euchre.exe` | Name of the executable |\n| `pack.in` | Filename of the pack |\n| `noshuffle` | Don't shuffle the deck, or use `shuffle` to turn on shuffling |\n| `1` | Points to win the game |\n| `Adi` | Name of player 0 |\n| `Simple` | Type of player 0 |\n| `Barbara` | Name of player 1 |\n| `Simple` | Type of player 1 |\n| `Chi-Chih` | Name of player 2 |\n| `Simple` | Type of player 2 |\n| `Dabbala` | Name of player 3 |\n| `Simple` | Type of player 3 |\n\nCheck for each of these errors:\n  - There are exactly 12 arguments, including the executable name.\n  - Points to win the game is between 1 and 100, inclusive.\n  - The shuffle argument is either `shuffle` or `noshuffle`.\n  - The types of each of the players are either `Simple` or `Human`.\n\nIf there is an error print this message and no other output.  Exit returning a non-zero value from `main`.\n\n```c++\ncout << \"Usage: euchre.exe PACK_FILENAME [shuffle|noshuffle] \"\n     << \"POINTS_TO_WIN NAME1 TYPE1 NAME2 TYPE2 NAME3 TYPE3 \"\n     << \"NAME4 TYPE4\" << endl;\n```\n\nYou must also verify the pack input file opens successfully. If it does not,\nprint this error message and exit returning a non-zero value from `main`.\n\n```c++\n// Assume pack_filename is a variable containing\n// the specified pack filename from argv\ncout << \"Error opening \" << pack_filename << endl;\n```\n{: data-variant=\"no-line-numbers\" }\n\nIf the file opens successfully, you may assume it is formatted correctly.\n\n### Design\n\nThe Euchre game driver coordinates all the [actions in the game](#playing-the-game).  *Take some time* to design this complex piece of code before beginning.\n\nWe recommend writing a `Game` ADT. It should have a constructor that takes in details like the players, points to win, etc. and a public `play()` function.  The `Game` and its helper functions do the hard work, and the `main()` function is simple.\n\n```c++\nclass Game {\n public:\n  // primer-spec-highlight-start\n  Game(/* game details */);\n  void play();\n  // primer-spec-highlight-end\n};\n\nint main(int argc, char **argv) {\n  // Read command line args and check for errors\n  // primer-spec-highlight-start\n  Game game(/* game details */);\n  game.play();\n  // primer-spec-highlight-end\n}\n```\n\nNext, consider which member data you'll need.  Examples include player pointers, pack of cards, etc.\n```c++\nclass Game {\n public:\n  Game(/* ... */);\n  void play();\n\n private:\n  // primer-spec-highlight-start\n  std::vector<Player*> players;\n  Pack pack;\n  // ...\n  // primer-spec-highlight-end\n};\n```\n\nWhich helper functions would help simplify the `play()` function?  Add these as private member functions.  Functions that shuffle, deal, make trump, and play a hand are a good starting point. \n```c++\nclass Game {\n public:\n  Game(/* ... */);\n  void play();\n\n private:\n  std::vector<Player*> players;\n  Pack pack;\n  // ...\n\n  // primer-spec-highlight-start\n  void shuffle();\n  void deal(/* ... */);\n  void make_trump(/* ... */);\n  void play_hand(/* ... */);\n  // ...\n  // primer-spec-highlight-end\n};\n```\n\n#### End of game\n{: .primer-spec-toc-ignore }\n\nAt the end of a game, delete the `Player` objects created by the [`Player_factory`](#player-factory).\n\n```c++\nfor (size_t i = 0; i < players.size(); ++i) {\n  delete players[i];\n}\n```\n\n### Example With Simple Players\n\nWe've provided full example output for a game with four simple players in `euchre_test00.out.correct`.  This section explains the output line by line.\n\nAs a reminder, all the output in this example is produced by the Euchre Game driver, not by the simple player code in `Player.cpp`.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Debug differences in game output using `diff -y -B`, which shows differences side-by-side and ignores whitespace.  We'll use the `less` pager so we can scroll through the long terminal output.  Press `q` to quit.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple > euchre_test00.out\n$ diff -y -B euchre_test00.out.correct euchre_test00.out | less  # q to quit\n```\n</div>\n\nRun the example.\n\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n\nFirst, print the executable and all arguments on the first line. Print\na single space at the end, which makes it easier to print an array.\n\n```\n./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple \n```\n{: data-variant=\"legacy\" }\n\nAt the beginning of each hand, announce the hand, starting at zero,\nfollowed by the dealer and the upcard.\n\n```\nHand 0\nAdi deals\nJack of Diamonds turned up\n```\n{: data-variant=\"legacy\" }\n\nPrint the decision of each player during the making procedure. Print\nan extra newline when making, adding, and discarding is complete.\n\n```\nBarbara passes\nChi-Chih passes\nDabbala passes\nAdi passes\nBarbara orders up Hearts\n```\n{: data-variant=\"legacy\" }\n\nEach of the five tricks is announced, including the lead, cards played\nand the player that took the trick. Print an extra newline at the end\nof each trick.\n\n```\nJack of Spades led by Barbara\nKing of Spades played by Chi-Chih\nAce of Spades played by Dabbala\nNine of Diamonds played by Adi\nDabbala takes the trick\n\n```\n{: data-variant=\"legacy\" }\n\nAt the end of the hand, print the winners of the hand. When printing\nthe names of a partnership, print the player with the lower index\nfirst. For example, Adi was specified on the command line before\nChi-Chih, so he goes first.\n\n```\nAdi and Chi-Chih win the hand\n```\n{: data-variant=\"legacy\" }\n\nIf a march occurs, print `march!` followed by a newline. If euchre\noccurs, print `euchred!` followed by a newline. If neither occurs,\nprint nothing.\n\n```\neuchred!\n```\n{: data-variant=\"legacy\" }\n\nPrint the score, followed by an extra newline.\n\n```\nAdi and Chi-Chih have 2 points\nBarbara and Dabbala have 0 points\n```\n{: data-variant=\"legacy\" }\n\nWhen the game is over, print the winners of the game.\n\n```\nAdi and Chi-Chih win!\n```\n{: data-variant=\"legacy\" }\n\nThe output for a much longer game with four simple players is in `euchre_test01.out.correct`. See the [Euchre Test 01 Explanation](euchre_test01.html) for an explanation of the output.\n\n### Example With Human Players\n\nWe\u2019ve provided full example output for a game with four human players in `euchre_test50.out.correct`. The input is in `euchre_test50.in`.  This section explains the output line by line.\n\nOutput that is specific to the Human Player should be printed by the Human Player code in (`Player.cpp`). All other output that is common to both Simple and Human Players should be printed by the Euchre Game driver.\n\nSet up input redirection ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#input-redirection), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#input-redirection), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#input-redirection), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#input-redirection)) to read `euchre_test50.in`. \n\nConfigure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)) for euchre test 50: `noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human`\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Similar to the simple player, you can debug differences in game output using `diff -y -B`.  Press `q` to quit.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human < euchre_test50.in > euchre_test50.out\n$ diff -y -B euchre_test50.out.correct euchre_test50.out | less  # q to quit\n```\n</div>\n\nRun the example, redirecting the input file `euchre_test50.in` to stdin.\n\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human < euchre_test50.in\n```\n\nFirst, print the executable and all arguments on the first line. Print\na single space at the end, which makes it easier to print an array.\n\n```\n./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human \n```\n{: data-variant=\"legacy\" }\n\nAt the beginning of each hand, announce the hand, starting at zero,\nfollowed by the dealer and the upcard.\n\n```\nHand 0\nIvan deals\nJack of Diamonds turned up\n```\n{: data-variant=\"legacy\" }\n\nPrint the hand of each player during the making procedure, followed by\na prompt for their making decision. End the prompt with a newline\nimmediately after the colon.\n\n```\nHuman player Judea's hand: [0] Nine of Spades\nHuman player Judea's hand: [1] Ten of Spades\nHuman player Judea's hand: [2] Jack of Spades\nHuman player Judea's hand: [3] King of Hearts\nHuman player Judea's hand: [4] Ace of Hearts\nHuman player Judea, please enter a suit, or \"pass\":\n```\n{: data-variant=\"legacy\" }\n\nPrint the decision of each player during the making procedure.\n\n```\nJudea passes\n...\nJudea orders up Hearts\n```\n{: data-variant=\"legacy\" }\n\nPrint the dealer's hand if a player orders up during the first round,\nas well as an option to discard the upcard. Prompt the dealer to\nselect a card to discard, ending the prompt with a newline immediately\nafter the colon. Print an extra newline when making, adding, and\ndiscarding is done.\n\n```\nHuman player Ivan's hand: [0] Nine of Diamonds\n...\nHuman player Ivan's hand: [4] Ace of Clubs\nDiscard upcard: [-1]\nHuman player Ivan, please select a card to discard:\n```\n{: data-variant=\"legacy\" }\n\nFor each trick, print the Human Player's hand and prompt them to\nselect a card.\n\n```\nHuman player Judea's hand: [0] Nine of Spades\n...\nHuman player Judea's hand: [4] Ace of Hearts\nHuman player Judea, please select a card:\n```\n{: data-variant=\"legacy\" }\n\nThen print the card played or lead.\n\n```\nNine of Spades led by Judea\n```\n{: data-variant=\"legacy\" }\n\nAt the end of each trick, print the player who took the trick as well\nas an extra newline.\n\n```\nLiskov takes the trick\n```\n{: data-variant=\"legacy\" }\n\nAt the end of the hand, print the winners of the hand. When printing\nthe names of a partnership, print the player with the lower index\nfirst. For example, Ivan was specified on the command line before\nKunle, so he goes first.\n\n```\nIvan and Kunle win the hand\n```\n{: data-variant=\"legacy\" }\n\nIf a march occurs, print `march!` followed by a newline. If euchre\noccurs, print `euchred!` followed by a newline. If neither occurs, print\nnothing.\n\n```\neuchred!\n```\n{: data-variant=\"legacy\" }\n\nPrint the score, followed by an extra newline.\n\n```\nIvan and Kunle have 2 points\nJudea and Liskov have 0 points\n```\n{: data-variant=\"legacy\" }\n\nWhen the game is over, print the winners of the game.\n\n```\nIvan and Kunle win!\n```\n{: data-variant=\"legacy\" }\n\n\n## Submission and Grading\n\nSubmit these files to the [autograder](https://autograder.io).\n  - `Card.cpp`\n  - `Card_tests.cpp`\n  - `Pack.cpp`\n  - `Player.cpp`\n  - `Player_tests.cpp`\n  - `euchre.cpp`\n\nYou do not have to submit `Pack_tests.cpp` to the autograder.\n\nThis project will be autograded for correctness, comprehensiveness of\nyour test cases, and programming style. See the [style checking\ntutorial](https://eecs280staff.github.io/tutorials/setup_style.html)\nfor the criteria and how to check your style automatically on CAEN.\n\n### Checkpoint\n\nThis project is graded on an early checkpoint as well as the full submission. The checkpoint submission is worth 0.5% of your overall course grade. The full submission is worth 9.5% of your overall course grade.\n\nThe checkpoint consists of everything except the [Euchre Game](#euchre-game) driver.\n\nSubmit these files to the [autograder](https://autograder.io).\n  - `Card.cpp`\n  - `Card_tests.cpp`\n  - `Pack.cpp`\n  - `Player.cpp`\n  - `Player_tests.cpp`\n\nThere are no private tests and no style grading at the checkpoint.\n\nYour checkpoint score does not change after the checkpoint deadline, even though we run the same public tests and [mutation tests](#unit-test-grading) at both the checkpoint and full submission.\n\nAfter the checkpoint autograder closes, the full submission autograder will open.\n\n### Testing\n\nRun all the unit tests and system tests.  This includes the public tests we provided and the unit tests that you wrote.\n\n```console\n$ make test\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Run commands in parallel with `make -j`.\n```console\n$ make -j4 test\n```\n{: data-variant=\"no-line-numbers\" }\n</div>\n\n### Unit Test Grading\n\nWe will autograde your `Card_tests.cpp` and `Player_tests.cpp` unit tests. Note that your player tests should only test the \"simple player\", not the \"human player\".\n\nYour unit tests must use the [unit test framework](https://eecs280staff.github.io/unit_test_framework/).\n\nA test suite must run in less than 5 seconds and contain 50 or fewer `TEST()` functions.  One test suite is one `_tests.cpp` file.\n\nTo grade your unit tests, we use a set of intentionally buggy instructor solutions.  You get points for catching the bugs.\n\n1.  We compile and run your unit tests with a **correct solution**.\n    - Tests that pass are **valid**.\n    - Tests that fail are **invalid**, they falsely report a bug.\n3.  We compile and run all of your **valid** tests against each **buggy solution**.\n    - If any of your tests fail, you caught the bug.\n    - You earn points for each bug that you catch.\n\n### Requirements and Restrictions\n\nIt is our goal for you to gain practice with good C++ code, classes,\nand polymorphism.\n\n\n| DO | DO NOT |\n| -- | ------ |\n| Modify `.cpp` files | Modify `.hpp` files |\n| Write helper functions in `Card.cpp` and `Pack.cpp` as non-member functions in the `.cpp` files and declare them `static` | Modify `.hpp` files |\n| Use these libraries: `<iostream>`, `<fstream>`, `<cstdlib>`, `<cassert>`, `<cstring>`, `<string>`, `<array>`, `<vector>`, `<sstream>` <br>Use the `<algorithm>` library, but only for the `sort()` function. | Use other libraries. <br><br>Use `<algorithm>` library for anything other than the `sort()` function. |\n| `#include` a library to use its functions | Assume that the compiler will find the library for you (some do, some don't) |\n| | `#include` an unnecessary `.hpp` file, such as `#include Pack.hpp` in either `Card.cpp` or in `Player.cpp` (This introduces undesirable dependencies, e.g. that the `Card`/`Player` ADTs require the `Pack` ADT to exist and be properly implemented.) |\n| Use C++ strings | Use C-strings other than when checking `argv` |\n| Send all output to standard out (AKA stdout) by using `cout` | Send any output to standard error (AKA stderr) by using `cerr` |\n| `const` global variables | Global or static variables |\n| Pass large structs or classes by reference | Pass large structs or classes by value |\n| Pass by `const` reference when appropriate | \"I don't think I'll modify it ...\" |\n| Variables on the stack | Dynamic memory (`new`, `malloc()`, etc.) outside of the `Player_factory`. |\n\n\n## Acknowledgments\n\nThe original project was written by Andrew DeOrio, Fall 2013. The\nproject was modified to use C++ style object oriented programming and\nthe specification updated by the Fall 2015 staff.\n", "extracted_entities": ["EECS 280", "Euchre", "Winter 2025", "February 24, 2025", "March 12, 2025", "Michigan", "C++", "AI", "Human", "YouTube", "Google Drive", "VS Code", "Visual Studio", "Xcode", "Pack_public_tests.cpp", "Card.hpp", "Card.cpp", "Pack.hpp", "Player.hpp", "unit_test_framework.hpp", "Card_tests.cpp", "Player_tests.cpp", "Pack_tests.cpp", "euchre.cpp", "pack.in", "Card", "Pack", "Player", "Simple", "Euchre Game", "Adrian", "Barbara", "Chi-Chih", "Dabbala", "Ivan", "Judea", "Kunle", "Liskov"], "extracted_triples": [["EECS 280", "is a course for", "Euchre"], ["Euchre", "is scheduled for", "Winter 2025"], ["Euchre", "has a checkpoint due on", "February 24, 2025"], ["Euchre", "has a full project due on", "March 12, 2025"], ["Euchre", "is popular in", "Michigan"], ["Euchre", "is implemented in", "C++"], ["Euchre", "can be played by", "AI"], ["Euchre", "can be played by", "Human"], ["Euchre", "has a tutorial on", "YouTube"], ["Euchre", "has resources on", "Google Drive"], ["Euchre", "can be set up using", "VS Code"], ["Euchre", "can be set up using", "Visual Studio"], ["Euchre", "can be set up using", "Xcode"], ["Card.hpp", "is a header file for", "Card"], ["Card.cpp", "is an implementation file for", "Card"], ["Pack.hpp", "is a header file for", "Pack"], ["Player.hpp", "is a header file for", "Player"], ["unit_test_framework.hpp", "is a framework for", "unit testing"], ["Card_tests.cpp", "contains tests for", "Card"], ["Player_tests.cpp", "contains tests for", "Player"], ["Pack_tests.cpp", "contains tests for", "Pack"], ["euchre.cpp", "contains the main game logic for", "Euchre"], ["pack.in", "is an input file for", "Euchre"], ["Adrian", "is a player in", "Euchre Game"], ["Barbara", "is a player in", "Euchre Game"], ["Chi-Chih", "is a player in", "Euchre Game"], ["Dabbala", "is a player in", "Euchre Game"], ["Ivan", "is a player in", "Euchre Game"], ["Judea", "is a player in", "Euchre Game"], ["Kunle", "is a player in", "Euchre Game"], ["Liskov", "is a player in", "Euchre Game"], ["Euchre Game", "is played by", "four players"]]}, {"idx": "chunk-97b512c3a5231e7c1ea317f1a9cf2152", "passage": "---\nlayout: spec\n---\nEECS 280 Project 5: Text Editor\n===============================\n{: .primer-spec-toc-ignore }\n\nFall 2024 release.\n\nProject due 8:00pm EST Monday November 25, 2024.\n\nYou may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)).\n\n<!-- ## Change Log -->\n\n\n## Introduction\nThe learning goals of this project include Container ADTs, Dynamic Memory, The Big Three, Linked Lists, and Iterators.  You will gain experience with `new` and `delete`, constructors and destructors, and the `List` data structure that is similar to `std::list` from the standard library.\n\nWhen you're done, you'll have implemented the basic features of a text\neditor that is usable through a terminal-based visual editor, similar\nto other terminal editors such as\n[Pico](https://en.wikipedia.org/wiki/Pico_(text_editor)),\n[nano](https://en.wikipedia.org/wiki/GNU_nano),\n[Emacs](https://en.wikipedia.org/wiki/Emacs), and\n[vi](https://en.wikipedia.org/wiki/Vi_(text_editor)).\n\n<img src=\"img/femto-light.png#gh-light-mode-only\" width=\"600px\" class=\"no-border\" />\n<img src=\"img/femto-dark.png#gh-dark-mode-only\" width=\"600px\" class=\"no-border\" />\n\n## Setup\nSet up your visual debugger and version control, then submit to the autograder.\n\n### Visual debugger\nDuring setup, name your project `list-editor`. Use this starter files link: `https://eecs280staff.github.io/list-editor/starter-files.tar.gz`\n\n| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |\n\nYou should end up with a folder with starter files that look like this.  You may have already renamed files like `List.hpp.starter` to `List.hpp`.\n```console\n$ ls\nList.hpp.starter               e0.cpp\nList_compile_check.cpp         femto.cpp\nList_public_tests.cpp          line.cpp\nList_tests.cpp.starter         line_test1.in\nMakefile                       line_test1.out.correct\nTextBuffer.hpp                 line_test2.in\nTextBuffer_public_tests.cpp    line_test2.out.correct\nTextBuffer_tests.cpp.starter   unit_test_framework.hpp\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each starter file.\n\n| File(s) | Description |\n| ------- | ----------- |\n| `List.hpp.starter` | Starter code for the `List` class template. |\n| `List_tests.cpp.starter` | Starter code for your `List` unit tests. |\n| `List_compile_check.cpp` | Compile check test for `List`. |\n| `List_public_tests.cpp` | A very small set of test cases for `List`. |\n| `Makefile` | Helper commands for building. |\n| `TextBuffer.hpp` | Interface specification for the `TextBuffer` class. |\n| `TextBuffer_public_tests.cpp` | Public test cases for the `TextBuffer` class. |\n| `TextBuffer_tests.cpp.starter` | Starter code for your `TextBuffer` unit tests. |\n| `e0.cpp` | A basic visual editor for testing the `TextBuffer` class. |\n| `femto.cpp` | A more functional visual editor that uses the `TextBuffer` class. |\n| `line.cpp` | A simple command line tool to test the `TextBuffer` class. |\n| `line_test1.in`<br/> `line_test1.out.correct`<br/> `line_test2.in`<br/> `line_test2.out.correct` | Input and correct output for system tests with `line.cpp`. |\n\n### Version control\nSet up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).\n\nAfter you're done, you should have a local repository with a \"clean\" status and your local repository should be connected to a remote GitHub repository.\n```console\n$ git status\nOn branch main\nYour branch is up-to-date with 'origin/main'.\n\nnothing to commit, working tree clean\n$ git remote -v\norigin\thttps://github.com/awdeorio/list-editor.git (fetch)\norigin\thttps://github.com/awdeorio/list-editor.git (push)\n```\n{: data-variant=\"no-line-numbers\" }\n\nYou should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).\n```console\n$ head .gitignore\n# This is a sample .gitignore file that's useful for C++ projects.\n...\n```\n{: data-variant=\"no-line-numbers\" }\n\n### Group registration\nRegister your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.\n\n\n## Linked list\nStart by following the instructions in the [Setup](#setup-1) section below. Then implement your doubly-linked list in `List.hpp`.  `List.hpp.starter` provides prototypes for each function.  Because `List` is a *templated*, function implementations go in `List.hpp`.  There is no `List.cpp`.\n\nWhile the `List` from lecture was singly linked, this `List` is doubly\nlinked. This `List` also contains an iterator interface. The iterator\nkeeps track of both the current node as well as the `List` to which it\nbelongs - this allows us to go backwards from an end iterator by\nlooking up the last node in the `List`.\n\nDo not modify the public interface of the `List` class.  Implement a doubly-linked list.  No arrays or vectors, etc. Manage memory allocation so that there are no memory leaks ([Leak checking tutorial](https://eecs280staff.github.io/tutorials/setup_leakcheck.html)).\n\nYou can compile and run the provided compile check and `List` tests as follows.\n```console\n$ make List_compile_check.exe\n$ make List_public_tests.exe\n$ ./List_public_tests.exe\n```\n{: data-variant=\"no-line-numbers\" }\n\nWrite tests for `List` in `List_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make List_tests.exe\n$ ./List_tests.exe\n```\n{: data-variant=\"no-line-numbers\" }\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Getting an error about `typename`?  Take a look at our [reference on Typename](typename.html).\n</div>\n\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `List.hpp.starter` -> `List.hpp`\n-  `List_tests.cpp.starter` -> `List_tests.cpp`\n\nEdit `List.hpp`, adding a function stub for each member function declared in `List.hpp`, either inside or outside the class definition: For example:\n\n```c++\n// Inside the class definition:\ntemplate <typename T>\nclass List {\n  ...\n  \n  bool empty() const {\n    assert(false);\n  }\n\n  ...\n};\n\n// Or, outside the class definition:\ntemplate<typename T>\nbool List<T>::empty() const {\n  assert(false);\n}\n```\n\nThe List tests should compile and run. The public tests will fail until you implement the functions.  The file for your test cases (`List_tests.cpp`) will pass because it initially only contains `ASSERT_TRUE(true)`.\n```console\n$ make List_public_tests.exe\n$ ./List_public_tests.exe\n$ make List_tests.exe\n$ ./List_tests.exe\n```\n{: data-variant=\"no-line-numbers\" }\n\nAt this point, we haven't written the List Iterator, so `List_compile_check.exe` won't compile.  You'll need to take a look at the lecture about iterators and write your own tests.  After you do, use the provided compile check like this:\n```console\n$ make List_compile_check.exe\n```\n{: data-variant=\"no-line-numbers\" }\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/List_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/List_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/List_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/List_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `List_public_tests.cpp`, `List.hpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `List_tests.cpp`, `List.hpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `List_public_tests.cpp`\n  - Exclude `List_compile_check.cpp`, `List_tests.cpp`, `TextBuffer_public_tests.cpp`, `TextBuffer_tests.cpp`, `e0.cpp`, `femto.cpp`, `line.cpp`, `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `List_tests.cpp`\n  - Exclude `List_compile_check.cpp`, `List_public_tests.cpp`, `TextBuffer_public_tests.cpp`, `TextBuffer_tests.cpp`, `e0.cpp`, `femto.cpp`, `line.cpp`, `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n## TextBuffer\n\nA *text buffer* holds an editable sequence of characters and at the same time\nhas the ability to report the current row and column (You can display\nthis information in Pico/nano with `Ctrl-C`, or in Emacs by typing\n`M-x line-number-mode` and `M-x column-number-mode`.). The text buffer\nkeeps track of the current cursor position where all edits are done and\nallows scrolling using the arrow keys to move the cursor\nthrough the text.\n\nIn this section, you will implement the `TextBuffer`\nclass according the interface defined in the `TextBuffer.hpp` file.\nThe data representation of a `TextBuffer` is a doubly linked list\nof characters (either your implementation from [part 1](#linked-list)\nor `std::list` from the C++ standard library). The `TextBuffer` also\nstores an iterator that indicates the current position of the cursor,\nthe current row and column position, and the index of the cursor with\nrespect to the entire buffer (i.e. how many characters from the start\nto the cursor).\n\nThe definition of the ``TextBuffer`` class is shown\nbelow:\n\n```c++\nclass TextBuffer {\n  using CharList = std::list<char>;\n  using Iterator = std::list<char>::iterator;\nprivate:\n  CharList data;           // linked list that contains the characters\n  Iterator cursor;         // current position within the list\n  int row;                 // current row\n  int column;              // current column\n  int index;               // current index\n  // ... public interface not shown\n};\n```\n\nWe use `CharList` as a *type alias* for either `List<char>`, or\n`std::list<char>` (your choice -- the autograder will use\n`std::list<char>` to avoid any issues with your `List`\nimplementation), representing a doubly-linked list of characters. The\nfollowing list contains the text ``spaces``:\n\n<img src=\"img/dll1.svg\" width=\"800px\" class=\"invert-colors-in-dark-mode\" />\n\nTo use a linked list as a text buffer, we need to keep track of the\n*cursor*, which represents the position where edits can be made in the\nbuffer. In many visual text editors, the cursor appears as a colored\nrectangle, so that if the cursor was pointing to the node containing\nthe character `'c'`, we'd see it displayed as\n\n<img src=\"img/spaces1.svg\" height=\"40px\" class=\"invert-colors-in-dark-mode\" />\n\nPressing the left arrow key in a text editor moves the cursor one\ncharacter backward (to the left).\n\n<img src=\"img/spaces2.svg\" height=\"40px\" class=\"invert-colors-in-dark-mode\" />\n\nWe can now draw the linked list corresponding to this text buffer\nalong with the cursor:\n\n<img src=\"img/dll2.svg\" width=\"800px\" class=\"invert-colors-in-dark-mode\" />\n\nDeletions in a text buffer take place at the cursor. If we\ndelete a character in the previous picture, it will remove the\ncharacter at the cursor:\n\n<img src=\"img/dll3.svg\" width=\"700px\" class=\"invert-colors-in-dark-mode\" />\n\nInsertions happen to the left of the cursor. If we next typed the\n`i` key, that character would be entered in to the left of the\ncursor.\n\n<img src=\"img/dll4.svg\" width=\"800px\" class=\"invert-colors-in-dark-mode\" />\n\nOne consequence of this design is that, in order for additions to be\nmade to the end of the buffer, the cursor needs to be able to go to\nthe right of all the text. In other words, it must be possible for the\n`cursor` member variable to be equal to the end iterator for the\nunderlying list. Starting from the buffer above, we can see what that\nlooks like from the editor's point of view:\n\n<img src=\"img/spices_full.svg\" width=\"550px\"  class=\"invert-colors-in-dark-mode\" />\n\nAs a doubly-linked list, this final buffer looks like this:\n\n<img src=\"img/dll5.svg\" width=\"800px\"  class=\"invert-colors-in-dark-mode\" />\n\nA new, empty text buffer containing no text starts with the cursor at\nthe end iterator.\n\n### Rows and Columns\n\nOne thing we care a great deal about in a text editor is which\ncharacters are newlines, because that is what lets us know our\nposition in the document: the row and column. In Emacs (and the\nremaining tasks of this assignment), the first row is row 1, and the\nfirst column is column 0. In these Emacs buffers, you can see the\n(row, column) displayed in the lower-right corner:\n\n<img src=\"img/emacs-rowcol.png\"/>\n\nWe can calculate the column of the cursor by working backwards until\nwe find a newline, and we can calculate the row of the cursor by\nworking backwards to the beginning of the buffer and counting the\nnewlines. Note that in the middle example, the cursor is atop a cell\ncontaining a newline `\\n`, but the cursor is at the end of\nrow 1, not the beginning of row 2.\n\nBy tracking the row and column in the data structure, we can report\nthis information to the user without ever having to recalculate the\nrow. It's good to avoid this, because calculating the ``row`` every\ntime an edit is made can be expensive to run. You should also keep\ntrack of the ``column`` field but sometimes you might need to\nrecalculate this field depending on the type of edit. Any single row\nis usually relatively short (80 columns maximum, if you're using good\nstyle), so this should be fast. Specifically, we only need to\nrecalculate the column when we move left from the beginning of one\nline to the end of the previous line.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** The `TextBuffer` class has a private `compute_column`\nmember function that is intended to be a helper function for\n`backward`. Implement `compute_column` before you start implementing\n`backward`.\n</div>\n\nIn `TextBuffer.cpp`, efficiently implement the interface functions for manipulating editors\ngiven in the definition of the ``TextBuffer`` class in\n``TextBuffer.hpp``.\n\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `TextBuffer_tests.cpp.starter` -> `TextBuffer_tests.cpp`\n\nCreate a new file `TextBuffer.cpp`. Add function stubs for all the\nfunctions in `TextBuffer.hpp`. Remember to `#include\n\"TextBuffer.hpp\"`.\n\n### Testing the TextBuffer\n\nThe `TextBuffer` tests should compile and run once you have created\n`TextBuffer.cpp` and added function stubs. The public tests will fail\nuntil you implement the functions. The file for your test cases\n(`TextBuffer_tests.cpp`) will pass because it initially only contains\n`ASSERT_TRUE(true)`.\n\n```console\n$ make TextBuffer_public_tests.exe\n$ ./TextBuffer_public_tests.exe\n$ make TextBuffer_tests.exe\n$ ./TextBuffer_tests.exe\n```\n{: data-variant=\"no-line-numbers\" }\n\n### Interactive Testing\n\nYou can also test your `TextBuffer` implementation interactively by\ncompiling and running the provided `line.cpp`, which visualizes the\ncontents of a text buffer. Make sure your code passes the tests in `TextBuffer_public_tests.cpp` (see above) before using the interactive tests in `line.cpp`.\n\n```console\n$ make line.exe\n$ ./line.exe\nLINE Is Not an Editor -- it is a linear visualization of a TextBuffer.\nThe '<' character mimics a call to backward()\nThe '>' character mimics a call to forward()\nThe '#' character mimics a call to remove()\nThe '^' character mimics a call to up()\nThe '!' character mimics a call to down()\nThe '[' character mimics a call to move_to_row_start()\nThe ']' character mimics a call to move_to_row_end()\nThe '@' character mimics a call to insert() with a newline\nAll other characters just mimic insert() with that character\n\nGive initial input (empty line quits):\n\n```\n{: data-variant=\"no-line-numbers\" }\n\nTry entering `steady^<<<<^>>^>>^@<<@^^` as the initial input. Here are\nthe first few lines of the result:\n\n```console\nGive initial input (empty line quits):\nsteady^<<<<^>>^>>^@<<@^^\nSTARTING\nstart : |       :(1,0 )\nadd   : s|      :(1,1 )\nadd   : st|     :(1,2 )\nadd   : ste|    :(1,3 )\nadd   : stea|   :(1,4 )\nadd   : stead|  :(1,5 )\nadd   : steady| :(1,6 )\nup    : steady| :(1,6 )\nleft  : stead|y :(1,5 )\nleft  : stea|dy :(1,4 )\n```\n\nThe special commands directly invoke the corresponding member\nfunctions in the `TextBuffer` class. If an operation cannot be\nperformed (e.g., invoking the `up()` member function to move the\ncursor up a line when it is already at the first row), the function\nshould leave the text buffer **unchanged** instead of raising an error\nor assertion violation.\n\nWe have provided two test cases that use `line.exe`, which you can\nrun as follows:\n\n``` console\n$ ./line.exe < line_test1.in > line_test1.out\n$ diff -qB line_test1.out line_test1.out.correct\n$ ./line.exe < line_test2.in > line_test2.out\n$ diff -qB line_test2.out line_test2.out.correct\n```\n{: data-variant=\"no-line-numbers\" }\n\nAlternatively, use\n\n``` console\n$ make test\n```\n{: data-variant=\"no-line-numbers\" }\n\nto run all `List` and `TextBuffer` tests.\n\n### Visual Text Editors\n\nThe starter files include two visual frontends, `e0` and `femto`, that use your\n`TextBuffer` class to implement a fully functional, terminal-based editor. You\nmay use these to stress test your `TextBuffer` implementation, but we recommend\nyou ensure your code passes both the `TextBuffer_public_tests` and `line` interactive\ntests described above before testing with either editor.\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\nYou may need to install the\n[ncurses](https://en.wikipedia.org/wiki/Ncurses) library before you\ncan use the visual editors. On WSL, run:\n\n```console\n$ sudo apt install libncurses5-dev\n```\n{: data-variant=\"no-line-numbers\" }\n\nOn macOS, run:\n\n```console\n$ brew install ncurses\n```\n{: data-variant=\"no-line-numbers\" }\n\nClose your terminal and reopen your terminal.\n</div>\n\nThe first visual editor is called *E0*, and you can compile and run it\nas follows:\n\n```console\n$ make e0.exe\n$ ./e0.exe\n```\n{: data-variant=\"no-line-numbers\" }\n\nThis will launch a visual editor that will allow you to type text, use\ndelete or backspace to remove characters, and use the arrow and\nhome/end keys to navigate the text. The key combination `Ctrl-X` exits\nthe editor.\n\n<img src=\"img/e0-light.png#gh-light-mode-only\" width=\"640px\" class=\"no-border\" />\n<img src=\"img/e0-dark.png#gh-dark-mode-only\" width=\"640px\" class=\"no-border\" />\n\nThe second visual editor is called *FEMTO*, and it provides much of\nthe functionality of terminal editors such as \n[Pico](https://en.wikipedia.org/wiki/Pico_(text_editor)). Use the following\nto compile and run it:\n\n```console\n$ make femto.exe\n$ ./femto.exe\n```\n{: data-variant=\"no-line-numbers\" }\n\nYou can also specify a filename at the command line. For instance, we\ncan examine the visual editor's own source code with\n\n```console\n$ ./femto.exe femto.cpp\n```\n{: data-variant=\"no-line-numbers\" }\n\nYou should see something like the following:\n\n<img src=\"img/femto-light.png#gh-light-mode-only\" width=\"720px\" class=\"no-border\" />\n<img src=\"img/femto-dark.png#gh-dark-mode-only\" width=\"720px\" class=\"no-border\" />\n\nYou can scroll between pages with the page-up and page-down keys (or\njust the up and down keys at the top and bottom rows), and you can use\nthe special commands listed at the bottom - for example, `^X` means\nthe combination `Ctrl-X`, which you can use to exit.\n\n## Submission and grading\n\nSubmit these files to the [autograder](https://autograder.io).\n  - `List.hpp`\n  - `List_tests.cpp`\n  - `TextBuffer.cpp`\n\nThis project will be autograded for correctness, comprehensiveness of\nyour test cases, and programming style. See the [style checking\ntutorial](https://eecs280staff.github.io/tutorials/setup_style.html)\nfor the criteria and how to check your style automatically on CAEN.\n\n### Testing\n\nCheck for memory leaks using the [Leak checking tutorial](https://eecs280staff.github.io/tutorials/setup_leakcheck.html).\n\nRun all the unit tests and system tests.  This includes the public tests we provided and the unit tests that you wrote.\n\n```console\n$ make test\n```\n{: data-variant=\"no-line-numbers\" }\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Run commands in parallel with `make -j`.\n```console\n$ make -j4 test\n```\n{: data-variant=\"no-line-numbers\" }\n</div>\n\n\n### Unit Test Grading\n\nWe will autograde your `List` unit tests. We will **not** grade your\n`TextBuffer` tests.\n\nYour unit tests must use the [unit test framework](https://eecs280staff.github.io/unit_test_framework/).\n\nA test suite must complete less than 5 seconds and contain 50 or fewer `TEST()` items.  One test suite is one `_tests.cpp` file.\n\nTo grade your unit tests, we use a set of intentionally buggy instructor solutions.  You get points for catching the bugs.\n\n1.  We compile and run your unit tests with a **correct solution**.\n    - Tests that pass are **valid**.\n    - Tests that fail are **invalid**, they falsely report a bug.\n3.  We compile and run all of your **valid** tests against each **buggy solution**.\n    - If any of your tests fail, you caught the bug.\n    - You earn points for each bug that you catch.\n\n### Requirements and restrictions\n\nIt is our goal for you to gain practice with good C++ code, classes,\nand dynamic memory.\n\n| DO                                                                                                                                                              | DO NOT                                                                                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Modify `.cpp` files and `List.hpp` | Modify the signature of any public functions in `List.hpp` or `TextBuffer.hpp`  |\n| For `List`, make helper member functions private | Modify the public interface of `List` or `TextBuffer` |\n| Use any part of the STL except for containers in your `List` implementation | Use STL containers in your implementation of `List` |\n| `#include` a library to use its functions | Assume that the compiler will find the library for you (some do, some don't) |\n| Use C++ strings  | Use C-strings |\n| Pass large structs or classes by reference | Pass large structs or classes by value |\n| Pass by const reference when appropriate | \"I don't think I'll modify it ...\" |\n| Use the [Address Sanitizer](https://eecs280staff.github.io/tutorials/setup_asan.html) to check for memory errors | \"It's probably fine...\" |\n\n## Acknowledgments\n\nThis project has been adapted from the course 15-122 (Principles of\nImperative Computation) offered at Carnegie Mellon University, which\nis taught in a safe subset of C called *C0*. This project was ported to\nC++ by Saquib Razak.\n\nThis document is licensed under a [Creative Commons Attribution-NonCommercial 4.0 License](https://creativecommons.org/licenses/by-nc/4.0/). You're free to copy and share this document, but not to sell it.  You may not share source code provided with this document.\n", "extracted_entities": ["EECS 280", "Fall 2024", "November 25, 2024", "Pico", "nano", "Emacs", "vi", "VS Code", "Visual Studio", "Xcode", "TextBuffer", "List", "std::list", "ncurses", "E0", "FEMTO", "GitHub"], "extracted_triples": [["EECS 280", "is a course for", "Fall 2024"], ["Project", "due on", "November 25, 2024"], ["TextBuffer", "is implemented using", "List"], ["List", "is similar to", "std::list"], ["TextBuffer", "holds", "editable sequence of characters"], ["TextBuffer", "has a cursor position", "current row and column"], ["Pico", "is a type of", "terminal editor"], ["nano", "is a type of", "terminal editor"], ["Emacs", "is a type of", "terminal editor"], ["vi", "is a type of", "terminal editor"], ["VS Code", "is an IDE used for", "C++ projects"], ["Visual Studio", "is an IDE used for", "C++ projects"], ["Xcode", "is an IDE used for", "C++ projects"], ["E0", "is a visual editor that uses", "TextBuffer"], ["FEMTO", "is a visual editor that uses", "TextBuffer"], ["ncurses", "is a library needed for", "visual editors"], ["GitHub", "is used for", "version control"]]}, {"idx": "chunk-b49f13e04395d1d33b9ff49fe35c9778", "passage": "---\nlayout: spec\nlatex: true\n---\n\nEECS 280 Project 1: Statistics\n==============================\n{: .primer-spec-toc-ignore }\n\nDue 8pm ET Mon Jan 27, 2025.  This is an individual project.\n\nWinter 2025 release.\n\n<div class=\"primer-spec-callout info\">\n  <p><strong>IMPORTANT</strong> If you are retaking the course, please note the project has changed significantly this term. While we always suggest students retaking the course redo the entire project from scratch (as it is helpful practice), we nevertheless want to emphasize you must work from a fresh set of starter files.</p>\n</div>\n\n## Introduction\n\nStatistical analysis is a key tool in many fields, from the natural and medical sciences to social sciences and business. It's used to summarize data, make inferences about populations, and test hypotheses. The intersection of statistical analysis and computation also underlies many emerging fields like machine learning and data science.\n\nIn this project, you'll implement a program that computes descriptive statistics and performs two-sample analysis on a given data set. \n\nFor example, consider data from [How Couples Meet and Stay Together (HCMST)](https://exhibits.stanford.edu/data/catalog/ns183dp7831), a study of how Americans meet their spouses and romantic partners. We can investigate the age (`ppage`) of survey respondents depending on whether or not they met their partner online (`q24_met_online`).\n\nAs shown below, our program displays descriptive statistics for respondents' age in the two groups. It also runs a 95% confidence interval procedure for the difference in means between the groups, meaning there is a 95% chance the interval computed from the sample contains the true value of the difference in means among the overall population. Overall, we can be reasonbly confident the mean age of people who met their partner online is several years younger than those who did not.\n\n```console\n$ ./two_sample.exe HCMST_ver_3.04.tsv q24_met_online 1 0 ppage\nreading column q24_met_online from HCMST_ver_3.04.tsv\nreading column ppage from HCMST_ver_3.04.tsv\nGroup A: ppage | q24_met_online = 1\ncount = 270\nsum = 10687\nmean = 39.5815\nstdev = 12.2103\nmedian = 40.5\nmin = 19\nmax = 86\n  0th percentile = 19\n 25th percentile = 29\n 50th percentile = 40.5\n 75th percentile = 49\n100th percentile = 86\n\nGroup B: ppage | q24_met_online = 0\ncount = 2664\nsum = 125721\nmean = 47.1926\nstdev = 16.1446\nmedian = 46\nmin = 19\nmax = 95\n  0th percentile = 19\n 25th percentile = 35\n 50th percentile = 46\n 75th percentile = 58\n100th percentile = 95\n\nConfidence interval for mean(ppage | A) - mean(ppage | B):\n  95% [-9.31595, -6.05068]\n\n```\n{: data-variant=\"no-line-numbers\" }\n\n## Learning Goals\n\nThe learning goals of this project include C++ fundamentals, control-flow structures, vectors, procedural abstraction, and unit testing. It's also a chance to get used to the C++ toolchain and review your 100-level programming skills. No prior knowledge of probability or statistics is required or expected for this project.\n\n## Setup\n\nSet up your project in your visual debugger.  We recommend VS Code because it's easier to use.  Many people use Visual Studio (Windows) or XCode (macOS).\n\nDuring setup, name your project `stats`. Use this starter files link: `https://eecs280staff.github.io/stats/starter-files.tar.gz`\n\n| [VS Code Tutorial (recommended)](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio Tutorial](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode Tutorial](https://eecs280staff.github.io/tutorials/setup_xcode.html) |\n\nIf you created a `main.cpp` while following the setup tutorial, delete it. You'll use the provided starter code for `two_sample.cpp` instead. You should end up with a folder with starter files that looks like this. (You may have already renamed files like `two_sample.cpp.starter` to `two_sample.cpp`.)\n\n```console\n$ ls\nMakefile          library.cpp  stats_public_tests.cpp\ncats.csv          library.hpp  stats_tests.cpp.starter\ncats.out.correct  stats.hpp    two_sample.cpp.starter\n```\n{: data-variant=\"no-line-numbers\"}\n\nHere's a short description of each file in this project.\n\n| File | Description |\n|----- |---- |\n| `Makefile` | Helper commands for building and testing |\n| `stats.hpp` | Function prototypes for statistics library |\n| `stats.cpp` | Function implementations for statistics library |\n| `stats_public_tests.cpp` | Public tests for the statistics library |\n| `stats_tests.cpp` | Your tests for the statistics library |\n| `library.cpp` | Provided code implementations |\n| `library.hpp` | Provided code function prototypes |\n| `two_sample.cpp` | Two-sample analysis program |\n| `cats.csv` | A small dataset for testing the analysis program |\n| `cats.out.correct` | Correct outputs of analysis program on cats.csv |\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Pitfall:** Make sure you have set up your visual debugger before continuing.\n\n| [VS Code Tutorial (recommended)](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio Tutorial](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode Tutorial](https://eecs280staff.github.io/tutorials/setup_xcode.html) |\n\n</div>\n\n## Statistics Background\nThis section provides an introduction to the statistical analyses you'll implement in this project.\n\n\n### Descriptive Statistics\nDescriptive statistics are computed properties that quantitatively summarize the underlying distribution of measured data. For example, the *mean* of a data set is a measure of its central tendency whereas the *standard deviation* measures how spread out the data are. Details of several descriptive statistics are given in the [Statistics Functions](#statistics-functions) section below.\n\n### Sampling\nWe often estimate qualities of a large *population* by measurement of a relatively small *sample*. For instance, we might want to know how many US residents are currently in a relationship, the distribution of age among these people, and whether they met their partner online or in-person. Rather than ask over 300 million people these questions, we might survey a subset of a few thousand people.\n\nThere are many essential considerations for proper survey procedure. For example, obtaining a random, unbiased sample of survey participants is important to ensure the sample is representative of the overall population. On the other hand, special attention (e.g. oversampling) may be needed to ensure underrepresented groups are not marginalized. Survey designers should mitigate potential threats to validity such as response bias (e.g. survey answers may be affected by perceived social desirability of answers). These considerations are important, but beyond the scope of this project.\n\n### Two-Sample Analysis\nWe may also want to compare two different samples via statistical analysis and make inferences about the underlying populations they represent. We might survey different populations entirely separately, or partition a data set into subgroups based on specific criteria. For example, we might filter responses to the HCMST survey based on whether people met their partner online or not, yielding two samples representing distinct populations. Then, we could compute the mean age for each sample, as well as the difference between those means, finding that to be approximately 7.6 years older for the sample of people who did not meet their partner online.\n\nHowever, inferences drawn from samples must be qualified in a way that accounts for the probability the observed difference is due to random chance (i.e. the uncertainty introduced by sampling). It would not be responsible to simply report the 7.6 point estimate as the difference in means among the underlying populations.\n\n#### Bootstrap Confidence Intervals\nInstead of reporting a single estimate based on a sample, we instead set up a procedure for computing a range of possible values (i.e. lower and upper bounds) defining a *confidence interval* at a particular *confidence level* of X%. The interpretation is as follows: *If we collected many samples (i.e. ran the survey many times), X% of the time the computed confidence interval would contain the true underlying value among the population*.\n\nOf course, it's not practical to actually conduct the survey many times, so we instead use an approach called *bootstrap resampling*. The essential idea is that we simulate taking several samples by instead re-sampling (with replacement) from one original sample.\n\nFor example, assume the original sample contained individuals [A, B, C, D]. Bootstrap resamples of this could be [A, C, C, D] or [A, A, A, B]. Each approximates a plausible sample we could have drawn from the underlying population (i.e. a resample of [A, A, A, B] approximates a sample that happened to have more people like A and less like C or D).\n\nWe can compute the statistic of interest (e.g. the difference in means) for many resamples to obtain an approximate *sampling distribution* from which we can compute a confidence interval.\n\nLet's apply this to our running example. We start with the original two samples of people who did or did not meet their partner online. Then, we repeat this process 1000 times:\n1. Generate a bootstrap resample for each of the two original samples.\n2. Compute the difference in means between the two resamples.\n3. Record the computed value.\n\nFinally, we determine the range containing the middle 95% of the values computed via resampling and report this as the 95% confidence interval.\n\nThe starter code for `two_sample.cpp` provides much of the overall structure for computing bootstrap confidence intervals and includes comments to guide you through implementing the rest.\n\nYou might also find this [video](https://www.youtube.com/watch?v=Xz0x-8-cgaQ) on bootstrapping helpful, which covers the same basic ideas described above. While there are many approaches to find confidence intervals, we chose bootstrapping for this project due to its uniquely computational approach that is well-suited for a programming project.\n\n## Statistics Library\n\nThe `stats.hpp` file specifies a general-purpose statistics library, including declarations and RME interface specifications of several functions for computing descriptive statistics and filtering data. You'll write implementations for each of these functions in `stats.cpp`.\n\nThe data sets are stored as a `std::vector<double>`. If you haven't used vectors in C++ before, check out our [Vector Reference](vector.html).  C++ vectors are similar to Java ArrayLists, Javascript arrays, and Python lists.\n\n### Setup\n\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n\n-  `stats_tests.cpp.starter` -> `stats_tests.cpp`\n\nAdd a new file `stats.cpp` containing a \"function stub\" for each prototype in `stats.hpp`, as shown below. Adding stubs ensures the program can compile, even though not everything is finished yet. The `assert(false);` in each is a placeholder that triggers an error if an unfinished function were to run - you should remove them once you implement each function.\n\n```c++\n// stats.cpp\n#include \"stats.hpp\"\n#include <cassert>\n#include <vector>\n#include <algorithm> // sort\n#include <cmath> // sqrt, modf\n\nusing namespace std;\n\nint count(vector<double> v) {\n  assert(false);\n}\n\ndouble sum(vector<double> v) {\n  assert(false);\n}\n\ndouble mean(vector<double> v) {\n  assert(false);\n}\n\ndouble median(vector<double> v) {\n  assert(false);\n}\n\ndouble min(vector<double> v) {\n  assert(false);\n}\n\ndouble max(vector<double> v) {\n  assert(false);\n}\n\ndouble stdev(vector<double> v) {\n  assert(false);\n}\n\ndouble percentile(vector<double> v, double p) {\n  assert(false);\n}\n\nvector<double> filter(vector<double> v,\n                      vector<double> criteria,\n                      double target) {\n  assert(false);\n}\n```\n{: data-title=\"stats.cpp\" }\n\nOnce you've added the stubs, you can compile and run the public tests.\n\n```console\n$ make stats_public_tests.exe\n$ ./stats_public_tests.exe\n```\n\nThe tests should compile successfully but won't pass until you've implemented each function.\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Pitfall:** Do not include a `main()` function in your `stats.cpp` file.  Remember, `stats.cpp` is a library of functions that another module like `two_sample.cpp` will use.\n</div>\n\n### Statistics Functions\n\nThis section provides background for each statistical method and tips for implementation.\n\n#### General Tips\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Your implementation of some functions may require sorting the input vector. You can use the `std::sort()` function from the `<algorithm>` library for this. Here's an example:\n\n```c++\nvector <double> v; // assume v contains some data\nstd::sort(v.begin(), v.end());\n```\n</div>\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Pitfall:** If you're getting errors like this, check out the [Comparisons tutorial](comparisons.html).\n\n```\nerror: comparison between signed and unsigned integer expressions\n```\n</div>\n\n#### `count()`, `sum()`, `mean()`\n\nThe `count()` function returns the number of values in a data set.\n\nThe `sum()` function computes the *sum* of the values in a data set.\n\nThe `mean()` function computes the *arithmetic mean* of a data set:\n\n  $$\n  \\bar{x} = \\frac{1}{n}\\left(\\sum_{i=1}^n x_i\\right) = \\frac{x_1 + x_2 + \\dots + x_n}{n}\n  $$\n\nHere, $$\\bar{x}$$ denotes the mean, $$x_i$$ denotes the value of the $$i$$th data point, and $$n$$ is the sample size.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Call `count()` and `sum()` as helper functions in your implementation of `mean()`.\n</div>\n\n#### `median()`\n\nComputes the *median*, which is the \"middle\" value in a data set. In other words, it is the value for which half the data points lie below the value, and half lie above it. If the number of data values $$n$$ is odd, this is just the middle value when the data set is sorted. If the number of data values is even, then it is the average of the two values in the middle.\n\n#### `min()`, `max()`\nThese functions return the *minimum* and *maximum* values in the data set.\n\n#### `stdev()`\n\nThe `stdev()` function computes the *standard deviation*, which is a measure of the \"spread\" among data values. For instance, while the data sets $$(2, 2, 2)$$ and $$(1, 2, 3)$$ have the same mean of 2, the latter set has a higher standard deviation than the former one since the values are more spread apart. We specifically use the [corrected sample standard deviation](https://en.wikipedia.org/wiki/Standard_deviation#Corrected_sample_standard_deviation), which is defined as:\n\n  $$\n  s_x = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n(x_i-\\bar{x})^2}\n  $$\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Pitfall:** Make sure that your code is doing floating-point rather than integer division.\n\n``` c++\ndouble x = 1 / 4;    // integer division: x is 0\ndouble y = 1.0 / 4;  // floating-point division: y is 0.25\n```\n</div>\n\nWhen writing `stdev()`, use the [`sqrt()` function](https://cplusplus.com/reference/cmath/sqrt/), which calculates a square root.\n\n```c++\n#include <cmath>\n// ...\ncout << \"the square root of 4 is \" << sqrt(4) << \"\\n\";\n```\n\n#### `percentile()`\n\nA call to `percentile(data, p)` computes the $$ p^{th} $$ *percentile* for a fractional value $$0 \\le p \\le 1$$, which is the threshold below which a portion $$p$$ of the data occurs. For example, `percentile(data, 0.3)` returns the value below which 30% of the data occur.\n\nWe use the percentile formula that is implemented in many software packages, which estimates the percentile $$v_p$$ for a fraction $$p$$ as follows:\n\n  1. Compute the *rank*, which is the approximate position in the (<mark>sorted</mark>) data set corresponding to the fraction:\n\n     $$\n     rank = p(n-1) + 1\\text{, for $0 \\le p \\le 1$}\n     $$\n\n  2. Split the rank into its integer and decimal components $$k$$ and $$d$$ respectively, so that\n\n     $$\n     rank = k + d\\text{, where $k$ is an integer and $0 \\le d < 1$}\n     $$\n\n  3. Then the percentile $$v_p$$ is\n\n     $$\n     v_p = v_k + d(v_{k+1} - v_k)\\text{, for $1 \\le k \\le n$}\n     $$\n\n     where $$v_k$$ is the $$k$$th data point from the sorted data set. Essentially, $$v_p$$ is the weighted average of the $$k$$th and $$(k+1)$$th data points in the <mark>sorted</mark> set, with the weight of each value determined by the decimal component $$d$$: a weight of $$d$$ for the $$(k+1)$$th value and a weight of $$1-d$$ for the $$k$$th value.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Use the [`modf()` function](http://www.cplusplus.com/reference/cmath/modf/) to break a double into its integral and fractional parts.\n\n```c++\n#include <cmath>\n// ...\ndouble pi = 3.14159265;\ndouble intpart = 0;\ndouble fractpart = 0;\nfractpart = modf(pi, &intpart);\n// intpart is now 3, factpart is now 0.14159265\n```\n</div>\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Pitfall:** The formula here and the worked example below use indices that start with 1. You will need to adapt them for `vector` indexing, which starts at 0.\n</div>\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Pitfall:** Consider an example dataset with 5 elements. For p=1, the above formula gives:\n$$\nv_{1.0} = v_5 + 0(v_6-v_5)\n$$\n\nThis includes a nonexistent datapoint - $$v_6$$! Mathematically, everything works out because it gets multiplied by 0. However, you must ensure your implementation code never even attempts to access out-of-bounds data, which can cause undefined behavior, including a program crash (regardless of whether it would be canceled out later in the formula).\n</div>\n\n**Worked Example of Percentile Computation**  \nSuppose that our data set consists of the values $$35, 20, 15, 50, 40$$. What is the 40th percentile from this data set?\n\nFirst, we sort the values to obtain the ordered sequence\n\n$$\n(v_1, v_2, v_3, v_4, v_5) = (15, 20, 35, 40, 50)\n$$\n\nThen, we calculate the rank for $$p = 0.4$$:\n\n$$\nrank = 0.4(5 - 1) + 1 = 2.6\n$$\n\nSplitting this into integer and decimal components, we have\n\n$$\nrank = k + d = 2 + 0.6\n$$\n\nWe then calculate the percentile as\n\n$$\nv_{0.4} = v_k + d(v_{k+1}-v_k) = v_2 + 0.6(v_3-v_2) = 20 + 0.6(35-20) = 29\n$$\n\nThus, the 40th percentile is 29.\n\n\n#### `filter()`\n\nThe `filter()` function separates out the portion of a data set where some measured criterion has a particular value. For example:\n\n```c++\n// Data set of temperatures measured at different locations.\n// e.g. the first measurement was at location 0 with temperature 15.5\nvector<double> locations = {0, 1, 0, 1, 1, 2, 2, 0, 1};\nvector<double> temps = {15.5, 23.1, 7.8, 19.2, 22.6, 4.6, 1.9, 14.3, 18.0};\n\n// Filter to the temperature measurements at location 1\nvector<double> temps_1 = filter(temps, locations, 1);\n// temps_1 is {23.1, 19.2, 22.6, 18.0}\n```\n\n### Testing\n\nThere are two sets of unit tests for the stats module.\n\n**1. Public Tests in `stats_public_tests.cpp`**  \nA minimal set of public tests that we provide (and that match the ones on the autograder). Passing these is a good first target, but is generally not sufficient to ensure correctness. Compile and run the public stats tests with:\n\n```console\n$ make stats_public_tests.exe\n$ ./stats_public_tests.exe\n```\n\n**2. Your Tests in `stats_tests.cpp`**  \nWrite your own comprehensive set of unit tests in `stats_tests.cpp` for each of the statistics functions declared in `stats.hpp`. Use `assert()` to verify the results of the function are as expected when called on a variety of inputs, including any relevant special cases. Keep your tests organized by splitting them into separate helper functions, as in the provided example in the `stats_tests.cpp` starter file.\n\nCompile and run your tests with:\n\n```console\n$ make stats_tests.exe\n$ ./stats_tests.exe\n```\n\nYou will submit `stats_tests.cpp` to the autograder. You must write at least one test for each function in `stats.hpp`, but it's a good idea to write more. Generally speaking, your tests should not produce output to `cout` - the autograder will ignore such output, and you should use `assert()` to verify expected behavior.\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Pitfall:** Due to rounding errors, two floating point numbers we expect to be equal may be slightly different. This might happen while testing `stdev()`. Check out the [Floating-point Comparisons tutorial](comparisons.html#floating-point-comparisons).\n</div>\n\n### Debugging\n\nUse your IDE's visual debugger for either the public tests or your own tests.\n\nFor example, you might set a breakpoint in the unit test that is failing, before your function from `stats.cpp` is called. Then you can use the debugger to step into the function and see what's going wrong.\n\nHere's a reminder of how to configure the debugger to launch either the public tests or your own tests:\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  First, compile from the terminal using `make stats_public_tests.exe`.\n  \n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/stats_public_tests.exe`\n  \n  Click the run button in the debugging tab of the left side panel.\n  </td>\n  <td markdown=\"1\">\n  First, compile from the terminal using `make stats_tests.exe`.\n\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/stats_tests.exe`\n  \n  Click the run button in the debugging tab of the left side panel.\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  First, compile from the terminal using `make stats_public_tests.exe`.\n  \n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/stats_public_tests.exe`\n  \n  Click the run button in the debugging tab of the left side panel.\n  </td>\n  <td markdown=\"1\">\n  First, compile from the terminal using `make stats_tests.exe`.\n\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/stats_tests.exe`\n  \n  Click the run button in the debugging tab of the left side panel.\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>XCode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `stats_public_tests.cpp`, `stats.cpp`, `library.cpp`\n\n  Click the run button.\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `stats_tests.cpp`, `stats.cpp`, `library.cpp`\n\n  Click the run button.\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `stats_public_tests.cpp`\n  - Exclude `stats_tests.cpp`, `two_sample.cpp`, `main.cpp` (if present)\n\n  Click the run button.\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `stats_tests.cpp`\n  - Exclude `stats_public_tests.cpp`, `two_sample.cpp`, `main.cpp` (if present)\n\n  Click the run button.\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Submit\nSubmit `stats.cpp` and `stats_tests.cpp` to the Autograder using the direct link in the [Submission and Grading section](#submission-and-grading).\n\n\n## Analysis Program\n\nOur statistical analysis program is run like this:\n\n```console\n$ ./two_sample.exe HCMST_ver_3.04.tsv q24_met_online 1 0 ppage\n```\n\nIt takes command-line arguments for the data file name (`HCMST_ver_3.04.tsv`), a filter column name (`q24_met_online`), filter A/B values (`0` and `1`), and a data column name to analyze (`ppage`).\n\nWhen run, it reads data from the specified file and columns and splits into groups on the filter column and A/B values. Then, it prints descriptive statistics for the data column on each group, as well as a 95% confidence interval for the difference in means between the two groups.\n\nThe program may also be run for testing purposes with no command-line arguments provided:\n\n```console\n$ ./two_sample.exe\n```\n\nIn this case, the program uses default arguments of `cats.csv`, `food`, `1`, `2`, and `weight`, performing an analysis of the weights of cats in the provided `cats.csv` sample data set according to which brand of cat food (i.e. #1 or #2) they eat.\n\n### Setup\n\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n\n-  `two_sample.cpp.starter` -> `two_sample.cpp`\n\nIf you created a `main.cpp` while following the setup tutorial, you should delete it.\n\n### Data Sets\n\nThe analysis program can be run with any input data file in a standard delimited format (e.g. a `.csv` comma-separated value file or `.tsv` tab-separated value file) with a header row containing column names.\n\n#### Sample Data Set: Cats\nWe've provided a small data set in `cats.csv` for testing purposes:\n\n```csv\nname,food,weight\nFluffy,1,9.6\nSocks,1,11.5\nMittens,1,9.9\nFelix,1,10.1\nLuna,1,11.2\nSimba,2,9.2\nNala,2,7.8\nOliver,2,12.3\nBella,2,10.1\nMilo,2,10.9\n```\n\nWhen the program is run without command-line arguments, it defaults to use this data set, analyzing the weights of group A (fed food #1) and group B (fed food #2). The correct program output for this case is provided in `cats.out.correct`.\n\n\n#### Real Data Set: HCMST\n\n[How Couples Meet and Stay Together (HCMST)](https://exhibits.stanford.edu/data/catalog/ns183dp7831) is a study of how Americans meet their spouses and romantic partners.\n\nWant to try it out with real data from the [How Couples Meet and Stay Together](https://exhibits.stanford.edu/data/catalog/ns183dp7831) study?\n1.  Use the following `wget` link to download the data in tsv format: `https://eecs280staff.github.io/stats/data/HCMST_ver_3.04.tsv`.\n2.  The variables in the study are the first line of the tsv file.\n3.  Another file called the codebook describes the variables. It can be accessed here: [https://stacks.stanford.edu/file/druid:ns183dp7831/HCMST_codebook_3_04.pdf](https://stacks.stanford.edu/file/druid:ns183dp7831/HCMST_codebook_3_04.pdf).\n\n### Overview\n\nComplete the code in `two_sample.cpp` to implement the two-sample analysis program. The starter code handles several tasks for you, including reading command-line arguments, reading data from an input file, and the high-level structure of the two-sample analysis. You should spend some time reading through the file to familiarize yourself with the provided code.\n\nYou will need to implement the following functions in `two_sample.cpp`:\n- `print_descriptive_stats()`: Prints descriptive statistics for a given data set.\n- `mean_diff_sampling_distribution()`: Returns an approximation of the sampling distribution of the difference in means between two groups, computed using bootstrap resampling.\n- `confidence_interval()`: Returns a confidence interval for a given data set and interval width.\n\nNote the provided file contains `// TODO` comments and `assert(false);` placeholders for each function you need to implement. You should remove these as you complete each function. We have also provided `// HINT` comments with specific guidance.\n\n### Program Walkthrough\n\nLet's walk through complete example of the two-sample analysis program. First, we'll compile and run the program at the command line.\n\n```console\n$ make two_sample.exe\n$ ./two_sample.exe\n```\n\nNext, let's walk through the program and its output, step-by-step.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Note the spacing and formatting of the output in the example below. Your program should match this format exactly.\n</div>\n\nThe program starts in `main()`. Since no command-line arguments are provided, the program defaults to using `cats.csv` for the filename, `food` for the filter column, `1`/`2` for the A/B criteria, and `weight` for the data column. These are passed into the `two_sample_analysis()` function.\n\nThe `two_sample_analysis()` function calls `extract_columns()` to read from the input file, which prints an informational message.\n\n```console\nreading column food from cats.csv\nreading column weight from cats.csv\n```\n{: data-variant=\"no-line-numbers\" }\n\nIt then filters into groups A and B. It prints a header for group A, calls your `print_descriptive_stats()` function on group A, and prints an extra blank line. Then it does the same for group B.\n\n```console\nGroup A: weight | food = 1\ncount = 5\nsum = 52.3\nmean = 10.46\nstdev = 0.838451\nmedian = 10.1\nmin = 9.6\nmax = 11.5\n  0th percentile = 9.6\n 25th percentile = 9.9\n 50th percentile = 10.1\n 75th percentile = 11.2\n100th percentile = 11.5\n\nGroup B: weight | food = 2\ncount = 5\nsum = 50.3\nmean = 10.06\nstdev = 1.70088\nmedian = 10.1\nmin = 7.8\nmax = 12.3\n  0th percentile = 7.8\n 25th percentile = 9.2\n 50th percentile = 10.1\n 75th percentile = 10.9\n100th percentile = 12.3\n\n```\n{: data-variant=\"no-line-numbers\" }\n\nIt then computes a 95% confidence interval for the difference in means between groups A and B by calling your `mean_diff_sampling_distribution()` and `confidence_interval()` functions. Then it prints a header and the confidence interval.\n\n```console\nConfidence interval for mean(weight | A) - mean(weight | B):\n  95% [-0.28, 1.2005]\n```\n{: data-variant=\"no-line-numbers\" }\n\n### Testing\n\nEnsure you've saved all files and compiled your most recent code.\n\n```console\n$ make two_sample.exe\n```\n\nRun the program (which defaults to using the `cats.csv` sample data set) and save the output to a file with [output redirection](https://eecs280staff.github.io/tutorials/cli.html#output-redirection-).\n```console\n$ ./two_sample.exe > cats.out\n```\n{: data-variant=\"no-line-numbers\" }\n\nCompare saved output (`cats.out`) with the instructor-provided correct output (`cats.out.correct`). If the `diff` command finishes with no output, that means the files are identical.\n```console\n$ diff cats.out cats.out.correct\n```\n{: data-variant=\"no-line-numbers\" }\n\nYou may also open `cats.out` in your editor for manual inspection or use the [`cat`](https://eecs280staff.github.io/tutorials/cli.html#cat) command to print it at the terminal. (Note that it's simply a coincidence the command is also called `cat`.)\n\nYou can also use the `Makefile` to [run all tests](#testing-2).\n```console\n$ make test\n```\n\n### Debugging\n\nUse your IDE's visual debugger to track down issues in your implementation of `two_sample.cpp`.\n\nFor example, if your printed descriptive statistics don't match, you might set a breakpoint shortly before the first mismatched line. Or, if the confidence interval is computed incorrectly, you can strategically set a breakpoint in-between various steps of the algorithm to check at which point something goes wrong.\n\nHere's a reminder of how to configure the debugger to launch the two-sample analysis program:\n\n<table>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  First, compile from the terminal using `make two_sample.exe`.\n\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/two_sample.exe`\n\n  Click the run button in the debugging tab of the left side panel.\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  First, compile from the terminal using `make two_sample.exe`.\n\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/two_sample.exe`\n\n  Click the run button in the debugging tab of the left side panel.\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>XCode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `two_sample.cpp`, `stats.cpp`, `library.cpp`\n\n  Click the run button.\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `two_sample.cpp`\n  - Exclude `stats_public_tests.cpp`, `stats_tests.cpp`, `main.cpp` (if present)\n\n  Click the run button.\n  </td>\n</tr>\n</tbody>\n</table>\n\nIf you choose to run the program with custom command-line arguments, you'll need to configure them in your visual debugger ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)). For example, for the HCMST example in the project introduction, you would use the following arguments: `HCMST_ver_3.04.tsv q24_met_online 1 0 ppage`.\n\n## Submission and Grading\n\nSubmit `stats.cpp`, `stats_tests.cpp`, and `two_sample.cpp` to the autograder using this direct autograder link: [https://autograder.io/web/project/3033](https://autograder.io/web/project/3033).\n\nWe will grade your code on functional correctness and the presence of test cases.\n\n### Testing\nRun all the public tests locally, including the public stats tests, your stats unit tests, and the two-sample analysis on the cats data set.\n\n```console\n$ make test\n```\n\n### Requirements and Restrictions\n\nUse only the provided `bootstrap_resample()` function declared in `library.hpp` to perform resampling with replacement and ensure you pass in the current 0-indexed iteration number - this is necessary to ensure consistent pseudorandom number generation for autograding purposes.\n\n\n## Acknowledgments\nThe original project was written by Andrew DeOrio, Spring 2015. It was revised in Fall 2024 by James Juett and Amir Kamil.\n\nThis project is based on research work by Rosenfeld, Michael J., Reuben J. Thomas, and Maja Falcon. 2015. How Couples Meet and Stay Together, Waves 1, 2, and 3: Public version 3.04, plus wave 4 supplement version 1.02 and wave 5 supplement version 1.0 [Computer files]. Stanford, CA: Stanford University Libraries.\n\nThis document is licensed under a [Creative Commons Attribution-NonCommercial 4.0 License](https://creativecommons.org/licenses/by-nc/4.0/). You're free to copy and share this document, but not to sell it. You may not share source code provided with this document.\n", "extracted_entities": ["EECS 280", "Winter 2025", "How Couples Meet and Stay Together (HCMST)", "HCMST_ver_3.04.tsv", "q24_met_online", "ppage", "cats.csv", "cats.out.correct", "Stanford University"], "extracted_triples": [["EECS 280", "is a course for", "Winter 2025"], ["How Couples Meet and Stay Together (HCMST)", "is a study by", "Stanford University"], ["HCMST_ver_3.04.tsv", "is a data file for", "How Couples Meet and Stay Together (HCMST)"], ["q24_met_online", "is a filter column in", "HCMST_ver_3.04.tsv"], ["ppage", "is a data column in", "HCMST_ver_3.04.tsv"], ["cats.csv", "is a sample data set for", "two-sample analysis program"], ["cats.out.correct", "is the correct output for", "cats.csv"], ["two_sample.exe", "analyzes data from", "HCMST_ver_3.04.tsv"], ["two_sample.exe", "analyzes data from", "cats.csv"]]}, {"idx": "chunk-d3068af8a41db5b5e2a28cc5c3429139", "passage": "===== FILE: Pack.hpp =====\n#ifndef PACK_HPP\n#define PACK_HPP\n/* Pack.hpp\n *\n * Represents a pack of playing cards\n *\n * by Andrew DeOrio <awdeorio@umich.edu>\n * 2014-12-21\n */\n\n\n#include \"Card.hpp\"\n#include <array>\n#include <string>\n\nclass Pack {\npublic:\n  // EFFECTS: Initializes the Pack to be in the following standard order:\n  //          the cards of the lowest suit arranged from lowest rank to\n  //          highest rank, followed by the cards of the next lowest suit\n  //          in order from lowest to highest rank, and so on. \n  // NOTE: The standard order is the same as that in pack.in.\n  // NOTE: Do NOT use pack.in in your implementation of this function\n  // NOTE: The pack is initially full, with no cards dealt.\n  Pack();\n\n  // REQUIRES: pack_input contains a representation of a Pack in the\n  //           format required by the project specification\n  // MODIFIES: pack_input\n  // EFFECTS: Initializes Pack by reading from pack_input.\n  // NOTE: The pack is initially full, with no cards dealt.\n  Pack(std::istream& pack_input);\n\n  // REQUIRES: cards remain in the Pack\n  // EFFECTS: Returns the next card in the pack and increments the next index\n  Card deal_one();\n\n  // EFFECTS: Resets next index to first card in the Pack\n  void reset();\n\n  // EFFECTS: Shuffles the Pack and resets the next index. This\n  //          performs an in shuffle seven times. See\n  //          https://en.wikipedia.org/wiki/In_shuffle.\n  void shuffle();\n\n  // EFFECTS: returns true if there are no more cards left in the pack\n  bool empty() const;\n\nprivate:\n  static const int PACK_SIZE = 24;\n  std::array<Card, PACK_SIZE> cards;\n  int next; //index of next card to be dealt\n};\n\n#endif // PACK_HPP\n", "extracted_entities": ["Pack", "Card", "Andrew DeOrio", "2014-12-21", "std::istream", "PACK_SIZE", "24"], "extracted_triples": [["Pack", "is represented by", "Pack.hpp"], ["Pack", "is authored by", "Andrew DeOrio"], ["Pack", "was created on", "2014-12-21"], ["Pack", "contains", "Card"], ["Pack", "has a size of", "PACK_SIZE"], ["PACK_SIZE", "is equal to", "24"], ["Pack", "initializes with", "std::istream"], ["Pack", "deals", "Card"], ["Pack", "can be shuffled", "true"], ["Pack", "can be reset", "true"], ["Pack", "is empty", "bool"]]}, {"idx": "chunk-fc09063192413e935e726618a4f593d2", "passage": "===== FILE: Card.cpp =====\n#include <cassert>\n#include <iostream>\n#include <array>\n#include \"Card.hpp\"\n\nusing namespace std;\n\n/////////////// Rank operator implementations - DO NOT CHANGE ///////////////\n\nconstexpr const char *const RANK_NAMES[] = {\n  \"Two\",   // TWO\n  \"Three\", // THREE\n  \"Four\",  // FOUR\n  \"Five\",  // FIVE\n  \"Six\",   // SIX\n  \"Seven\", // SEVEN\n  \"Eight\", // EIGHT\n  \"Nine\",  // NINE\n  \"Ten\",   // TEN\n  \"Jack\",  // JACK\n  \"Queen\", // QUEEN\n  \"King\",  // KING\n  \"Ace\"    // ACE\n};\n\n//REQUIRES str represents a valid rank (\"Two\", \"Three\", ..., \"Ace\")\n//EFFECTS returns the Rank corresponding to str, for example \"Two\" -> TWO\nRank string_to_rank(const std::string &str) {\n  for(int r = TWO; r <= ACE; ++r) {\n    if (str == RANK_NAMES[r]) {\n      return static_cast<Rank>(r);\n    }\n  }\n  assert(false); // Input string didn't match any rank\n  return {};\n}\n\n//EFFECTS Prints Rank to stream, for example \"Two\"\nstd::ostream & operator<<(std::ostream &os, Rank rank) {\n  os << RANK_NAMES[rank];\n  return os;\n}\n\n//REQUIRES If any input is read, it must be a valid rank\n//EFFECTS Reads a Rank from a stream, for example \"Two\" -> TWO\nstd::istream & operator>>(std::istream &is, Rank &rank) {\n  string str;\n  if(is >> str) {\n    rank = string_to_rank(str);\n  }\n  return is;\n}\n\n\n\n/////////////// Suit operator implementations - DO NOT CHANGE ///////////////\n\nconstexpr const char *const SUIT_NAMES[] = {\n  \"Spades\",   // SPADES\n  \"Hearts\",   // HEARTS\n  \"Clubs\",    // CLUBS\n  \"Diamonds\", // DIAMONDS\n};\n\n//REQUIRES str represents a valid suit (\"Spades\", \"Hearts\", \"Clubs\", or \"Diamonds\")\n//EFFECTS returns the Suit corresponding to str, for example \"Clubs\" -> CLUBS\nSuit string_to_suit(const std::string &str) {\n  for(int s = SPADES; s <= DIAMONDS; ++s) {\n    if (str == SUIT_NAMES[s]) {\n      return static_cast<Suit>(s);\n    }\n  }\n  assert(false); // Input string didn't match any suit\n  return {};\n}\n\n//EFFECTS Prints Suit to stream, for example \"Spades\"\nstd::ostream & operator<<(std::ostream &os, Suit suit) {\n  os << SUIT_NAMES[suit];\n  return os;\n}\n\n//REQUIRES If any input is read, it must be a valid suit\n//EFFECTS Reads a Suit from a stream, for example \"Spades\" -> SPADES\nstd::istream & operator>>(std::istream &is, Suit &suit) {\n  string str;\n  if (is >> str) {\n    suit = string_to_suit(str);\n  }\n  return is;\n}\n\n\n/////////////// Write your implementation for Card below ///////////////\n\n\n// NOTE: We HIGHLY recommend you check out the operator overloading\n// tutorial in the project spec before implementing\n// the following operator overload functions:\n//   operator<<\n//   operator>>\n//   operator<\n//   operator<=\n//   operator>\n//   operator>=\n//   operator==\n//   operator!=\n", "extracted_entities": [], "extracted_triples": []}, {"idx": "chunk-cbb8e23873fbc6002fc735dce5b6fc73", "passage": "===== FILE: Player.cpp =====\n#include \"Player.hpp\"\n\nclass SimplePlayer : public Player {\n    public:\n     //EFFECTS: Creates a SimplePlayer with the given name\n     SimplePlayer(const std::string &name);\n   \n     //EFFECTS: Returns player's name\n     const std::string & get_name() const;\n   \n     //REQUIRES player has less than MAX_HAND_SIZE cards\n     //EFFECTS  adds Card c to Player's hand\n     void add_card(const Card &c);\n   \n     //REQUIRES round is 1 or 2\n     //EFFECTS If Player wishes to order up a trump suit then return true and\n     //  change order_up_suit to desired suit.  If Player wishes to pass, then do\n     //  not modify order_up_suit and return false.\n     // In making trump, a Simple Player considers the upcard, which player dealt, and whether it is the first or second round of making trump. A more comprehensive strategy would consider the other players\u2019 responses, but we will keep it simple.\n     // During round one, a Simple Player considers ordering up the suit of the upcard, which would make that suit trump. They will order up if that would mean they have two or more cards that are either face or ace cards of the trump suit (the right and left bowers, and Q, K, A of the trump suit, which is the suit proposed by the upcard). (A Simple Player does not consider whether they are the dealer and could gain an additional trump by picking up the upcard.)\n     // During round two, a Simple Player considers ordering up the suit with the same color as the upcard, which would make that suit trump. They will order up if that would mean they have one or more cards that are either face or ace cards of the trump suit in their hand (the right and left bowers, and Q, K, A of the order-up suit). For example, if the upcard is a Heart and the player has the King of Diamonds in their hand, they will order up Diamonds. The Simple Player will not order up any other suit. If making reaches the dealer during the second round, we invoke screw the dealer, where the dealer is forced to order up. In the case of screw the dealer, the dealer will always order up the suit with the same color as the upcard.\n     bool make_trump(const Card &upcard, bool is_dealer,\n                     int round, Suit &order_up_suit) const;\n   \n     //REQUIRES Player has at least one card\n     //EFFECTS  If the trump suit is ordered up during round one, the dealer picks up the upcard. The dealer then discards the lowest card in their hand, even if this is the upcard, for a final total of five cards. (Note that at this point, the trump suit is the suit of the upcard.)\n     void add_and_discard(const Card &upcard);\n   \n     //REQUIRES Player has at least one card\n     //EFFECTS  Leads one Card from Player's hand according to their strategy\n     //  \"Lead\" means to play the first Card in a trick.  The card\n     //  is removed the player's hand.\n     //  When a Simple Player leads a trick, they play the highest non-trump card in their hand. If they have only trump cards, they play the highest trump card in their hand.\n     Card lead_card(Suit trump);\n   \n     //REQUIRES Player has at least one card\n     //EFFECTS  Plays one Card from Player's hand according to their strategy.\n     //  The card is removed from the player's hand.\n     //  When playing a card, Simple Players use a simple strategy that considers only the suit that was led. A more complex strategy would also consider the cards on the table.\n     //  If a Simple Player can follow suit, they play the highest card that follows suit. Otherwise, they play the lowest card in their hand.\n     Card play_card(const Card &led_card, Suit trump);\n   \n    private:\n     std::string name;\n     std::vector<Card> hand;\n   };\n\n// The Human Player reads input from the human user. You may assume all user input is correctly formatted and has correct values. You may also assume the user will follow the rules of the game and not try to cheat.\nclass HumanPlayer: public Player {\n    public:\n    //EFFECTS: Creates a SimplePlayer with the given name\n    HumanPlayer(const std::string &name);\n  \n    //EFFECTS: Returns player's name\n    const std::string & get_name() const;\n  \n    //REQUIRES player has less than MAX_HAND_SIZE cards\n    //EFFECTS  adds Card c to Player's hand\n    void add_card(const Card &c);\n  \n    //REQUIRES round is 1 or 2\n    //EFFECTS  If Player wishes to order up a trump suit then return true and\n  //  change order_up_suit to desired suit.  If Player wishes to pass, then do\n  //  not modify order_up_suit and return false.\n  //  When making trump reaches a Human Player, first print the Player\u2019s hand. Then, prompt the user for their decision to pass or order up. The user will then enter one of the following: \u201cSpades\u201d, \u201cHearts\u201d, \u201cClubs\u201d, \u201cDiamonds\u201d, or \u201cpass\u201d to either order up the specified suit or pass. This procedure is the same for both rounds of making trump.\n    bool make_trump(const Card &upcard, bool is_dealer,\n                    int round, Suit &order_up_suit) const;\n  \n    //REQUIRES Player has at least one card\n    //EFFECTS  Player adds one card to hand and removes one card from hand.\n    //  If a Human Player is the dealer and someone orders up during the first round of making, the Human Player will pick up the upcard and discard a card of their choice. Print the Player\u2019s hand and an option to discard the upcard. Then, prompt the user to select a card to discard. The user will then enter the number corresponding to the card they want to discard (or -1 if they want to discard the upcard).\n    void add_and_discard(const Card &upcard);\n  \n    //REQUIRES Player has at least one card\n    //EFFECTS  Leads one Card from Player's hand according to their strategy\n    //  \"Lead\" means to play the first Card in a trick.  The card\n    //  is removed the player's hand.\n    //  When it is the Human Player\u2019s turn to lead or play a trick, first print the Player\u2019s hand. Then, prompt the user to select a card. The user will then enter the number corresponding to the card they want to play.\n    Card lead_card(Suit trump);\n  \n    //REQUIRES Player has at least one card\n    //EFFECTS  Plays one Card from Player's hand according to their strategy.\n    //  The card is removed from the player's hand.\n    //   When it is the Human Player\u2019s turn to lead or play a trick, first print the Player\u2019s hand. Then, prompt the user to select a card. The user will then enter the number corresponding to the card they want to play.\n    Card play_card(const Card &led_card, Suit trump);\n  \n   private:\n    std::string name;\n    std::vector<Card> hand;\n   };", "extracted_entities": ["SimplePlayer", "Player", "HumanPlayer", "Card", "Suit", "MAX_HAND_SIZE"], "extracted_triples": [["SimplePlayer", "is a subclass of", "Player"], ["HumanPlayer", "is a subclass of", "Player"], ["SimplePlayer", "has method", "get_name"], ["HumanPlayer", "has method", "get_name"], ["SimplePlayer", "has method", "add_card"], ["HumanPlayer", "has method", "add_card"], ["SimplePlayer", "has method", "make_trump"], ["HumanPlayer", "has method", "make_trump"], ["SimplePlayer", "has method", "add_and_discard"], ["HumanPlayer", "has method", "add_and_discard"], ["SimplePlayer", "has method", "lead_card"], ["HumanPlayer", "has method", "lead_card"], ["SimplePlayer", "has method", "play_card"], ["HumanPlayer", "has method", "play_card"], ["SimplePlayer", "requires", "less than MAX_HAND_SIZE cards"], ["HumanPlayer", "requires", "less than MAX_HAND_SIZE cards"], ["SimplePlayer", "uses", "Card"], ["HumanPlayer", "uses", "Card"], ["SimplePlayer", "uses", "Suit"], ["HumanPlayer", "uses", "Suit"]]}, {"idx": "chunk-d37817a59bc77fa061992192db4501f8", "passage": "===== FILE: Player.hpp =====\n#ifndef PLAYER_HPP\n#define PLAYER_HPP\n/* Player.hpp\n *\n * Euchre player interface\n *\n * by Andrew DeOrio\n * awdeorio@umich.edu\n * 2014-12-21\n */\n\n\n#include \"Card.hpp\"\n#include <string>\n#include <vector>\n\nclass Player {\n public:\n  //EFFECTS returns player's name\n  virtual const std::string & get_name() const = 0;\n\n  //REQUIRES player has less than MAX_HAND_SIZE cards\n  //EFFECTS  adds Card c to Player's hand\n  virtual void add_card(const Card &c) = 0;\n\n  //REQUIRES round is 1 or 2\n  //MODIFIES order_up_suit\n  //EFFECTS If Player wishes to order up a trump suit then return true and\n  //  change order_up_suit to desired suit.  If Player wishes to pass, then do\n  //  not modify order_up_suit and return false.\n  virtual bool make_trump(const Card &upcard, bool is_dealer,\n                          int round, Suit &order_up_suit) const = 0;\n\n  //REQUIRES Player has at least one card\n  //EFFECTS  Player adds one card to hand and removes one card from hand.\n  virtual void add_and_discard(const Card &upcard) = 0;\n\n  //REQUIRES Player has at least one card\n  //EFFECTS  Leads one Card from Player's hand according to their strategy\n  //  \"Lead\" means to play the first Card in a trick.  The card\n  //  is removed the player's hand.\n  virtual Card lead_card(Suit trump) = 0;\n\n  //REQUIRES Player has at least one card\n  //EFFECTS  Plays one Card from Player's hand according to their strategy.\n  //  The card is removed from the player's hand.\n  virtual Card play_card(const Card &led_card, Suit trump) = 0;\n\n  // Maximum number of cards in a player's hand\n  static const int MAX_HAND_SIZE = 5;\n\n  // Needed to avoid some compiler errors\n  // NOTE: Do NOT write a destructor in the Player subclasses. The compiler-generated ones will work fine.\n  virtual ~Player() {}\n};\n\n//EFFECTS: Returns a pointer to a player with the given name and strategy\n//To create an object that won't go out of scope when the function returns,\n//use \"return new Simple(name)\" or \"return new Human(name)\"\n//Don't forget to call \"delete\" on each Player* after the game is over\nPlayer * Player_factory(const std::string &name, const std::string &strategy);\n\n//EFFECTS: Prints player's name to os\nstd::ostream & operator<<(std::ostream &os, const Player &p);\n#endif // PLAYER_HPP\n", "extracted_entities": ["Player", "Euchre", "Andrew DeOrio", "awdeorio@umich.edu", "2014-12-21", "Card", "MAX_HAND_SIZE", "Simple", "Human"], "extracted_triples": [["Player", "is an interface for", "Euchre"], ["Player", "was created by", "Andrew DeOrio"], ["Andrew DeOrio", "can be contacted at", "awdeorio@umich.edu"], ["Player", "has a maximum hand size of", "MAX_HAND_SIZE"], ["MAX_HAND_SIZE", "is equal to", "5"], ["Player", "includes", "Card"], ["Player", "can be instantiated as", "Simple"], ["Player", "can be instantiated as", "Human"], ["Player_factory", "creates", "Player"], ["Player", "has a method", "get_name"], ["Player", "has a method", "add_card"], ["Player", "has a method", "make_trump"], ["Player", "has a method", "add_and_discard"], ["Player", "has a method", "lead_card"], ["Player", "has a method", "play_card"]]}, {"idx": "chunk-3ab74c8ca013475310dc1899eeff8acb", "passage": "===== FILE: euchre.cpp =====\n#include <iostream>\n#include <fstream>\n#include <string>\n#include \"Card.hpp\"\n#include \"Pack.hpp\"\n#include \"Player.hpp\"\n#include <cstring>\n\nclass Game {\n    public:\n     Game(/* ... */);\n     void play();\n   \n    private:\n     std::vector<Player*> players;\n     Pack pack;\n     // ...\n   \n     void shuffle();\n     void deal(/* ... */);\n     void make_trump(/* ... */);\n     void play_hand(/* ... */);\n     // ...\n   };\n   ", "extracted_entities": ["euchre.cpp", "Game", "Card", "Pack", "Player", "std::vector"], "extracted_triples": [["euchre.cpp", "contains", "Game"], ["Game", "includes", "Card"], ["Game", "includes", "Pack"], ["Game", "includes", "Player"], ["Game", "uses", "std::vector"], ["Game", "has", "players"], ["Game", "has", "pack"], ["Game", "has method", "shuffle"], ["Game", "has method", "deal"], ["Game", "has method", "make_trump"], ["Game", "has method", "play_hand"]]}, {"idx": "chunk-440f590c41049beebc81c813ab95b98d", "passage": "===== FILE: Card.hpp =====\n#ifndef CARD_HPP\n#define CARD_HPP\n/* Card.hpp\n *\n * Represents a single playing card\n *\n * by Andrew DeOrio\n * awdeorio@umich.edu\n * 2014-12-21\n */\n\n#include <iostream>\n\n// Represent a Card's Rank.\n// Rank is a type that can represent the specific values\n// listed in the definition below, but no others. (In memory\n// the Rank values are represented as integers from 0 to 12.)\n// Use the values as constants, for example:\n//   Rank r1 = FOUR;\n//   Rank r2 = NINE;\n// Ranks may be compared (this compares the underlying int values):\n//   if (r1 < r2) { // this condition is true\n// Overloaded << and >> operators are also defined farther below to\n// enable stream input/output for Rank objects:\n//   cout << r1 << endl; // prints \"Four\"\n//   cin >> r2 << endl;  // reads a string from cin and updates r2\n// Because the underlying representation of the enum is an integer,\n// objects of type Rank are ok to pass/return by value.\nenum Rank {\n  TWO     = 0,\n  THREE   = 1,\n  FOUR    = 2,\n  FIVE    = 3,\n  SIX     = 4,\n  SEVEN   = 5,\n  EIGHT   = 6,\n  NINE    = 7,\n  TEN     = 8,\n  JACK    = 9,\n  QUEEN   = 10,\n  KING    = 11,\n  ACE     = 12,\n};\n\n//REQUIRES str represents a valid rank (\"Two\", \"Three\", ..., \"Ace\")\n//EFFECTS returns the Rank corresponding to str, for example \"Two\" -> TWO\nRank string_to_rank(const std::string &str);\n\n//EFFECTS Prints Rank to stream, for example \"Two\"\nstd::ostream & operator<<(std::ostream &os, Rank rank);\n\n//REQUIRES If any input is read, it must be a valid rank\n//EFFECTS Reads a Rank from a stream, for example \"Two\" -> TWO\nstd::istream & operator>>(std::istream &is, Rank &rank);\n\n// Represent a Card's suit\nenum Suit {\n  SPADES   = 0,\n  HEARTS   = 1,\n  CLUBS    = 2,\n  DIAMONDS = 3,\n};\n\n//REQUIRES str represents a valid suit (\"Spades\", \"Hearts\", \"Clubs\", or \"Diamonds\")\n//EFFECTS returns the Suit corresponding to str, for example \"Clubs\" -> CLUBS\nSuit string_to_suit(const std::string &str);\n\n//EFFECTS Prints Suit to stream, for example \"Spades\"\nstd::ostream & operator<<(std::ostream &os, Suit suit);\n\n//REQUIRES If any input is read, it must be a valid suit\n//EFFECTS Reads a Suit from a stream, for example \"Spades\" -> SPADES\nstd::istream & operator>>(std::istream &is, Suit &suit);\n\n\nclass Card {\npublic:\n\n  //EFFECTS Initializes Card to the Two of Spades\n  Card();\n\n  //EFFECTS Initializes Card to specified rank and suit\n  Card(Rank rank_in, Suit suit_in);\n\n  //EFFECTS Returns the rank\n  Rank get_rank() const;\n\n  //EFFECTS Returns the suit.  Does not consider trump.\n  Suit get_suit() const;\n\n  //EFFECTS Returns the suit\n  //HINT: the left bower is the trump suit!\n  Suit get_suit(Suit trump) const;\n\n  //EFFECTS Returns true if card is a face card (Jack, Queen, King or Ace)\n  bool is_face_or_ace() const;\n\n  //EFFECTS Returns true if card is the Jack of the trump suit\n  bool is_right_bower(Suit trump) const;\n\n  //EFFECTS Returns true if card is the Jack of the next suit\n  bool is_left_bower(Suit trump) const;\n\n  //EFFECTS Returns true if the card is a trump card.  All cards of the trump\n  // suit are trump cards.  The left bower is also a trump card.\n  bool is_trump(Suit trump) const;\n\nprivate:\n  Rank rank;\n  Suit suit;\n\n  // This \"friend declaration\" allows the implementation of operator>>\n  // to access private member variables of the Card class.\n  friend std::istream & operator>>(std::istream &is, Card &card);\n};\n\n//EFFECTS Prints Card to stream, for example \"Two of Spades\"\nstd::ostream & operator<<(std::ostream &os, const Card &card);\n\n//EFFECTS Reads a Card from a stream in the format \"Two of Spades\"\n//NOTE The Card class declares this operator>> \"friend\" function,\n//     which means it is allowed to access card.rank and card.suit.\nstd::istream & operator>>(std::istream &is, Card &card);\n\n//EFFECTS Returns true if lhs is lower value than rhs.\n//  Does not consider trump.\nbool operator<(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is lower value than rhs or the same card as rhs.\n//  Does not consider trump.\nbool operator<=(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is higher value than rhs.\n//  Does not consider trump.\nbool operator>(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is higher value than rhs or the same card as rhs.\n//  Does not consider trump.\nbool operator>=(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is same card as rhs.\n//  Does not consider trump.\nbool operator==(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is not the same card as rhs.\n//  Does not consider trump.\nbool operator!=(const Card &lhs, const Card &rhs);\n\n//EFFECTS returns the next suit, which is the suit of the same color\nSuit Suit_next(Suit suit);\n\n//EFFECTS Returns true if a is lower value than b.  Uses trump to determine\n// order, as described in the spec.\nbool Card_less(const Card &a, const Card &b, Suit trump);\n\n//EFFECTS Returns true if a is lower value than b.  Uses both the trump suit\n//  and the suit led to determine order, as described in the spec.\nbool Card_less(const Card &a, const Card &b, const Card &led_card, Suit trump);\n\n#endif // CARD_HPP\n", "extracted_entities": ["Card", "Rank", "Suit", "Andrew DeOrio", "awdeorio@umich.edu", "2014-12-21"], "extracted_triples": [["Card", "is represented by", "Rank"], ["Card", "is represented by", "Suit"], ["Card", "was created by", "Andrew DeOrio"], ["Andrew DeOrio", "can be contacted at", "awdeorio@umich.edu"], ["Card", "has a creation date", "2014-12-21"], ["Rank", "is a type of", "Card"], ["Suit", "is a type of", "Card"]]}], "avg_ent_chars": 9.7778, "avg_ent_words": 1.3472}