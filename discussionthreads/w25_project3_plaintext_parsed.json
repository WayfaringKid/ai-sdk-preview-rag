[
  {
    "question": "project_Because of the weather advisory alert for snow on Saturday is there a chance of the Euchre social being moved to Sunday?",
    "answers": [
      "No, luckily it'll be on Central Campus, so it should be easy for most students to get to!"
    ]
  },
  {
    "question": "project_Does this error: Card.cpp:121:17: error: non-member function cannot have 'const' qualifier  mean that we have to remove the 'const' from the: Rank get_rank() const assert(false); {}",
    "answers": [
      "No, the const should stay. get_rank() should be a member function of the Card class. So if you're declaring the function outside of the class, it would look something like: \n\nRank Card::get_rank() ..."
    ]
  },
  {
    "question": "project_Hi,  This is my first time working with overloaded operators. I understand that we can make operators do what we specify in their overload functions, but I was wondering how we should test this. Is it similar to testing functions, or are there other considerations that I should be aware of? Any help is appreciated.  Thank you.",
    "answers": [
      "Hello! You can use the unit test framework like in previous projects. Use the assert TRUE or assert FALSE functions to check if the comparisons are correct. Consider card1 (Ace of the trump suit) and card2 (Jack of the trump suit). card1 > card2 should resolve to false. So, in this case you would use ASSERT_FALSE(card1 > card2) to test. I hope this helps!"
    ]
  },
  {
    "question": "project_For the void shuffle() function, should we call the Pack() function to order the pack from lowest to highest rank before shuffling? Or do we just shuffle without ordering the pack?",
    "answers": [
      "If this question is referring to Pack::shuffle() , you should not be calling Pack() to order the pack from lowest to highest rank before shuffling. Shuffle the cards without ordering the pack. :)"
    ]
  },
  {
    "question": "project_Suit Card::get_suit(Suit trump) const  Does this function return the next suit of the trump?  Ex: trump is SPADES so the function will return CLUBS",
    "answers": [
      "The function Suit Card::get_suit(Suit trump) const will return the suit of the card given the trump. If the trump is spades and this function is being called on the Ace of Diamonds, the function should return DIAMONDS. Note that there is a special case where a card's suit changes depending on its rank, suit, and the trump suit."
    ]
  },
  {
    "question": "project_For the card comparison operators like <, <=, >, >=, ==, !=, are we only comparing the rank of the cards and not considering the suit at all?",
    "answers": [
      "Card comparison operators should consider both suit and rank. According to the specs, Diamonds > Clubs > Hearts > Spades. For rank, Ace > King > Queen > Jack > ... and so on. I would highly recommend looking at the card visuals as a reference for comparisons."
    ]
  },
  {
    "question": "project_What does lhs and rhs stand for in the operation overloading functions?",
    "answers": [
      "lhs: left hand side, rhs: right hand side. It's a shorthand to describe the values on the left and right of the operator respectively."
    ]
  },
  {
    "question": "project_Hi,  When testing any const function in project 3, should different cases use const and non-const objects? Additionally, should we check that an object's member variables are not changed if testing on a non-const object?  On a side note, when considering cases for testing should we make different cases for every potential suit and rank? I was wondering if there is a concept to apply here that is similar to the small-scope idea that we followed in the previous project.  Thank you.",
    "answers": [
      "should different cases use const and non-const objects?\n\nSure!\n\nshould we check that an object's member variables are not changed if testing on a non-const object?\n\nI personally don't think this is necessary, because if you try to modify member variable in `const` function, compiler will throw an error before you test it.\n\n when considering cases for testing should we make different cases for every potential suit and rank\n\nProbably not EVERY potential suit, but I definitely encourage you to think of all special cases - like left/right bower, trump, face/non-face card, etc. Consider how these special cases impact each stage of the gameplay."
    ]
  },
  {
    "question": "project_Overall game.",
    "answers": [
      "Some of the specifics of how we want you to code up your project are specific to us, so if you want to play online or watch videos to understand the game better, make sure to pay close attention to the spec."
    ]
  },
  {
    "question": "project_The EECS 280 website says that the euchre social is located in the Jeff Blau Hall while Ed says that the Euchre Social is located in the Mason Hall. Can you please confirm the location of the euchre social and its room?",
    "answers": [
      "It's in BLAU 1570 (Jeff Blau Hall)."
    ]
  },
  {
    "question": "project_For the functions such as add_and_discard, lead_card, play_card, how do I write test for those functions? Those functions print output to the command line and also takes input from the command line, does that mean I should use cin and cout to test those functions?",
    "answers": [
      "You don't need to take input from command line in order to call these functions. Here's an example from Player_public_tests.cpp :\n\n  bob->add_and_discard(\n    Card(NINE, HEARTS) // upcard\n  );\n\n\nIn terms of testing the effect of these functions, you don't necessarily need to compare the printed output with correct output. Instead, you can think of what effect does these function calls should have on player's hand, and add assertions based on that."
    ]
  },
  {
    "question": "project_If two non-trump cards are of equal rank in Card_less() are ties broken by suit?",
    "answers": [
      "Yes"
    ]
  },
  {
    "question": "project_Hi, I just wanted to make sure I'm understanding the <= operator properly. Since < checks for both rank and suit to determine the card values, what's the point of checking if lhs and rhs are the same card if we know that all the cards in euchre are unique? Is it just because it's good to have a <= operator defined? Thank you!",
    "answers": [
      "For euchre, it may seem like the <= and == operators are not necessary. However, it's practical to have all the logical operators completed for the card.hpp and card.cpp suite. It ensures consistency if this code was ever exported to another program that utilizes card logic. In this program, there might be a case where the <= or == have importance and need to be implemented.\n\nFor euchre, there might be a case where cards are not unique. There's a pack input, meaning that you can (realistically) put in any set of cards, including duplicates. It might be a fun test case to write :)"
    ]
  },
  {
    "question": "project_In the case where the simple player would be picking up a card (dealer and round 1), are we supposed to call the add_and_discard function from make_trump? It seems reasonable but I got errors trying to implement probably because make_trump is const and you would be calling a modiyfing function. Or is this something that we would do later in the euchre driver and there's no need to call it now?",
    "answers": [
      "Managing things like that is something that you will implement in the driver."
    ]
  },
  {
    "question": "project_While I was writing the implementation for the second pack constructor function, the one where we take an istream as an argument, I noticed that, when I tried to use istringstream to help break the task down, I keep getting an \"incomplete type istringstream is not allowed\".    Does this mean that we should not be using istringstream to help set up the cards array?",
    "answers": [
      "You're probably missing #include <sstream>. Though, is there a reason you're using a stringstream instead of  the istream directly?"
    ]
  },
  {
    "question": "project_Do we need to implement friend std::istream & operator>>(std::istream &is, Card &card);  If so, I'm a bit confused on how to write the function stub in Card.cpp.",
    "answers": [
      "You do have to implement it, just like the other operator functions. The whole \"friend\" thing doesn't matter, that just means it has access to certain data."
    ]
  },
  {
    "question": "project_when I return this, do I return literally   return trump;    or do I return the trump suit? (Example if its diamonds I return DIAMONDS)",
    "answers": [
      "You should return the suit of the card object it\u2019s being called on, considering how the Trump suit affects the suit of the card (i.e. If card is Jack of hearts, card.get_suit(DIAMONDS) returns DIAMONDS)"
    ]
  },
  {
    "question": "project_Hi, I have a question on the ordering in the correct euchre output for euchre_test01.out.correct. Most of my output is correct but my differences are slightly confusing.   First difference in bold, strikethrough because error cascades.  Correct Hand 1 in euchre_test01.out.correct  Hand 1 Fran deals Nine of Diamonds turned up Gabriel passes Herb passes Edsger orders up Diamonds  Ace of Clubs led by Gabriel Nine of Hearts played by Herb Nine of Clubs played by Edsger Queen of Clubs played by Fran Gabriel takes the trick  King of Clubs led by Gabriel Queen of Hearts played by Herb Ace of Hearts played by Edsger Jack of Clubs played by Fran Gabriel takes the trick  Queen of Spades led by Gabriel Ace of Spades played by Herb King of Diamonds played by Edsger King of Spades played by Fran Edsger takes the trick  Jack of Hearts led by Edsger Nine of Diamonds played by Fran Ten of Clubs played by Gabriel Jack of Diamonds played by Herb Herb takes the trick  Ten of Diamonds led by Herb Ace of Diamonds played by Edsger Ten of Spades played by Fran Jack of Spades played by Gabriel Edsger takes the trick  Edsger and Gabriel win the hand Edsger and Gabriel have 3 points Fran and Herb have 0 points   My output:  Hand 1 Fran deals Nine of Diamonds turned up Gabriel passes Herb passes Edsger orders up Diamonds  Ace of Clubs led by Gabriel Nine of Hearts played by Herb Nine of Clubs played by Edsger Queen of Clubs played by Fran Gabriel takes the trick  King of Clubs led by Gabriel Queen of Hearts played by Herb Ace of Hearts played by Edsger Jack of Clubs played by Fran Gabriel takes the trick  Queen of Spades led by Gabriel Ace of Spades played by Herb King of Diamonds played by Edsger King of Spades played by Fran Edsger takes the trick  Jack of Hearts led by Edsger Ten of Spades played by Fran Ten of Clubs played by Gabriel Ten of Diamonds played by Herb Edsger takes the trick  Ace of Diamonds led by Edsger Nine of Diamonds played by Fran Jack of Spades played by Gabriel Jack of Diamonds played by Herb Herb takes the trick  Edsger and Gabriel win the hand Edsger and Gabriel have 3 points Fran and Herb have 0 points   The lead card is hearts, trump is diamond. Fran doesn't have any cards that match hearts, so they will play the lowest card. Why are they playing 9 diamonds when they have a 10 of spades (diamond is trump). Similarly why is herb playing the jack of diamonds if he has 10 of diamonds.",
    "answers": [
      "Ok, I saw the explanation; it is because Jack of Hearts is a diamond, my b."
    ]
  },
  {
    "question": "project_for both card_less functions, can we assume that the cards will not be the same card because there are no duplicate cards in the deck of 24 cards? So card a will not equal card b? Thanks!",
    "answers": [
      "Correct, the function will only return true or false. No two cards are equal"
    ]
  },
  {
    "question": "project_Hi, is it okay to include <string> in our card.cpp file? Thanks!",
    "answers": [
      "Yep, you can. Note that the <string> library is mostly useful for string manipulation functions. You can still declare a string variable type without the string header."
    ]
  },
  {
    "question": "project_For the pack() default functions are we only allowed to use one array for the 24 cards individually since there is one array in the class? If so are we allowed to look up how to split strings into words based on certain elements so we can make it work?  Otherwise Are we allowed to split Card element into multiple arrays or?",
    "answers": [
      "Pack is already defined to have one array (cards) in the .hpp file, so you are only allowed to use one array for the 24 cards in a Pack. I am confused on why you would need to split strings into words, as the array stores Card objects, which have functions that allow you to retrieve their rank / suit. It might not be necessary to do so :)"
    ]
  },
  {
    "question": "project_Hi,  I'm a little confused by what reset is supposed to do, are we just setting int next to 0?  Thanks",
    "answers": [
      "Yep, that's correct."
    ]
  },
  {
    "question": "project_For the overloading of functions I had questions about the value system. Are we comparing the rank first (A > K > Q > J > 10 ...) then the suit?",
    "answers": [
      "Yep, you should first compare rank and then compare suit if the ranks are equal."
    ]
  },
  {
    "question": "project_When testing Player.cpp, how do we access the cards a player has after we have changed it with something like add_and_discard? Since cards is a private vector and there is no function that would return the cards a player has, what is the best way to go about accessing them?",
    "answers": [
      "I would recommend creating a helper function that will check the cards that a player has in their hand. Think about how a function like lead card or play card can be used to extract a card from a player's hand. Just remember that if you remove a card from the player's hand during testing, you'll need to add it back as well. Follow up if you have further questions!"
    ]
  },
  {
    "question": "project_Do we Have to write test cases for pack? I assume since we are not submitting them we are given the choice, if it turns out to be buggy wont we find out either way in Euchre.cpp?",
    "answers": [
      "Euchre only uses a specific subset of cards from a full deck, but Pack.cpp is able to work with a variety of different sets. So just using Euchre.cpp as a way to test won't be enough. Also, it will be very annoying to write Euchre.cpp if you're still unsure of the correctness of Pack.cpp."
    ]
  },
  {
    "question": "project_Do we assume that the simple player abides by the rules of Euchres? For example, if they have a card of the same suit as the upcard, they won't place a card of a different suit? Or, do we have to implement this fact?",
    "answers": [
      "For Simple Player, you have to implement their behavior according to the spec. The behavior in the spec already follows the rules, so there shouldn't be any rules being broken by a Simple player."
    ]
  },
  {
    "question": "project_Should I be using asserts inside my member functions of the Card class to verify that the input parameters such as (Suit trump) are valid Suit types, or is that redundant since it is an enum type?",
    "answers": [
      "Yes, because it is an enumerated class, this is not needed."
    ]
  },
  {
    "question": "project_How do I test my shuffle function if the point of shuffle is that it generates a random order?",
    "answers": [
      "Shuffle doesn't generate a completely random order. Shuffle mixes the card in the same way each time, outlined in this section of the spec."
    ]
  },
  {
    "question": "project_Hi,   For some member functions, I think it would make sense to not make them virtual. For example, both the Simple and the Human player would have a name, so could we make that a function of the Player parent class?   Thanks!",
    "answers": [
      "You don't submit Player.hpp to the autograder, so you can't change it."
    ]
  },
  {
    "question": "project_Hello!  My partner and I are a bit confused about whether or not certain card combinations count in 'Card_less()' functions based on our Euchre knowledge.   For an example on what I mean:   Function 1 (no leading): Suppose both A and B are non-trump aces. Which wins? Is it that they are the same, so A !< B since they are tied (aka return false)?   Function 2 (with leading): Suppose both A and B are not trumps and not leading suit (aka off-suit), but different values. In euchre, this means that neither card wins and therefore A !< B (so return false).   Is my logic correct, or should we return the lower-rank card even if it doesn't follow the euchre rules? If so, how would it handle those cases where the card suit is different but the rank is the same?",
    "answers": [
      "In the simplest case, cards are ordered by rank (A > K > Q > J > 10 > 9), with ties broken by suit (D > C > H > S).\n\nFor your first question, you need to look at A and B's suit.\n\nIf a led suit is present as well as a trump suit, the ordering is the same except that all cards of the led suit are considered more valuable than all non-trump-suit, non-led-suit cards. Note that it is possible for the trump suit and led suit to be the same.\n\nFor your second question, you simply return true if A has higher rank, return false if B has higher rank"
    ]
  },
  {
    "question": "project_Hello! For deal_one the requires states that cards must remain in the deck.   1. If there are no more cards remaining in the deck, does this mean that the next index would be equal to the PACK_SIZE? If so, should we add that as an assertion?    3. Should we check if next equals PACK_SIZE (or the end of the deck) after we increment it, and reset it back to 0 if necessary, or will this be covered in later functions?",
    "answers": [
      "1. Yes, next should be less than PACK_SIZE. You may add that as an assertion if you wish.\n\n2. You should not reset the value of next in Pack::deal_one(), this should only be done by the Pack::reset() function."
    ]
  },
  {
    "question": "project_For the \"name\" assignment in return for the function, it says out of scope, how I make it in-scope?",
    "answers": [
      "Which function is this error occuring in? You might want to check where your variables are being declared to ensure they don't go out of scope before returning."
    ]
  },
  {
    "question": "project_for the subclasses, is it okay to define function inside the class? or should we still define them outside the class using this \"::\" operator?",
    "answers": [
      "Either is fine as long as it compiles and runs properly."
    ]
  },
  {
    "question": "project_in function: std::istream & operator>>(std::istream &is, Card &card)  do we always assume that the input is in the format of \"Three of Spades\",  both suit and rank start with capital letter and then lowercase, and have \"of\" in between? or we need to write more detail to make sure that the input is in this way, otherwise, report error?  thx",
    "answers": [
      "yes I believe that is standard output \n\n[Rank] of [Suit]\n\nWith Rank and Suit being titled."
    ]
  },
  {
    "question": "project_So the spec says \"If the trump suit is ordered up during round one...)\" but this is nowhere to be found in the requires clause, Do I still need to implement the add_and_discard function within the bounds of round 1, or is that not necessary?",
    "answers": [
      "The functionality of add_and_discard is separate from making trump, meaning you don't have to worry about the current round when implementing. The round is something to consider when writing euchre.cpp."
    ]
  },
  {
    "question": "project_Hi, should we include tests for our implementations of the overloading operator functions? if so do we use assert_true for the bool functions? How can we test the ostream/istream ones then? Thank you.",
    "answers": [
      "Yes, you should include tests for these. You can use ASSERT_TRUE or any other assert in the unit test framework for this.\n\nFor the stream operators, you should be able to use stringstreams, similar to how you used them in P2 to test Image_print and Image_init."
    ]
  },
  {
    "question": "project_The project spec seems to imply that we should prompt the human player to input any suit during the ordering up making trump process.   \"When making trump reaches a Human Player, first print the Player\u2019s hand. Then, prompt the user for their decision to pass or order up. The user will then enter one of the following: \u201cSpades\u201d, \u201cHearts\u201d, \u201cClubs\u201d, \u201cDiamonds\u201d, or \u201cpass\u201d to either order up the specified suit or pass. This procedure is the same for both rounds of making trump.\"  So, if the up card is of the diamonds suit and the human player choose clubs, should an error be thrown? Could a simple \"order up (y/n)\" line be used instead of allowing the player to choose a suit?  The spec also says \"You may also assume the user will follow the rules of the game and not try to cheat.\" Does this mean that we can rely on the autograder/Human Player to always choose an acceptable value? Meaning, for example, if the up card is of the diamonds suit (and its the first round) the player will never choose anything but diamonds or \"pass\" despite the option being presented to them? And similar for the second round, except allowing both diamonds and hearts as well as pass as options for the player to choose (will not choose spades or clubs).",
    "answers": [
      "You can assume all input a human player is given is valid. The situation you describe above would be an example of invalid behavior since the human player would be violating the rules of euchre (if you're talking about the first round of making trump-- note that it would be valid during the second round)."
    ]
  },
  {
    "question": "project_Does the default constructor pack(); return a pack of 52 ordered cards or only the euchre pack of 24?",
    "answers": [
      "The euchre pack."
    ]
  },
  {
    "question": "project_I saw another post that said we should make helper functions to access private member variables in Player.cpp like hand for easier testing. However, I am a little confused on how to do this without being able to modify the .hpp file. If I try just defining the function in the .cpp it tells me that Player * does not have that function in Player_test.cpp. Thanks!",
    "answers": [
      "If I try just defining the function in the .cpp it tells me that Player * does not have that function in Player_test.cpp\n\nHard to say without looking at your code, but my best guess is because you're trying to define the function as part of the player base class, not the simple player or human player subclass. Try just making the helper function for the subclasses and see if that works."
    ]
  },
  {
    "question": "project_In the slides describing the simple player strategies, it says that in round 2 of making trump, the dealer can no longer take the upcard.  I wanted to clarify what this means.  Does this just mean they cannot order up?  Thank you.",
    "answers": [
      "In the first round, the if anyone orders up, the dealer can decide whether or not to replace a card in their hand with the upcard.\nIn the second round, the dealer cannot replace a card in their hand with the upcard if someone decides to order up.\n\nSo the dealer can order up in the second round. Does this clarify things?"
    ]
  },
  {
    "question": "project_I just want to clarify if we need to implement the human player derived class for the checkpoint or is it only simple?",
    "answers": [
      "Both simple and human players! Most of the effort is in simple players, but part of the checkpoint involves passing the player public tests which have some human player functionality."
    ]
  },
  {
    "question": "project_Multiple of the requires clauses mention that player should have less than 5 cards for example. But my question is how do access this hand variable since it does not exist in the hpp class. Do we have to add a variable to the hpp or is there a different method to doing that.",
    "answers": [
      "Good question! In Player.hpp is your \"Player\" base class, and you would have to create derived classes (namely \"Simple\" and \"Human\" derived classes). Since you are in charge of writing these classes, feel free to add whatever member variables you deem fit."
    ]
  },
  {
    "question": "project_Hello,  I had some questions when I was implementing the Simple class    1) If the led suite and trump suite are same, do we consider the left bower as following suit? Or would they play the lowest card in their hand?  2) If jack is the only card you have in led suite but that is the left bower, should u still play it?   Is the left bower SOLEY considered the trump suit, or is it also considered in the led suite?    Thanks",
    "answers": [
      "1) If the led suite and trump suite are same, do we consider the left bower as following suit? Or would they play the lowest card in their hand?\n\nThe LB is always considered part of the trump suit (not the suit that is printed on the card itself), so if the led suit is the trump suit, playing the left bower would be considered following suit. (this is a great edge case to test for simple player!)\n\n2) If jack is the only card you have in led suite but that is the left bower, should u still play it? \n\nNot sure exactly what you mean by this question. Let me know if this situation describes it:\n\nTrump is diamonds, and someone leads with hearts. You have the Jack of hearts (and no other cards that have hearts on them). Because trump is diamonds the Jack of Hearts is the LB. If you play the Jack of Hearts, this would not be considered following suit because the left bower is the suit of the trump suit (so your jack of hearts is actually considered a diamond). \n\nDoes this help?"
    ]
  },
  {
    "question": "project_i saw that on another thread that for the human make_trump() function, that the human player gets to input something on both round 1 and round 2 of making trump.   my question is about the \"screw the dealer\" variant. if the human player is the dealer and round 2 makes it all the way to them, do they still have to input the suit of the same color or can they just input anything? Or do we have to manually check the condition that they are the dealer and then order up the suit of the same color for them, in which case, the human user doesn't input anything?  also, when we're printing the cards in the human player's hand, before we add or discard an upcard, can we assume their hand is already sorted and we only need to sort after they add or discard a card? Or do we need to sort their cards just in general cause their hand will not be sorted?",
    "answers": [
      "my question is about the \"screw the dealer\" variant. if the human player is the dealer and round 2 makes it all the way to them, do they still have to input the suit of the same color or can they just input anything? \n\nThe human player can declare any suit, except for the upcard's suit. However, you can assume that all input to the human player will be valid, so there is no need to check that the selected suit doesn't match the upcard. the human player implementation is essentially a bunch of reading input and not much else in terms of game logic\n\n\nwhen we're printing the cards in the human player's hand, before we add or discard an upcard, can we assume their hand is already sorted and we only need to sort after they add or discard a card? \n\n\nYou should sort the hand whenever there is a change to the hand (adding or discarding cards to the hand)."
    ]
  },
  {
    "question": "project_When the player has no Cards with the led_suit, and they must play the lowest card, this has to factor trump in right?  Like if player has all trumps; lowest trump.  If player has no trumps, just regular operators to check smallest  if player has mix of trump and regular, take only regular, get lowest  Correct?",
    "answers": [
      "This is all correct. \n\nYour card_less function should take care of all of this logic between comparing cards in reference to the trump suit. Your play card function, however, needs to decide whether to play the max card of the led suit, or if that is not an option, the lowest card of non-led suit."
    ]
  },
  {
    "question": "project_Hi,  when submitting to autograder, I fail Player public tests and get this error:  Player.cpp:6:10: fatal error: Pack.hpp: No such file or directory 6 | #include \"Pack.hpp\" | ^~~~~~~~~~ compilation terminated. make: *** [public.mk:35: Player.o] Error 1  Is there something I am missing? What can I do to correct this?",
    "answers": [
      "Do you need anything in Pack inside Player? The autograder is likely throwing an error because Pack.hpp is not necessary for the functions in Player. If you are not using those functions, remove the include \"Pack.hpp\"."
    ]
  },
  {
    "question": "project_When I try to launch my debugger, I receive this error:  \"the platform is not currently connected  Possible cause: the working directory \"/Users/muskanrekhani/Documents/GitHub/P3-EUCHRE\" is missing or inaccessible.\"  So far, I have attempted to type ls into my terminal to see if the files exist, and they do. Here is my json file:  {     // Use IntelliSense to learn about possible attributes.     // Hover to view descriptions of existing attributes.     // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387     \"version\": \"0.2.0\",     \"configurations\": [         {             \"type\": \"lldb\",             \"request\": \"launch\",             \"name\": \"Debug\",             \"program\": \"${workspaceFolder}/Card_tests.exe\",             \"args\": [],             \"cwd\": \"${workspaceFolder}\"         }     ] }",
    "answers": [
      "It's a little difficult to find the cause of the issue without being able to see everything taking place in VSCode, so feel free to come to office hours if you're still having trouble with this.\n\nI would first check to make sure that the workspace folder (the folder you opened in VSCode when you opened your project) is the same folder you are in on the terminal, and is also the same folder that has your Makefile and all of your euchre code. This is also the folder where your .vscode folder and launch.json should reside. (All of these locations should match).\n\nEverything in your launch.json looks good to me."
    ]
  },
  {
    "question": "project_for human player,  do functions Card lead_card(Suit trump and Card play_card(const Card &led_card, Suit trump) mean, we human choose whatever card they want, and we assume they follow rules and their inputs are valid, so the only job we have to do in the coding is to read the input and remove that card from hand and return the chosen card?  i am not sure whether this understanding is correct or not, or we need to add more limitations on these 2 functions.   thx",
    "answers": [
      "Yep, exactly. For the Human player, you can assume the entered inputs are valid, so you only have to read the input and remove the card from their hand."
    ]
  },
  {
    "question": "project_I'm doing Human Player, am I allowed to assume that the user will only enter pass, Diamonds, Clubs, Spades, and Hearts?",
    "answers": [
      "Yes, you can assume that all input from the human player is valid. This is included in the spec: \"The Human Player reads input from the human user. You may assume all user input is correctly formatted and has correct values. You may also assume the user will follow the rules of the game and not try to cheat.\"\n\nPost #414 also provides some more detail on this."
    ]
  },
  {
    "question": "project_Can we include the cmath library?",
    "answers": [
      "Yes, that's fine"
    ]
  },
  {
    "question": "project_When writing test cases, will we get points taken off for using ASSERT_EQUAL(true, ______) instead of ASSERT_TRUE(); since it is technically more efficient or does it not matter?",
    "answers": [
      "ASSERT_TRUE is more intuitive so you should use that. I don't think there would be a difference in efficiency though, and it wouldn't affect your points."
    ]
  },
  {
    "question": "project_Does this function also invoke screw the dealer or not?",
    "answers": [
      "I think post #414 explains this well. Essentially, you don't need to include logic to invoke screw the dealer on the human player because you assume that the human player plays the game correctly. If the human player is the dealer and they are asked to make trump on round two, they should know that they cannot pass."
    ]
  },
  {
    "question": "project_In the bool Card_less(const Card &a, const Card &b, const Card &led_card, Suit trump) function can the led_suit be equal to the trump suit? Thanks",
    "answers": [
      "Yes, the led suit could be the trump suit!"
    ]
  },
  {
    "question": "project_\"During round two, a Simple Player considers ordering up the suit with the same color as the upcard, which would make that suit trump. They will order up if that would mean they have one or more cards that are either face or ace cards of the trump suit in their hand\"  Just to be clear, when you say \"if they have one or more cards that are either face or ace cards of the trump suit\"  here the alleged \"trump\" suit means the suit the same color as the upcard right?  For example, the upcard is hearts, my functions checks if i have at least one KQA and left/right bower of DIAMONDS, correct?",
    "answers": [
      "Yes, they would consider making diamonds the upcard in round two if no one ordered up hearts in round one, so checking for at least one of:\n\nAce of Diamonds\n\nKing of Diamonds\n\nQueen of Diamonds\n\nRight bower (Jack of Diamonds)\n\nLeft bower (Jack of Hearts) \n\nshould be correct!"
    ]
  },
  {
    "question": "project_Does false positives mean that my implementation is wrong?",
    "answers": [
      "False positives mean that a test case that should not pass on a correct implementation passed on your code, so it is likely a problem with your implementation. You can also check your test cases to make sure you didn't violate the requires clause of the particular function."
    ]
  },
  {
    "question": "project_How should I test add_and_discard if there's no function that can help me see the player's cards?",
    "answers": [
      "One way to check is by using the play_card function to deal the player's hand. There should be five cards in the player's hand, so using play_card five times should result in dealing the entire player's hand. Additionally, the play_card function returns a Card, so that can be used to check if the player has actually discarded/added the correct card to their hand."
    ]
  },
  {
    "question": "project_With the comparison operators, would the == operator only be comparing rank since there will not be an equal card with both the same rank and suit? and on the other comparisons, how would this work",
    "answers": [
      "Think about using the == operator for test cases. In a test case, you may be using == to see whether the pack has dealt one card correctly to a player. A written test case has the pack dealing the Jack of Hearts. However, the pack (due to a bug) has dealt the Jack of Spades. If only rank is compared, the operator would return true. However, this is not what we would want in our implementation as the two cards are different.\n\nFor all operators, you will need to keep both rank and suit in mind. I suggest looking at this image to see the card comparisons: \n\nTop left is the most powerful card; bottom right is the least powerful card."
    ]
  },
  {
    "question": "project_When writing make_trump(), do we need to consider if the player has >=2 cards with the same suit as the upsuit before ordering up? For both the human and simple player.",
    "answers": [
      "For a human player, no. Human players use inputs to determine whether they make a suit trump. For a simple player, follow the algorithm in the specs.\n\nFor a simple player:\n\nRound 1: If they have 2+ cards that are either face/ace of the trump suit, they will order up the suit of the upcard.\n\nRound 2: If they have 1+ cards that are either face/ace of the same color of the trump suit, they will order up."
    ]
  },
  {
    "question": "project_Hello,  So if I make trump during the first round and the dealer, as a simple player, picks it up, this would be handled by the make_trump function, correct?  So would it be ok to change the function from const to a non-const function or are we going to deal with this externally in euchre.cpp?    Thank you,  Ethan Tilak",
    "answers": [
      "The player class should have a function called void add_and_discard(const Card &upcard) . This function should handle the logic for picking up the upcard in the first round and discarding a card as needed. Make_trump should only modify the order_up_suit."
    ]
  },
  {
    "question": "project_When the spec says something like  \"If a Human Player is the dealer and someone orders up during the first round of making, the Human Player will pick up the upcard and discard a card of their choice. .\"  but \u00a0void add_and_discard(const Card &upcard) has no parameter for round  does this mean I have to somehow figure out round number and assert its round one, or no?",
    "answers": [
      "You don't need to worry about round number within add_and_discard as the function should only be called only when round==1."
    ]
  },
  {
    "question": "project_\"Pro-tip: Make \u201csorted card ordering\u201d a representation invariant of your Human Player class and ensure that the hand is always kept in sorted order. For consistency with autograder test cases, the cards in a human player\u2019s hand must always be printed in ascending order, as defined by the < operator in Card.hpp.  Use the STL to sort a vector<Card> hand:\"  is this telling me to call the sort functionality before at the top of each function implementation, or somehow declare it in private and call it? what exactly am I supposed to do here?",
    "answers": [
      "The representation invariant essentially means that the hand should only be valid if it in sorted order. Take a look at the pitfall in the spec as it tells you exactly how you should accomplish this."
    ]
  },
  {
    "question": "project_Ive went over both function implementations in HumanPlayer class multiple times and I cannot spot the difference, do they have the same implementation in the Human class?",
    "answers": [
      "lead_card() will be called when the player is playing the first card in a trick, and then play_card() will be called in all other instances, but you are correct that their implementations are technically the same in the Human class :)"
    ]
  },
  {
    "question": "project_Do we modify the Player factory function whatsoever? The spec asks us to create our subclasses at the top of the file, then gives us two functions, but the player factory one seems to be complete, am I missing something?",
    "answers": [
      "If you are referring to the implementation for Player_factory that is given in the spec, it is a good jumping off point and correctly handles the case where a Player is of strategy \"Simple\", but you need to finish implementing it so that it can handle the cases of a \"Human\" strategy as well as an invalid one (the code for inside of the invalid case is also given in the spec)"
    ]
  },
  {
    "question": "project_Hello,  I am currently working on the Human class and had a question regarding some of the function's input parameters. Because Human dervies it's functions from the base Player class, some of them have input parameters that I didn't think we needed to consider for the Human Player. For example, the is_dealer and round variables in make_trump and the trump and led_card variables in play_card.   Since we are going off the assumption the human would play by the rules, I didn't think we needed to consider these variables as the user would follow the rules. Thanks.",
    "answers": [
      "Great observation, I think your reasoning is on the right track! Remember the function signatures between simple and human players have to match so that we can use polymorphism and do stuff like:\n\nPlayer *s = Player_factory(\"Bob\", \"Simple\");\nPlayer *h = Player_factory(\"Alice\", \"Human\");\n\n...\n\ns->play_card(...); // I forget the parameters...\nh->play_card(...);\n\nWhere both s and h are player pointers. This may mean that some function parameters for the simple player class are not needed for the human player class, but they need to be included for the above behavior to work."
    ]
  },
  {
    "question": "project_Hi   I'm passing the public tests (both in my own terminal and on autograder), but in the autograder it says I have a UB problem, but I can't understand what is wrong (I couldn't understand the error output).  Could some one look at my autograder and explain what is wrong?   Thank you so much!",
    "answers": [
      "One potential reason could be that when you are using hands.erase(hands.begin()+index), there's a chance (at least from the compiler view), that you could access incorrect memory locations since there are places where you are not assigning a value to int index when you first declare it. Not a 100% certain but I would recommend fixing that first."
    ]
  },
  {
    "question": "project_for testing play_card, and the left bower is the only card that follow the lead, do we play the left bower? or we  just consider left bower be one of trump cards, and then play the lowest one in hand?    thx",
    "answers": [
      "#413"
    ]
  },
  {
    "question": "project_When testing my player cpp, does it make sense to add if classes and assertions against duplicates, or is that just impossible?  Like for add card, if add card is called twice in a row on one same card, what would happen? Should I defend against that, is it impossible for some reason?",
    "answers": [
      "Up to you. Might be good for debugging purposes later on, but having two of the exact same card in a deck is not valid input so the AG will not be checking this case."
    ]
  },
  {
    "question": "project_I'm working on testing a \"Simple\" player. The issue arises in the following scenario:  The trump suit is Clubs  The lead card is the Ace of Clubs  The player's entire hand consists of trump cards:  Ten of Clubs  Jack of Spades (Left Bower, which is a trump in Clubs)  Queen of Clubs  Nine of Clubs  King of Clubs  Expected behavior: Since the Jack of Spades is the Left Bower and counts as the highest available trump, the player should play the Jack of Spades.  Actual behavior of my program: The player plays the King of Clubs instead.  I am not sure if this follows the rules because I get a false positive, could you clarify if I am writing the test correctly?    Thanks!",
    "answers": [
      "Here are your two false positive tests:\n\nfrom the spec: If a Simple Player can follow suit, they play the highest card that follows suit. Otherwise, they play the lowest card in their hand. Here, bob can follow suit, so they play the highest card that follows suit. All cards in bob's hand are clubs (J of spades is technically considered a club here because it is the left bower). So bob should play the J of spades, not the A of clubs.\n\n\n\nHere, bob's highest card that follows suit (and therefore the correct simple player choice) is also the Jack of spades. Can you see why using the same logic as my answer above?"
    ]
  },
  {
    "question": "project_I am a little confused about the description for the pack constructor. I know we should be putting the existing array in order of rank for each suit, but is the pack.in the only rank the cards will have? will it only be from rank Nine to Ace each time? or should we be considering all possible rank cards can have?",
    "answers": [
      "I'm a bit confused by your question. I'll try to be as comprehensive as possible but let me know if you still have questions. \n\nFor the default constructor (with no input), your pack should contain all 24 cards arranged by their suit and rank (rank should range from nine to ace only). Lower suit first, ordered by their rank, then next suit ordered by their rank and so on. There's a more detailed description in Pack.hpp. \n\nFor the constructor with the input pack_input. pack_input will contain all 24 cards. The cards in the pack will be arranged in the order they were read in. No need to sort this. \n\nThe only ranks cards will have is from nine to ace. Only those 24 cards will be in the pack."
    ]
  },
  {
    "question": "project_Why is there no getter for hand? I feel like it's just inefficient to not have it? Anyways, from my understanding, we are supposed to use play_cards to test functions like add_and_discard. Could someone speak more to it on how to actually use it for testing. Thank you so much.",
    "answers": [
      "Since we're trying to emulate a card game, we unfortunately can't provide a functionality where you can just choose to randomly get a card from someone's hand (that wouldn't be allowed in the game!).\n\nTo test these functions, you can set up the player's hand (push the exact cards you want) so that you logically know what card the player must play if they are leading, playing, etc. The public tests gives you a good starting point for how to set this up. Look at lines 76 through 121."
    ]
  },
  {
    "question": "project_Are we going to be graded on our comments for the Project 3 checkpoint?",
    "answers": [
      "No, we will not be checking comments for the checkpoint. The autograder will check for comment length in the final project 3 submission."
    ]
  },
  {
    "question": "project_For the version of Card_less where we pass in the led card, would there be a special test case for if the led card is the left bower? If so, how would this affect the cards a and b that are passed into the function?",
    "answers": [
      "Even if the led card is the left bower, the led suit will still be the 'true' underlying suit for the led card. For example, if the led card is the left bower Jack of Hearts, the led suit will be Hearts. As long as you make sure you are checking the 'true' suit of the led card when getting the led suit, this would not need to be treated specially."
    ]
  },
  {
    "question": "project_I had a few questions about the derived classes we have to make.  1) It was a bit unclear if we should declare the interface for the derived classes in the player.h file and then implement it in the cpp or if we just do both in the cpp alone.  2) Im trying to implement the simple class, but I am not sure where the players hand comes from, do we create this as a private member? If we do, can we also create member functions for it as well? I am also confused if we should create our own constructor for the classes as well as it wasnt specified in the spec.  Thank you!",
    "answers": [
      "1) Do both in cpp. We don't want you to make any changes to the hpp file as you will not be submitting those. \n\n2) Yes, you should create the private member variables name and hand. For Simple, you need to override the member functions in the base class, so those functions should be declared and implemented for the Simple class. This includes creating constructors, yes."
    ]
  },
  {
    "question": "project_Hi,  I\u2019m currently working on the make_trump() function and encountering a segmentation fault error when running the public test. I\u2019ve tried printing the trump suit output to check if the trump for the different rounds is being set correctly. Additionally, I\u2019ve written some basic test cases for round 1, but I\u2019m still unable to identify the cause of the error. My code is shown below.  Could you please help me troubleshoot this issue or provide any guidance on what might be going wrong?   bool make_trump(const Card &upcard, bool is_dealer, int round,                      Suit &order_up_suit) const override {                  // check if int round is set to either 1 or 2         assert(round == 1 || round == 2);          round = 1;          // initialize trump suit to upcard suit         Suit trump = upcard.get_suit();          // round 1 check         if (round == 1) {             // initialize trump card/face card count             int count = 0;             // for loop checking and counting each trump suit/head card in human hand             for (int i = 0; i < human_hand.size(); ++i) {                 // if card has trump suit or left bower and is a                  // face head card or ace, make trump                 if (((human_hand[i].is_trump(trump)) || (human_hand[i].is_left_bower(trump)))                        && (human_hand[i].is_face_or_ace())) {                     // add one to count                     count++;                 }             }              // check how many cards are either trump/left bower and face cards             // if there are at least two, make upcard trump suit             if (count >= 2) {                 return true;             }             // if there are less than 2, don't make upcard trump suit             else {                 return false;             }         }          // round 2 check: set suit of trump to same color suit         else {              // initialize trump card/face card count             int count = 0;              // set trump suit to next suit of the upcard             Suit trump = Suit_next(upcard.get_suit());              // for loop checking and counting each trump suit/head card in human hand             for (int i = 0; i < human_hand.size(); ++i) {                 // if card has trump suit or left bower and is a face head card or ace, make trump                 if (((human_hand[i].is_trump(trump)) || (human_hand[i].is_left_bower(trump)))                       && (human_hand[i].is_face_or_ace())) {                     // add one to count                     count++;                   }             }              // check how many cards are either trump/left bower and face cards             // if there are at least onw, make upcard trump suit             // cout << \"count: \" << count;             if (count >= 1) {                 return true;             }             // if there are less than one, don't make upcard trump suit             else {                 return false;             }         }     }  Thanks!",
    "answers": [
      "I don't immediately see anything wrong with the code that might cause a segmentation fault. We would need to look at the unit test as well to identify the issue. Please come to office hours so we can look through the entirety of the code!"
    ]
  },
  {
    "question": "project_Should the pack ctors assign next a value of 0? Otherwise my code isn't working but I don't see anything about it in the spec.",
    "answers": [
      "Yes we want to make sure we initialize all of the private member variables in the pack ctors."
    ]
  },
  {
    "question": "project_Hi, we were having issues with writing the Player_factory function. In particular, how to set the name of the Player without an internal private name variable or a set_name function within the class. The code would not have errors if a SimplePlayer or HumanPlayer instance was initialized with the default constructor, but that wouldn't use the name parameter passed into the function. Let us know!",
    "answers": [
      "Having an internal private name variable would be a great way to keep track of that information for when you have an instance of HumanPlayer or SimplePlayer. You can then initialize the name variable within your constructors."
    ]
  },
  {
    "question": "project_I am a bit confused on screw the dealer.  From the spec:   If making reaches the dealer during the second round, we invoke screw the dealer, where the dealer is forced to order up. In the case of screw the dealer, the dealer will always order up the suit with the same color as the upcard.  Screw the Dealer: When making* reaches the dealer on round two, the dealer must *order up a suit other than the rejected one  So if round 2 of making the trump reaches the dealer, they are forced to order the same color suit and not the other color suits?",
    "answers": [
      "Yes, if screw the dealer is invoked the dealer must order up the suit that has the same color as the upcard."
    ]
  },
  {
    "question": "project_Hello!  For the checkpoint due on Feb 24th, do we need to implement anything in the files that are to be submitted? Or do we just have to submit the files once we have set the project up?",
    "answers": [
      "The checkpoint runs the public tests and mutation tests, so they should be fully implemented. What files are you thinking of leaving unimplemented?"
    ]
  },
  {
    "question": "project_Are we permitted to write our own helper functions for this project? If so, are we allowed to modify the .hpp or will we have to initialize in .cpp?",
    "answers": [
      "You can write helpers and we encourage it. You can't modify the .hpp file at all though because you can't submit it to the autograder. So it should be entirely in the .cpp files (and make sure it compiles without error)."
    ]
  },
  {
    "question": "project_A little bit confused about the dealer boolean variable. is the simple player will never be the dealer? is the usage for the is_dealer only for the screw part? we don't need to modify the cards in hand, right?  edit: Looks like a simple player can be the dealer",
    "answers": [
      "\"is the usage for the is_dealer only for the screw part?\"\n\nTo the best of my understanding, this is correct. Is_dealer is only relevant for simple players, where it forces them to obey the \"screw the dealer\" rule during Round 2 of making.\n\nFrom the spec: \"If making reaches the dealer during the second round, we invoke screw the dealer, where the dealer is forced to order up. In the case of screw the dealer, the dealer will always order up the suit with the same color as the upcard.\""
    ]
  },
  {
    "question": "project_For the add and discard card, does the simple player consider the trump when determining the lowest?  For example if I'm the dealer and I have 5 diamonds in my hand, and my opponent ordered up Spades since it's the upcard. Naturally, I would throw away the lowest diamonds I have, even though the upcard is the NINE of SPADES.   Does this logic apply to the simple player?",
    "answers": [
      "Unless I'm misunderstanding, the spec already explains this:\n\n\"If the trump suit is ordered up during round one, the dealer picks up the upcard. The dealer then discards the lowest card in their hand, even if this is the upcard, for a final total of five cards. (Note that at this point, the trump suit is the suit of the upcard.)\""
    ]
  },
  {
    "question": "project_same as above",
    "answers": [
      "No, only the Jack of the next suit gets special powers, the rest of the suit is not special."
    ]
  },
  {
    "question": "project_I wrote the function is_left_bower before the function Suit_next and used Suit_next in is_left_bower. Am I able to do that? Since Card.hpp is declared at the top of Card.cpp, I assume this should work?",
    "answers": [
      "It should work. As long as it compiles, it's fine."
    ]
  },
  {
    "question": "project_Do we have to create a test case for player constructor and/or player factory",
    "answers": [
      "We recommend creating test cases for every function (and every edge case for each function) that you write."
    ]
  },
  {
    "question": "project_For the human player functions in Project 3, should we assume that the player will only give inputs that are legal according to the rules of Euchre? If they, say, select a card in play_card() that doesn't obey the rules of following suit, or choose the same suit as the upcard in Round 2 of making trump, should we somehow enforce the rules to correct these inputs (maybe via assert(false)?), or should we just assume the players will obey the rules?",
    "answers": [
      "From the spec: \"You may assume all user input is correctly formatted and has correct values. You may also assume the user will follow the rules of the game and not try to cheat.\""
    ]
  },
  {
    "question": "project_I have submitted my completed code to the autograder after I had completed all the public tests, but once submitted, my player function wasn't compiling. It tells me there is a 'expected type-specifier before \u2018Simple\u2019' in the return line of the 'player factory' function. I had this error prior in my testing but hadn't named my constructor correctly, but fixed that and it fixed my problem. Any ideas as to why it is now popping back up in the autograder?",
    "answers": [
      "Did you modify Player.hpp?"
    ]
  },
  {
    "question": "project_I am a little bit confused as to what a player should have during this point of implementing simple player. In my constructor, I initialized a private variable (int num_cards=0) as I assumed a starting player should not have any cards yet until the game is implemented. I just wanted to verify if thats true, should we assume that dealing has begun while implementing the derived classes, or if not, should we be doing the dealing in this class?",
    "answers": [
      "I'm not really 100% sure if this will answer your question and if it doesn't please let me know! But you should implement the classes in simple player as if they have some cards in their hand. I believe if you look at the RME and the required clause you can see that function won't be called if the player's hand is empty."
    ]
  },
  {
    "question": "project_Hi,  I am not sure why I am getting a false positive error for this test. Also, I exposed 17/17 bugs for player_tests, but 4 of them are false positive. My score still shows 91/91, but will this affect my grade?  TEST(test_right_bower_vs_trump_ace) {     Suit trump = HEARTS;     Card led_card(QUEEN, CLUBS);      Player * bob = Player_factory(\"Bob\", \"Simple\");     bob->add_card(Card(JACK, HEARTS));     bob->add_card(Card(ACE, HEARTS));      Card card_played = bob->play_card(led_card, trump);     cout << card_played << endl;     ASSERT_EQUAL(card_played, Card(JACK, HEARTS));      delete bob; }   Thanks!",
    "answers": [
      "For the checkpoint, the score you see is the score you get. But regarding your issue...\n\nSpec: \"If a Simple Player can follow suit, they play the highest card that follows suit. Otherwise, they play the lowest card in their hand.\"\n\nSpec: \"Right Bower: The Jack of the trump suit. This is the most valuable card in the game.\""
    ]
  },
  {
    "question": "project_I understand the effects of the Suit_next function but don't know how to start.",
    "answers": [
      "My recommendation is to look at how the Suits are configured in Cards.hpp. Think about how the enums work with the suits and how you can use them to get from suit to suit. We cannot give you specific recommendations, but if you have any questions that are more specific please let us know."
    ]
  },
  {
    "question": "project_Hello!  After my partner and I submitted our Pack.cpp to our Autograder, we saw that it failed some of the tests that it passed in our code in the terminal.  When we run the Makefile commands (make Pack_public_tests.exe, ./Pack_public_tests.exe), we get that we passed all of the tests.  However, when we manually put in the compiling lines the Autograder uses   (ex: g++ --std=c++17 -Wall -pedantic -g -Wno-sign-compare -Wno-comment Pack_public_tests.cpp -c -o Pack_public_tests.o g++ --std=c++17 -Wall -pedantic -g -Wno-sign-compare -Wno-comment Pack.cpp -c -o Pack.o g++ --std=c++17 -Wall -pedantic -g -Wno-sign-compare -Wno-comment Card.cpp -c -o Card.o g++ -Wall Pack_public_tests.o Pack.o Card.o -o Pack_public_tests.exe)  Our code no longer passes certain tests even though we have not changed anything in our code. We are not sure if this is an error with our code or something else. How would we fix this and why would this error be occurring is what we are mainly concerned about.   Thank you!",
    "answers": [
      "Sometimes, your compiler default initializes variables when you don't, however the autograder does not. So I'd recommend going back through your code and make sure you initialize every variable. I'd make sure to look at your Pack constructor since that's where it seems you're failing on the autograder, and think about what variables need to be initialized in a class constructor."
    ]
  },
  {
    "question": "project_is there a way to have the debugger run with the euchre_test input? when i looked it up i saw that c++ doesn't support stdio as part of a configuration for the launch.json (?) but i figure there has to be a better way than typing it all manually haha. thanks!",
    "answers": [
      "You can add them in as arguments in the debugger like this. Similarly, you can use > for output redirection."
    ]
  },
  {
    "question": "project_I revealed all 17 bugs for the player but had a few false positives, yet I'm still getting 91/91. I'll work on reducing the false positives, but will they impact my checkpoint grade?",
    "answers": [
      "For the checkpoint, the score you see is the score you get."
    ]
  },
  {
    "question": "project_I am a little confused on playing with all trump suit cards:  If you do not lead, and cannot follow suit (because they have no cards of the led suit), they play the lowest card in their hand, even if all their cards are trumps?  If you do lead and have all trump suit cards, play the highest card in your hand?",
    "answers": [
      "From the spec:\n\nWhen a Simple Player leads a trick, they play the highest non-trump card in their hand. If they have only trump cards, they play the highest trump card in their hand.\n\nIf a Simple Player can follow suit, they play the highest card that follows suit. Otherwise, they play the lowest card in their hand.\n\nSo the answers to your questions are yes and yes.\n\n\nThe Simple Player must always follow suit (and play the highest card of the followed suit), and if they can't follow suit, they must play their lowest card."
    ]
  },
  {
    "question": "project_I've written over 40 test cases for player.cpp. But, I still have only found 13/17 bugs. I know we are limited to 50 cases total for a test file and I cannot think of what edge cases I am missing. Do you have any advice on how to figure out what I am missing?",
    "answers": [
      "Make sure you're writing a test for every function. I recommend thinking of scenarios in the game that change with order of card and how that may impact functions. For example, right and left bowers."
    ]
  },
  {
    "question": "project_should deal_one() allow the next to increment from next=23 to next=24? if I have an assertion that asserts whether the value of next is smaller than the PACK_SIZE. Or should I have an if-statement that examines whether the value of next is 23 or not?",
    "answers": [
      "There are 24 cards and we use 0-indexing. So the card at the 23rd index would be the \"last\" card. So you should be checking if going to the \"next\" card would exceed index 23."
    ]
  },
  {
    "question": "project_Or the only case when there are no more cards left in the pack is when next equals to PACK_SIZE.  I assume the value of next can never be greater than PACK_SIZE right?",
    "answers": [
      "I believe next shouldn't be greater than PACK_SIZE. But to be safe, in case there's any bug in your code, it might be a good idea to include that as a fail safe."
    ]
  },
  {
    "question": "project_What is the purpose of implementing both operator <= and operator < ?  Won't they have the same implementation?  In what scenario would two cards be equal? Won't one card always be greater than or less than another card?  Same logic applies to operator >= and operator > . Won't they both have same implementation?  Also when would we use operator == ?",
    "answers": [
      "If the same card is on both sides of the operator, then they would be equal."
    ]
  },
  {
    "question": "project_Hi, I have a question for screw the dealer. Let us simulate a process for making the trump. We assume the upcard is a diamond.   First round, nobody has at least 2 face cards of diamond. Everybody pass. We go into the second round.  Second round, we decide hearts to be the possible trump. Everybody does not have at least one face card of the hearts. Then the second round passes too.  Then we invoke screw the dealer, the dealer must order up the suit that has the same color as the upcard which is the diamond. So the dealer still have to order up the hearts.   I do not think it makes sense to me. Can anyone fix the issues in this process?",
    "answers": [
      "A round starts with the person on the dealer's left. So for screw the dealer, say it's second round and I'm the dealer. If the three people who go before me pass, then I would be forced to order up the suit that has the same color."
    ]
  },
  {
    "question": "project_I just wanted to quickly ask about how to check for success for void functions like add_and_discard because the hands are private variables?  Thank you.",
    "answers": [
      "People sometimes test them by adding and discarding and then playing cards a bunch of times. You can combine functions to make tests like that."
    ]
  },
  {
    "question": "project_Hi, I was wondering if I have the right logic for making trump for simple players in round 2.  I currently have a test case with this situation:  Upcard: King of Hearts  Simple player's hand: (Nine of Spades, Ace of Diamonds)  In my tests, I believe that this player will make trump in round 2 because they have the ace of diamonds. This runs correctly on my computer, however in the autograder it states that this player will not make trump.  I was wondering how I should go about fixing this situation, or where potential errors may be.  One last additional question was about if we have to implement HumanPlayer for this checkpoint, or if it will be due with the full project.  Any help is appreciated. Thank you.",
    "answers": [
      "Hi, \n\nI figured out what was going wrong with my autograder submission. I was still wondering if we are supposed to implement HumanPlayer for this checkpoint as it is still a bit unclear to me."
    ]
  },
  {
    "question": "project_Hi,  I just want to make sure that I understand the game. I am not understanding why this test was marked as a false positive.  TEST(test_simple_player_play_card_left_bower_trump_card) {   Suit trump = CLUBS;   ASSERT_TRUE(trump == CLUBS);    Card led_card(NINE, CLUBS);    Player * bob = Player_factory(\"Bob\", \"Simple\");   bob->add_card(Card(JACK, SPADES));   bob->add_card(Card(TEN, CLUBS));   bob->add_card(Card(KING, CLUBS));   bob->add_card(Card(QUEEN, CLUBS));   bob->add_card(Card(ACE, CLUBS)); // being played!!!    Card card_played = bob->play_card(led_card, trump);   cout << \"Card played: \" << card_played << endl;   // has to throw a club even though all trump   ASSERT_TRUE(card_played == Card(ACE, CLUBS));    delete bob; }  Thank you!",
    "answers": [
      "From the spec:\n\nLeft Bower: The Jack of the \u201csame color\u201d suit as trump is considered to be a trump (regardless of the suit printed on the card) and is the second most valuable card."
    ]
  },
  {
    "question": "project_Are we supposed to stick the dealer for the Human Player class make trump function? It doesn't say so in the spec, so are we supposed to assume that everything we did in SimplePlayer will be implemented in HumanPlayer?",
    "answers": [
      "#414 - essentially, you should assume that the human player knows the rules of euchre and will play accordingly."
    ]
  },
  {
    "question": "project_Yesterday, I asked a similar question as to why our Pack.cpp wasn't compiling properly. I made some changes, and uploaded it to the Autograder and got the points for Pack_Public_tests. Now, after making on changes to Pack.cpp, the Autograder is saying that it is failing one test but in my own terminal, it's not failing. Even when I run my debugger, it returns Nine of Spades and not the Jack of Spades which is what the Autograder is saying I'm returning. I made no changes to Pack.cpp that should dramatically affect these results.   Is it again an issue with not changing or initializing values that need to be intiialized that my computer automatically does for me and not the Autograder? I don't feel like it is, but I am curious as to why.  Thanks!",
    "answers": [
      "It looks like it still has to do with initializing member variables. Remember that when either constructor is invoked, every member variable has to be initialized."
    ]
  },
  {
    "question": "project_I have finished writing Player.cpp and the compiler shows no errors, but when I go to make the public player tests I get an error saying \"expected type-specifier before \u2018SimplePlayer\u2019 \" on the line where I am returning the pointer to the player. I am also getting errors saying \"expected \u2018;\u2019 before \u2018SimplePlayer\u2019 \" and \" \u2018SimplePlayer\u2019 was not declared in this scope \" on the same lines.   Any suggestions on how I can address this issue? I have left the code on the spec intact except for changing Simple to my class name, which is SimplePlayer, and I have made a 1-argument constructor that my compiler does seem to recognize.   Thank you in advance for your help.",
    "answers": [
      "I managed to solve the issue! The problem was that I was defining the factory function before declaring the classes."
    ]
  },
  {
    "question": "project_For the making_trump function of SimplePlayer, in round 2 when we are checking the next suit, does the left bower count in this scenario? Say, for example, hearts are led, and I have the left bower. I know that it is technically a heart, but should I also allow it to factor in as a card of the same color for this function? Thank you!",
    "answers": [
      "I think I understand, but just to clarify-- the upcard was a heart, and you have the left bower, so the jack of diamonds. Everybody passed, so now it's on round two, and we're checking for diamonds. You're asking if you should consider the jack of diamonds a diamond in this case? if so-- yes! you should be including it in your count for both rounds."
    ]
  },
  {
    "question": "project_Is it safe to assume that the dealer has at least one same color card as the trump card when screw the dealer is invoked?   Alternatively, if the dealer does not have at least one of the same color card as the trump card, is it safe to assume that at least one of the players (starting from the eldest to the one right before the dealer) has at least one same color card?   I thought that it would be problematic if the above is not the case because the dealer would be forced to order up when there aren't any same color cards in their hand",
    "answers": [
      "There's nothing wrong with ordering up a suit that you don't have in your hand-- it just means you're probably going to lose the round!"
    ]
  },
  {
    "question": "project_My group currently has full points on the autograder, but it says that we are failing \"Student Player tests on student Player (UB Checks). We are not entirely sure what this means, or why we would have gotten it. Any advice would be greatly appreciated!  Furthermore, will we still get full points if we are unable to fix the issue before the deadline?",
    "answers": [
      "#28 #472"
    ]
  },
  {
    "question": "project_When we follow suit in playing a card, do we still care about the trump suit? e.g. if my led card is jack of spades and trump suit is clubs, is the suit I'm 'following' spades or clubs. And if it is spades, are all of my club cards still the most highly valued cards amongst the non-led-suit cards (ie nine clubs>ace diamonds)?",
    "answers": [
      "If trump is clubs, then the jack of spades is considered a club, so you should lay a club to follow suit. \n\nLikewise, if spades was led, laying a jack of spades would not be following suit, because it is a club. However, yes, the club cards would still be the most highly valued cards, as in any club card > ace diamonds, AND any club card > spade, even if spades was led.\n\nlet me know if that was confusing!!"
    ]
  },
  {
    "question": "project_Hello,  I am writing the test cases for play_card() and I am getting a false positive when running the test case below.  I just wanted to clarify what the expected play card should be for the case below: Even though there is a Jack of Spades in the hand and the lead card is the nine of Spades, the cards in the hand are all trumps, so the played card should be the highest trump (JACK of SPADES). Is this correct?  TEST(test_play_card_right_bower) {     Player * alice = Player_factory(\"Alice\", \"Simple\");     Suit trump = CLUBS;     Card led_card(NINE, SPADES);      alice->add_card(Card(JACK, SPADES));     alice->add_card(Card(JACK, CLUBS));     alice->add_card(Card(ACE, CLUBS));      // Bob plays a card     Card card_played = alice->play_card(led_card, trump);     ASSERT_EQUAL(card_played, Card(JACK, SPADES));      delete alice; }   Thanks!",
    "answers": [
      "You are correct that all cards are trumps. So they need to play the highest trump card - the Jack of Clubs."
    ]
  },
  {
    "question": "project_When returning name in the get_name() function name = \"\", not the player name. How can we create a player with the given name.",
    "answers": [
      "I would make sure you have implemented ctor for the simple player that takes into account the name!"
    ]
  },
  {
    "question": "project_I am getting confused.  Spec: If a Simple Player can follow suit, they play the highest card that follows suit. Otherwise, they play the lowest card in their hand.  If you can't follow the lead suit, but have all trump cards, do you play your highest or lowest?  EX: For simple player playing card: if the trump is HEARTS and the leading card is SPADES, but you only have hearts, do you play the lowest or highest heart?",
    "answers": [
      "It's true that in a typical game of euchre you would want to play a trump card if you don't have any cards that follow suit. However, according to the spec, the simple player just plays the lowest card in their hand in this case. If they had all trump cards, they would play their lowest trump card.\n\nThey would play their lowest heart."
    ]
  },
  {
    "question": "project_For deal_one(), what is next initially supposed to be. All of my tests are failing because this function is not working. For the first public test, my initialization is perfect but next is set at index 1 not 0, so it is returning the wrong value, and therefore the test is failing.",
    "answers": [
      "i believe next is reset in the ctor so it is initially 0. and then in deal_one() the card at index 0 is returned first before index is incremented",
      "Expanding on the student's answer:\n\nYes, next should be initialized as 0.\n\nYou don't need to \"delete\" the card that you deal. Every time you deal the next variable will be incremented, so you know the index of the card that needs to be dealt next. So even though the cards are technically still there, you can ignore the cards before \"next\" and assume they've been \"removed\" from the deck."
    ]
  },
  {
    "question": "project_hpp only says Does not consider trump. Then how about led card color? Thanks!",
    "answers": [
      "No need to consider those either. Just compare the value of the card assuming there are no trump or led suits."
    ]
  },
  {
    "question": "project_The add_and_discard function will only get invoked when the dealer adds a card to his hand and discards the lowest in round1. Is that correct understanding?",
    "answers": [
      "i'm confused at your wording-- that's what the add_and_discard function does, but not when it is \"invoked\".\n\naccording to the spec, add_and_discard is invoked \"If the trump suit is ordered up during round one\".\n\nis that helpful?"
    ]
  },
  {
    "question": "project_For the input file format, can we assume that the cards will always be in the exact same order (starting with Nine of Spades and ending with Ace of Diamonds)? Or should we only assume that the file contains 24 different cards, but the order may be shuffled?",
    "answers": [
      "The latter."
    ]
  },
  {
    "question": "project_Should we make a CARD_NAMES just like rank and suit have RANK_NAMES and SUIT_NAMES?  Also, for the std::istream & operator>>(std::istream &is, Card &card)function, should we make a string_to_card helper function just like suit and rank have string_to_suit and string_to_rank?",
    "answers": [
      "I don't think having a enum for CARD_NAMES will be very helpful since the value of the card will change based on the trump/lead suits. \nYou are free to create helper functions."
    ]
  },
  {
    "question": "project_Let's say that the led suit is diamonds and the trump is diamonds. If you have no diamond cards in your hand and you only have the left bower, does this count as being a part of the led suit? Is the left bower considered a diamond here?",
    "answers": [
      "By definition, the left bower would be a diamond"
    ]
  },
  {
    "question": "project_\"If any player orders up, the upcard\u2019s suit becomes trump and the dealer is given the option to replace one of their cards with the upcard\". For simple player, when does the dealer decide to do this, and what card do they substitute the upcard for? Please let me know if there is a place where this logic is spelled out. I just couldn't find it in the rule explanation or the spec. Thank you!",
    "answers": [
      "It's in Player-Simple Player-Making section"
    ]
  },
  {
    "question": "project_Hi! When I tried to write test cases for simple player play_card function with 1) all cards available are aligned with the led card's suit 2) not all cards are aligned with the led card's suit but the same suit card is available in hand, I got both tests as false positives. I am not sure what is wrong (with my implementation in Player.cpp or the test cases itself), and wonder if anyone can give me some hints on the issue. Thank you!",
    "answers": [
      "False positives mean that your test incorrectly identifies correct code as incorrect. I.e. when we run your tests again our solution, they return that the solution is incorrect. \n\nI took a look at your false positive tests and they seem to assume the player will be playing the lowest card in their hand when you can follow led suit, and the highest when they cannot. \n\nThe spec notes \"If a Simple Player can follow suit, they play the highest card that follows suit. Otherwise, they play the lowest card in their hand.\" This seems to be the issue in both tests. Let me know if this helps!"
    ]
  },
  {
    "question": "project_For the representation invariants section, is it asking us to make a function for check invariants, which asserts that the cards are ordered using comparisons, like in the lecture notes with triangle, or is it just asking us to call the sort method on the hand each time we add a card?",
    "answers": [
      "It is just asking you to call sort every time a card is added to the hand."
    ]
  },
  {
    "question": "project_I'm having trouble passing the Card test. Everytime I submitted to Autograder it show \"  bash: line 1: ./Card_public_tests.exe: No such file or directory\" and the compiler would say  /usr/bin/ld: Card_public_tests.o: in function `test_card_insertion()': /home/autograder/working_dir/Card_public_tests.cpp:53:(.text+0x4e5): undefined reference to `operator<<(std::ostream&, Card const&)' /usr/bin/ld: Card_public_tests.o: in function `test_card_extraction()': /home/autograder/working_dir/Card_public_tests.cpp:60:(.text+0x65e): undefined reference to `operator>>(std::istream&, Card&)' /usr/bin/ld: Card_public_tests.o: in function `decltype ({parm#1}<<{parm#2})& unit_test_framework::Diagnostic::print_helper<Card>(std::ostream&, Card const&, int, int)': /home/autograder/working_dir/unit_test_framework.hpp:215:(.text._ZN19unit_test_framework10Diagnostic12print_helperI4CardEERDTlsfp_fp0_ERSoRKT_ii[_ZN19unit_test_framework10Diagnostic12print_helperI4CardEERDTlsfp_fp0_ERSoRKT_ii]+0x29): undefined reference to `operator<<(std::ostream&, Card const&)' collect2: error: ld returned 1 exit status make: *** [public.mk:32: Card_public_tests.exe] Error 1",
    "answers": [
      "The error is indicating that your Card_public_tests did not compile as a result of a missing definition for operator<< and operator>>. Make sure you implemented these correctly in Card.cpp."
    ]
  },
  {
    "question": "project_When implementing the default constructor for Pack , is it okay to initialize the cards array in the body of the constructor (i.e. inside the curly braces)? Here's what I have:  Pack::Pack()    : next(0) {   int index = 0;   for (int s = SPADES; s <= DIAMONDS; ++s) {     for (int r = NINE; r <= ACE; ++r) {       cards[index] = Card(static_cast<Rank>(r), static_cast<Suit>(s));       ++index;     }   } }   I'm asking because I remember hearing in lecture that it's generally not a good idea to do this and that it's always better to use a member-initializer list instead.  If this is not good practice, then could I get some guidance on what I can do instead? I don't remember learning about how to initialize an array in the member-initializer list.",
    "answers": [
      "Yes, it's okay to initialize the cards array using the curly braces.\n\n It's not a good idea to initialize member variables outside of a member-initializer list due to efficiency. With a member-initialized list, the constructor initializes the variable with the value given. However, if the variable is not initialized through the list, the constructor initializes the variable with a default value and then assigns the value in the curly braces.\n\nHowever, there are some cases where it's necessary to use the curly braces :)"
    ]
  },
  {
    "question": "project_Autograder says this: Simple Player add_and_discard() Bug #2 - Your tests fail to catch a bug in this function.  Need some guidance on add_and_discard test cases. This function is called only if  in round 1 a player orders up and an upcard becomes a trump. The dealer then has the option to replace one of their cards  The add_and_discard function is called for this purpose.  This function returns void. How can we test that the dealer added/discarded the correct card?  Do we check all cards in dealers hand before and after add_and_discard? There is no public function to get the vector<Card> hand?",
    "answers": [
      "The way I did it was play out the hand after the add/discard was done. If the hand is as expected, you can follow the rules set out in the spec on how the hand should be played out and assert equal each card in the test. This is a good way to implicitly test your play_card function as well."
    ]
  },
  {
    "question": "project_My question asks if we can treat left bowers of trump suits the same with led suits. For example, if the trump suit and led suit is different, lets say trump is hearts and led suit is spades. If we have a left bower of the spade suit, then does that mean we can follow suit? Or do bowers only apply to trump?",
    "answers": [
      "bowers only apply to trump ^^"
    ]
  },
  {
    "question": "project_I know we have to make the SimplePlayer and HumanPlayer derived classes and define the member functions in the derived classes.  Do we still have to define the functions in the base class then? Can we just leave them as function stubs?  It seems kind of redundant to give the same definition of a function between the derived classes and the base class.",
    "answers": [
      "the base class is already written for you, you can find it Player.hpp!\n\n\"It seems kind of redundant to give the same definition of a function between the derived classes and the base class.\" that's exactly why pure virtual functions exist! you'll notice that in Player.hpp, all of the functions are virtual and end in \"= 0\". \"virtual\" defines it as a function that can be overridden, and the \"= 0\" is what makes it \"pure\"-- meaning it must be overridden in order to be used because there is no base class implementation."
    ]
  },
  {
    "question": "project_I have two related questions about the led suit and the left bower:  1. When implementing bool Card_less(const Card &a, const Card &b, const Card &led_card, Suit trump) in Card.cpp, if the left bower is the led_card, is the led suit the original suit of the led_card or is it the trump suit?  In other words, which one of these two lines would be correct?  Suit led = led_card.get_suit(trump);   Suit led = led_card.get_suit();   2. When implementing play_card(const Card &led_card, Suit trump) in Player.cpp, if the left bower is the led_card, is the led suit the original suit of the led_card or is it the trump suit?",
    "answers": [
      "1. Suit led = led_card.get_suit(trump); \n\n2. Trump suit\n\nRemember that once the trump is made, the left bower \"adopts\" that suit and is always considered part of the trump suit for the remainder of the hand."
    ]
  },
  {
    "question": "project_For the checkpoint submission, is it sufficient to only implement the human subtype to the extent necessary to pass the tests in Player_public_tests.cpp?  Or do we need to fully implement human and write our own tests of human in Player_tests.cpp at this time?",
    "answers": [
      "There are no private tests for the checkpoint, if that is what you mean! So if you are passing everything up through the player public tests, then you should be good checkpoint-wise."
    ]
  },
  {
    "question": "project_I'm still confused on the spec. It says \"The dealer then discards the lowest card in their hand, even if this is the upcard, for a final total of five cards. (Note that at this point, the trump suit is the suit of the upcard.)\", then should I consider trump suit (suit of the upcard) when choosing the lowest card?   For example,   1. If I have 4 trump cards and 1 non-trump card in hand, then, should I always keep the upcard and discard the the one non-trump card?  3. If I have 5 trump cards in hand, then should I discard the lowest trump card while considering the trump suit values (right bower > left bower > A > K > Q > 10 > 9) ?",
    "answers": [
      "Yep, you are exactly correct. You'll discard your lowest card in relation to the trump suit, so your examples are accurate."
    ]
  },
  {
    "question": "project_In my current implementation for humanplayer tests I am using play_card to read the players hand in the tests. For such functions such as add_and_discard I use input redirection to get a certain input to read the first card for every play_card. How will the autograder test my tests if it doesnt know what inputs it should have? I keep getting false positives.",
    "answers": [
      "You don't need to test human players!\n\nWe will autograde your Card_tests.cpp and Player_tests.cpp unit tests. Note that your player tests should only test the \u201csimple player\u201d, not the \u201chuman player\u201d."
    ]
  },
  {
    "question": "project_If we submit more than 3 times a day to autograder, and our last submission is the highest, will it still count as a submission? Is the 3 submissions rule only for providing hints?    Thank you!",
    "answers": [
      "You are only able to submit up to 3 times a day to autograder. The submission with the highest points will be counted as your final submission."
    ]
  },
  {
    "question": "project_Will the Autograder allow me to submit files to the Project 3 Checkpoint after the due date? I know that it won't count towards my final grade, but will it still score my submission like it would if I had submitted it on time?",
    "answers": [
      "It will not let you submit if you're used 3 or it's past the due date"
    ]
  },
  {
    "question": "project_The autograder said I have a false positive for a test function that tests the card_less function that takes into account trump, and I'm not really sure whether the issue is with the way I wrote my tests or if it is the actual implementation in card.cpp. If anyone could give any hints on what the issue is, that would be much appreciated. Thank you!",
    "answers": [
      "One of the test cases in test_card_card_less_trump is asserting that a trump card is higher (not less) than the left bower."
    ]
  },
  {
    "question": "project_Since the overloaded operators for cards like < and > don't consider trump, and thus don't consider bowers, how can we accurately determine which cards are highest and lowest in functions like lead_card and play_card in Player.cpp? Should we add extra code each time to properly rank the cards?",
    "answers": [
      "Think about some other functions you have implemented in Card.cpp that you could use. Are there any functions that take in two cards, a trump suit, and even a led suit and determine if one card is less than the other? How can you use those functions to find, for instance, the \"max\" or \"min\" card in one's hand to play in a trick?"
    ]
  },
  {
    "question": "project_When will the autograder open for the full project? I wan trying to submit it but there was only tabs for the checkpoint.",
    "answers": [
      "I believe it's open now"
    ]
  },
  {
    "question": "project_Hi,  I submitted my work before the deadline and received full points, but I encountered UB errors. I'd like to check if I've resolved them. However, I haven't started writing the euchre section yet, so I don't think I should submit the full project just yet. Is it okay to submit to the checkpoint even though it's after the deadline? If I do, will it affect the score I already have?  Thanks in advance for your help!",
    "answers": [
      "I believe you can't submit to the checkpoint anymore, however the full project 3 autograder also has all of the tests from the checkpoint. So, you can just submit to that, it's fine that you haven't written the euchre section yet."
    ]
  },
  {
    "question": "project_Will Ed Discussion be active during spring break? If so, can I expect responses?",
    "answers": [
      "The forum will be active, but staff may not be answering as many questions over break."
    ]
  },
  {
    "question": "project_for euchre.cpp, do we have to create a header file for the class?",
    "answers": [
      "No, you do not need to make a header file for euchre.cpp."
    ]
  },
  {
    "question": "project_Do we implement the functions of Game directly in the class? So for example:   class Game {  public:  void play() {  // implementation  }  };",
    "answers": [
      "You may"
    ]
  },
  {
    "question": "project_At round 1, is the dealer always player0? And after that in round 2, the dealer will be the person on the left, in this case player1?",
    "answers": [
      "yes"
    ]
  },
  {
    "question": "project_In Euchre.cpp, can Player type inputs be mixed (eg. 2 Simple players and 2 Human players)? Or do we have to strictly focus on players with the same types, either Simple or Human?",
    "answers": [
      "yes, it can be mixed"
    ]
  },
  {
    "question": "project_I'm running test01. In Hand 1, my cards aren't being dealt correctly even though they were correct in Hand 0 and I made sure to reset the pack before shuffling in my shuffle function. The cards in question are Ace of Clubs and Jack of Diamonds. The Ace of Clubs is supposed to go to the player at index 2(Gabriel) and the Jack of Diamonds is supposed to go to the player at index 3(Herb). For some reason, the Jack of Diamonds is given to Gabriel so when it's time for Gabriel to take the Ace of Clubs, he can't because he already has 5 cards.  This is my code for the deal function, I would really appreciate any help or insight you can provide me with. Thank you.   void deal(int dealer_indexes,int current_hands, Card &first_upcards) { \t\t\tint left; \t\t\tint second_left; \t\t\tint third_left; \t\t\tstring dealer_name=players[dealer_indexes]->get_name(); \t\t\tcout<< \"Hand \"<<current_hands<<endl; \t\t\tcout<< dealer_name<< \" deals\"<<endl; \t\t\t//cout<< first_upcards<< \" turned up\"<<endl;  \t\t\tleft = (dealer_indexes + 1) % 4;     \t\tsecond_left = (dealer_indexes + 2) % 4;     \t\tthird_left = (dealer_indexes + 3) % 4;   \t\t\t//player left of dealer \t\t\tplayers[left]->add_card(pack.deal_one()); \t\t\tplayers[left]->add_card(pack.deal_one()); \t\t\tplayers[left]->add_card(pack.deal_one()); \t\t\t// for (int i = 0; i < 3; i++) { \t\t\t// \tCard c = pack.deal_one(); \t\t\t// \tplayers[left]->add_card(c); \t\t\t// \tcout << \"Player \" << left << \" receives \" << c << endl; \t\t\t// }  \t\t\t//player 2 positions left of dealer \t\t\tplayers[second_left]->add_card(pack.deal_one()); \t\t\tplayers[second_left]->add_card(pack.deal_one()); \t\t\t// for (int i = 0; i < 2; i++) { \t\t\t// \tCard c = pack.deal_one(); \t\t\t// \tplayers[second_left]->add_card(c); \t\t\t// \tcout << \"Player \" << second_left << \" receives \" << c << endl; \t\t\t// }  \t\t\t//player 3 positions left of dealer \t\t\tplayers[third_left]->add_card(pack.deal_one());     \t\tplayers[third_left]->add_card(pack.deal_one());     \t\tplayers[third_left]->add_card(pack.deal_one()); \t\t\t// for (int i = 0; i < 3; i++) { \t\t\t// \tCard c = pack.deal_one(); \t\t\t// \tplayers[third_left]->add_card(c); \t\t\t// \tcout << \"Player \" << third_left << \" receives \" << c << endl; \t\t\t// }  \t\t\t//dealer \t\t\tplayers[dealer_indexes]->add_card(pack.deal_one()); \t\t\tplayers[dealer_indexes]->add_card(pack.deal_one()); \t\t\t// for (int i = 0; i < 2; i++) { \t\t\t// \tCard c = pack.deal_one(); \t\t\t// \tplayers[dealer_indexes]->add_card(c); \t\t\t// \tcout << \"Dealer \" << dealer_indexes << \" receives \" << c << endl; \t\t\t// }  \t\t\t//player left of dealer \t\t\tplayers[left]->add_card(pack.deal_one()); \t\t\tplayers[left]->add_card(pack.deal_one()); \t\t\t// for (int i = 0; i < 2; i++) { \t\t\t// \tCard c = pack.deal_one(); \t\t\t// \tplayers[left]->add_card(c); \t\t\t// \tcout << \"Player \" << left << \" receives \" << c << endl; \t\t\t// }  \t\t\t//player 2 positions left of dealer \t\t\tplayers[second_left]->add_card(pack.deal_one()); \t\t\tplayers[second_left]->add_card(pack.deal_one()); \t\t\tplayers[second_left]->add_card(pack.deal_one()); \t\t\t// for (int i = 0; i < 3; i++) { \t\t\t// \tCard c = pack.deal_one(); \t\t\t// \tplayers[second_left]->add_card(c); \t\t\t// \tcout << \"Player \" << second_left << \" receives \" << c << endl; \t\t\t// }  \t\t\t//player 3 positions left of dealer \t\t\tplayers[third_left]->add_card(pack.deal_one()); \t\t\tplayers[third_left]->add_card(pack.deal_one()); \t\t\t// for (int i = 0; i < 2; i++) { \t\t\t// \tCard c = pack.deal_one(); \t\t\t// \tplayers[third_left]->add_card(c); \t\t\t// \tcout << \"Player \" << third_left << \" receives \" << c << endl; \t\t\t// }  \t\t\t//dealer \t\t\tplayers[dealer_indexes]->add_card(pack.deal_one()); \t\t\tplayers[dealer_indexes]->add_card(pack.deal_one()); \t\t\tplayers[dealer_indexes]->add_card(pack.deal_one()); \t\t\t// for (int i = 0; i < 3; i++) { \t\t\t// \tCard c = pack.deal_one(); \t\t\t// \tplayers[dealer_indexes]->add_card(c); \t\t\t// \tcout << \"Dealer \" << dealer_indexes << \" receives \" << c << endl; \t\t\t// } \t\t\t \t\t\tfirst_upcards=pack.deal_one(); \t\t\tcout<< first_upcards<< \" turned up\"<<endl;   \t\t\t \t\t}",
    "answers": [
      "You shouldn't be creating a new pack every time you shuffle. Instead call shuffle on the existing pack.",
      "I found the issue, thank you."
    ]
  },
  {
    "question": "project_Hi! So we read someone else's thread about testing the add_and_discard function in SimplePlayer, and we were also having trouble with it (#513). Someone replied to it saying that they played out the entire hand after they had called the add_and_discard function in the test case, and asserting equal each card in the test. However, in the past we made a public vector for the cards in our hand and the compiler did not allow us to assert equal each card. We were wondering if there is another way to make the vector accessible to the tests or if there is another way to test this function. Thanks!",
    "answers": [
      "To test this function, you can use add_card to add cards to a players hand, then call add_and_discard. Then, you can use lead_card or play_card repeatedly to see whether the card you expected to be discarded remained in the hand or not."
    ]
  },
  {
    "question": "project_Hello!  I would like to be able to print out all the cards in a player's hand as a function in euchre.cpp for debugging purposes, but I am not sure how to do this since hand is a private part of a Player. Am I allowed to make a function in Simple Player that prints the hand? Or are we not supposed to modify the structure of Player?",
    "answers": [
      "If you are trying to debug, it is best to use the visual debugger as it will show you the member variables as you debug. As far as modifying the simple player, it will likely cause problems as all functions in Player.hpp are pure virtual."
    ]
  },
  {
    "question": "project_Is our program supposed to account for multiple rounds (hands)? For instance, after all 5 tricks are played, am I supposed to restart the hand by shuffling, dealing... Also, when hand ends, does the dealer become the person to the left of the previous dealer?",
    "answers": [
      "Yes and yes."
    ]
  },
  {
    "question": "project_For the different hands, how does the upcard change? Am I supposed to shuffle the deck again after the first hand?",
    "answers": [
      "Yes, the deck should be shuffled at the beginning of each hand."
    ]
  },
  {
    "question": "project_Hi, I'm confused about add_card and add_and_discard for the simple player.   The spec says: \"If the trump suit is ordered up during round one, the dealer picks up the upcard. The dealer then discards the lowest card in their hand, even if this is the upcard, for a final total of five cards. (Note that at this point, the trump suit is the suit of the upcard.)\"  During making trump, all players have five cards. If the simple player is the dealer, they pick up the upcard before discarding the lowest card in their hand. This breaks the requires clause for add_card.   Also the requires clause for add_and_discard only requires player has at least one card. It seems that the only time a player may add and discard a card is during making trump--when all players have 5 cards, am i missing something? Thanks",
    "answers": [
      "Note that you are adding and discarding in add_and_discard so you can discard before you add to meet the requires clause of add_card. Additionally, you are correct that add_and_discard will practically only be used when a player has 5 cards, but the function should be implemented such that it would work as long as the player has at least one card."
    ]
  },
  {
    "question": "project_Hi,   When \"screw the dealer\" happens in the second round, will the human player be provided with a chance to enter their choices? Or the game will automatically decide for them, which is ordering up.",
    "answers": [
      "The human player is still given the chance to enter their choices. We \"trust\" that the human player plays according to the rules."
    ]
  },
  {
    "question": "project_Are you supposed to take the discarded cards and put them in a specific order and then shuffle? Or do you start from the same pack.in order when shuffling before the start of the next hand? How would the upcard change for each hand?",
    "answers": [
      "Remember that when we deal cards from the pack, all we're really doing is moving our \"next\" around. So, you can just use your normal shuffle implementation each time on the pack. You don't want to start from the same pack.in order each time."
    ]
  },
  {
    "question": "project_When a game is created, can we assume all players be the same type (all human or all simple)? Or can there be a mix of human and simple players?",
    "answers": [
      "There can be a mix. When writing Euchre.cpp, you shouldn't need to account for whether a player is human or simple once the player object has been made since the two classes have matching function calls."
    ]
  },
  {
    "question": "project_Hi,   I just wanted to double check my understanding of the operators. I know you are supposed to account for both the rank and suit, but are you only supposed to look at suit when ranks are equal? Or are both suit and rank determining order for all cards? For example, my < operator ranks the Queen of Diamonds higher than the Ace of Clubs when asked to evaluate Ace < Queen because diamonds rank higher than clubs. Should this be the case? or should I write the code to evaluate suit only if ranks are equal?   Thanks!",
    "answers": [
      "Take a look at the value of cards section of the spec. You only look at suit when ranks are equal."
    ]
  },
  {
    "question": "project_I am trying to debug for the human players' test, but I am not sure how to set up standard input in Xcode (< euchre_test50.in > euchre_test50.out). It seems like there isn't an option to do so.",
    "answers": [
      "There's a tutorial section about this."
    ]
  },
  {
    "question": "project_Hi, I have a question when using ASSERT_EQUAL() when testing player.cpp. Does that assert only compare rank? I got some false positives on my test cases for player.cpp, and when I looked into it, ASSERT_EQUAL() was basically saying my card was two suits at the same time.   For example, from the Player_public_tests.cpp in test_simple_player_lead_card:  ASSERT_EQUAL(card_led, ace_spades); equates to true when card_led = Card(ACE, SPADES) and ace_spades = Card(ACE, SPADES)  but  ASSERT_EQUAL(card_led, ace_diamonds); also equates to true when card_led = Card(ACE, SPADES) but ace_diamonds = Card(ACE, DIAMONDS)  If I changed the rank and said ASSERT_EQUAL(card_led, ten_spades) when card_led = Card(ACE, SPADES) then I end up with a false. From my perspective, it seems like ASSERT_EQUAL() only compares rank. Is this correct thinking or did I download something incorrectly? Would it have something to do with GitHub?",
    "answers": [
      "This is most likely an issue with how you implemented operator== in Card.cpp. Make sure that function takes into account both rank and suit."
    ]
  },
  {
    "question": "project_I've tried a couple different things and all of them come up as wrong. When trying to access the players inside std::vector<Player*> players; nothing seems to work. I've tried *players[index], players[index], and  &players[index] and all of them come up with an error.  On top of that if I try to put it into a Player first, it says \"object of abstract class type \"Player\" is not allowed\" even though I have #include \"Player.hpp\"   Please help point me in the right direction!",
    "answers": [
      "You should be able to use the players using, for example, Player* player = players[index], or players[index]->some_function() . If that's not working, follow up here."
    ]
  },
  {
    "question": "project_For euchre_tests01, why is the second card turned up different than the first one if the shuffling is the same both times? Am i missing something from the spec where it specifies something?",
    "answers": [
      "You aren't shuffling a \"fresh\" pack each time. For example, on the second hand, you'll be shuffling the shuffled deck, resulting in a new arrangement of cards."
    ]
  },
  {
    "question": "project_For euchre_tests01, for the second hand, do you just shuffle the deck again, even if it was already shuffled before? In that case, you don't need to create a separate vector to store the cards that were played and shuffle them specifically, right? So, it\u2019s not about shuffling the cards in the order they were played. How does this process differ from the way a human would handle it?",
    "answers": [
      "If you call your shuffle function again, and it is written correctly, you shouldn't have any issues. You don't need to save played cards or anything like that."
    ]
  },
  {
    "question": "project_How is it my code compiles in vs code but can't in autograder?",
    "answers": [
      "There might be many reasons. The general approach is to look at the error message on AG and debug from there. You can also check out this tutorial to push your code to caen and run it there. \n\nIn your case, please double check you have submitted all required files to AG."
    ]
  },
  {
    "question": "project_I understand that to test the euchre.cpp driver implementations ,it's recommended to see how our \"outfile\" compares to that of the correct answer. For some reason, our file is completely blank. How should we go about tackling this issue?",
    "answers": [
      "Could you send the command line prompt you used to generate the outfile? \n\n./euchre.exe [bunch of args] > [your outfile] works for me."
    ]
  },
  {
    "question": "project_When running euchre.cpp there is nothing outputted to euchre_test00.out. What command line argument should the output file be assigned to?",
    "answers": [
      "Please take a look at the protip here"
    ]
  },
  {
    "question": "project_In the player_public_tests, lead_card fails to pass the test which I believe is due to my lead_card function. Ive implemented it to return a card that matches the suit of the trump regardless of all other cards just like the spec says. I get the output of Nine of hearts != Ace of spades.   My question is why would I output a Ace of spades if in my deck, I have a card with the trump suit. Am i supposed to output a card depending on the Rank or the suit of the card?  for example, if I have a left bower or right bower of a suit, would I return those cards regardless if theres a higher ranking card in the deck or still return the highest ranking card?",
    "answers": [
      "\"When a Simple Player leads a trick, they play the highest non-trump card in their hand\". For lead card, you play highest non_trump card first. It is only in the case where ALL cards in your hand are trump that you play the highest trump."
    ]
  },
  {
    "question": "project_Simple Player and Human player have very similar functions, with the get_name and add_card implementations being identical. The autograder says the code for these functions is duplicated but they can't really be moved out of player.cpp. How can I fix this issue so these two functions are not duplicated but still member functions of the simple and human player classes?",
    "answers": [
      "Make sure you are reading the spec very carefully, because the implementations aren't super similar for the Simple and Human players, the Simple player will be more complex and have to make decisions where the human player side only has to provide choices and receive in a decision of what to do from the human player, along with that, in the spec you are provided with a lot of code that you can use to implement your human player functions.\n\nCheck this part of the spec: https://eecs280staff.github.io/euchre/#human-player"
    ]
  },
  {
    "question": "project_So im currently playing a quick game of euchre where I had a trump suit being spades. A player initially placed Ace of clubs, 10 of spades and 9 of hearts. why is the game only letting me choose two cards of my deck which are queen of clubs and 10 of clubs where I also had a queen of spades but it did not give me the option to choose it.  I'd like to understand how I could connect this with the lead_card function. From my understanding the simple_player is supposed to choose the highest card that follows suit. Otherwise, they play the lowest card in their hand. Im a bit confused on how to keep moving forward.",
    "answers": [
      "If the led card was an Ace of Clubs, you have to follow suit with what was led, and that is a general rule of euchre, you must follow the suit of what was led if possible, and since you had 2 clubs cards in your deck, you must follow suit by playing a club. If instead you had a queen of hearts, a 10 of diamonds, and a queen of spades, then you wouldn't have any cards that follow the suit of the led card and would be allowed to play any card in your hand. In the case of the other players playing cards not of the led suit, they just didn't have cards that matched the led card suit."
    ]
  },
  {
    "question": "project_Hi! Since we wrote a default constructor for Pack, will we ever need to call it in euchre.cpp? Or will there always be an input pack and thus only the second constructor will be called? Thanks!",
    "answers": [
      "You shouldn't need to call the default constructor in euchre.cpp"
    ]
  },
  {
    "question": "project_I am working on keeping track of points for player teams on euchre.cpp  I am having a hard time keeping track of which player played the card that wins the trick (so that they win the trick and points are added to their team)  I have tried having a vector that includes the card and player who played it and I have tried creating two separate vectors with one containing the cards played in a trick, and the other containing players. But it does not allow me to use push_back on a vector of players, as no overload function exists to accommodate that. May I please have some guidance on how I can go about this?  Thank you.",
    "answers": [
      "I think the creating 2 separate vectors is a good strategy especially since you already explored that idea. I'd be careful using push_back any time other than when you might be initializing a vector for use since push_back will increase the size of your vector and make it hard to align which card belongs to which player and this may be where you were having issues, and you might want to try just indexing instead. Remember that you can also using indexing to change the value at a specified position in the vector such as overwriting an already existing value. Also if you have 2 vectors of size 4 to hold both the players and the cards in the hand and have to go through the players around the table, you can figure out a way to keep track between the two vectors of which player played which card."
    ]
  },
  {
    "question": "project_Hi,   The autograder says there's code duplication in Card.cpp. Can I define a helper function in card.cpp to avoid this?",
    "answers": [
      "If this is in the different version of Card_less, I would recommend seeing if you can call some versions of Card_less in the other functions to reduce code duplication."
    ]
  },
  {
    "question": "project_Is play_hand just for when we go through the 5 tricks, or are we supposed to consider more than just the 5 tricks? Or are we thinking of it differently and we need to consider something for play_hand? My partner and I are having issues when considering what play_hand does.",
    "answers": [
      "You are free to organize the code how you'd like, but you can have play_hand take care of shuffling, dealing, making trump, and playing the 5 tricks."
    ]
  },
  {
    "question": "project_Hi!  I created a Game class, as suggested, and created a shuffle function, also as suggested, which shuffles the pack if and only if a boolean value \"is_shuffling\" is true.   However, the IF statement always skips, even if the debugger says the value is true immediately before the IF statement. So my code never shuffles :(  I confirmed that the bool is accessible.  Why might the IF statement be skipped anyway?",
    "answers": [
      "Answer: It had to do with the way shuffle was initialized. Fixed!"
    ]
  },
  {
    "question": "project_Hi, we were working on euchre.cpp and when making euchre.exe in the terminal there was a bunch of errors related to the fact that Players has two derived classes. It mentioned something about \"virtual functions\" and \"uninitialized copies\".  For example, it said: \"Player.hpp:17:7: note: because the following virtual functions are pure within \u2018Player\u2019: 17 | class Player { | ^~~~~~\"  We are thinking this may have to do with the fact that we have a vector of players, with each element of type * from the Player Factory (so basically a virtual vector), or maybe it has to do with the derived classes?  We really want all players to be in their assigned index in a vector of size 4 (just for ease of not needing to specify the type in the Game functions), but unfortunately this error has come up. Any help is appreciated!",
    "answers": [
      "If you have a vector defined as vector<Player*> and are using the Player_factory to fill it, that shouldn't cause issues so the problem may be elsewhere. Make sure you are overriding all the functions you need to. If you are still having issues, you can create a private post with your code or come to office hours once they start back up."
    ]
  },
  {
    "question": "project_For the test \"test_simple_player_lead_card\", I'm passing in vscode but failing in the autograder. the result should be the ace of spades which is what I get in vscode, but the autograder is saying that my code is outputting the king of spades. what could be the reason for the conflicting results?",
    "answers": [
      "Hmmm, that is odd--I would expect local and Autograder tests to output the same.  Double check that your local version of  Player.cpp matches the code uploaded to autograder. Otherwise, I would guess that something is going wrong with how you are accessing things in memory (i.e. adding or removing things from your collection of cards)."
    ]
  },
  {
    "question": "project_In the Game class in the Euchre.cpp, do we have to account for the fact that the dealer is not always player 0 and that it rotates to the left each round. This would impact which players get what number of cards following the 3-2-3-2 and 2-3-2-3 rule.",
    "answers": [
      "Yes, you do have to account for that when implementing your driver function."
    ]
  },
  {
    "question": "project_Keep getting this error on Player public tests. Need some guidance.  Running test: test_add_and_discard2FAIL3Running test: test_player_add_card4PASS5Running test: test_player_get_name6PASS7Running test: test_player_insertion8PASS9Running test: test_simple_player_lead_card10FAIL11Running test: test_simple_player_make_trump12PASS13Running test: test_simple_player_play_card14FAIL1516*** Results ***17** Test case \"test_add_and_discard\": FAIL18In ASSERT_EQUAL(hand2, expected2), line 459:19{ Ten of Hearts, Jack of Diamonds, Queen of Hearts, King of Hearts, Ace of Diamonds } != { Nine of Hearts, Ten of Hearts, Jack of Diamonds, Queen of Hearts, King of Hearts }2021** Test case \"test_player_add_card\": PASS22** Test case \"test_player_get_name\": PASS23** Test case \"test_player_insertion\": PASS24** Test case \"test_simple_player_lead_card\": FAIL25In ASSERT_EQUAL(card_led, jack_hearts), line 221:26Ace of Diamonds != Jack of Hearts2728** Test case \"test_simple_player_make_trump\": PASS29** Test case \"test_simple_player_play_card\": FAIL30In ASSERT_EQUAL(card_played, Card(JACK, DIAMONDS)), line 336:31King of Diamonds != Jack of Diamonds3233*** Summary ***34Out of 7 tests run:353 failure(s), 0 error(s)",
    "answers": [
      "\"test_add_and_discard\": FAIL18In ASSERT_EQUAL(hand2, expected2), line 459:19{ Ten of Hearts, Jack of Diamonds, Queen of Hearts, King of Hearts, Ace of Diamonds } != { Nine of Hearts, Ten of Hearts, Jack of Diamonds, Queen of Hearts, King of Hearts }: This line most likely means your add_and_discard function might be doing something wrong. It is discarding nine of hearts instead of ace of diamonds. I would check your add and discard function and double check your operator functions in card as well to make sure they compare correctly."
    ]
  },
  {
    "question": "project_Hi, I am getting a code duplication error for my card_less functions. They are very similar in nature so some parts of their definitions are similar as well. Any help would be appreciated please.",
    "answers": [
      "You can call some of your card_less functions in other ones. This may help with the code duplication issues."
    ]
  },
  {
    "question": "project_Hello, I keep getting false positives for my play_card tests and do not really know what to do. I used play card tests in other parts of my tests and it worked fine but in play tests it keeps reporting a false positive. I am not sure what is wrong and was wondering if anyone could give me any hints on the issue. Thank you.",
    "answers": [
      "Take a look at what you are asserting and what is actually being returned to make sure that you are not asserting the wrong card for any of the asserts."
    ]
  },
  {
    "question": "project_Hi!  I noticed that Autograder have \"Euchre Private Tests\" and \"Euchre Private Tests with Solution Card, Pack, Player\" sections. Since we are not required to make private tests cpp file for euchre.cpp. So I am wondering how we can check whether all the private tests for euchre are satisfied or not.",
    "answers": [
      "One way to do this is to write your own output solution for a specific set of command line arguments, and then run your solution with those to see if your program output matches the solution you created."
    ]
  },
  {
    "question": "project_When implementing the Game ADT, are we allowed to make a Game.hpp file and Game.cpp file? If so, should I submit both of the hpp file and the cpp file to the autograder?",
    "answers": [
      "No, it should all be implemented in euchre.cpp as the autograder only takes that file for grading."
    ]
  },
  {
    "question": "project_When implementing the make_trump() function in euchre.cpp what should the initial upcard be. How do we keep track of the upcards since they are not in a player's hand?",
    "answers": [
      "The upcard should be the first card from the pack, i.e., the result when you call deal_one on the pack"
    ]
  },
  {
    "question": "project_In euchre.cpp, the spec suggests we include void shuffle() as a private member function, but we have already written void shuffle() in Pack.cpp. I'm just a little confused on whether we are supposed to copy and paste our shuffle() from Pack.cpp into euchre.cpp, or if there is some sort of inheritance I need to make sure it calls the shuffle() function I already wrote.",
    "answers": [
      "The shuffle() function in Pack actually shuffles the deck of cards, you shouldn't rewrite this or re-declare it in euchre.cpp. The suggestion is to have a function in euchre.cpp that reads the input and determines what to do with the pack of cards, possibly calling the pack.cpp shuffle() function or not depending on the game inputs."
    ]
  },
  {
    "question": "project_In euchre_test01.html for Hand 0 the output is:  Hand 0 Edsger deals Nine of Hearts turned up Fran orders up Hearts  The explanation states:  Edsger\u2019s Hand: J of Clubs, A of Spades, K of Diamonds, J of Spades, 9 of Hearts  So since Edsger's hand has 9 of Hearts, he has picked up the upcard and discarded his lowest? Is that correct?",
    "answers": [
      "correct!"
    ]
  },
  {
    "question": "project_When I compile and run my euchre.cpp driver file, I get this error:   libc++abi: terminating due to uncaught exception of type std::out_of_range: vector  Whenever I index into my vectors, I use .at(), and the error message does not tell me where this error is happening. How would I go about trying to solve this?",
    "answers": [
      "I had these a few times, it is telling you that you are indexing out of range. Like a seg-fault error, you have to run in a visual debugger to look at where the code is breaking. If you want an idea of where to start, look at how much the code prints out before it breaks (your .out file updates until your code breaks). For example, if you print until the beginning of the third hand, then add a pause at the beginning of the hand and skip to the third one, then slowly continue through the code until the fault occurs."
    ]
  },
  {
    "question": "project_We are running the game and we are not sure what is causing for the right cards to not be dealt to the players. We were wondering if we can get some help with what potential functions could be causing the issue. Could it possibly be the shuffle function or are there other functions that could cause the error",
    "answers": [
      "shuffle could definitely be the answer, whether its the implementation or where its called in your code. you could also have an issue with when your \"next\" is being reset to 0. if your deal function is correct, those are the main places i'd look!"
    ]
  },
  {
    "question": "project_Are we allowed to use maps in euchre.cpp?",
    "answers": [
      "Based on the spec, I assume no."
    ]
  },
  {
    "question": "project_Whenever I try to go and debug euchre.exe, since I can't put in the parameters that euchre needs in int main, it exits the code prematurely and returns 1, and it doesn't allow me to go and debug. Is there something I need to do differently, or am I unable to put in the arguments necessary for euchre.cpp/euchre.exe?   I've also tried setting the breakpoints in different places after or before where it checks if the arguments are put in correctly but it still exits prematurely.",
    "answers": [
      "Have you tried following this tutorial on adding the arguments inside your .json file in order to run the debugger using command line arguments so that it doesn't fail out like you mentioned?\n\nHere is an example that might help:\n\nUsing the args you can input command line prompts in order to configure the debugger to run as it would if you pasted the ./euchre.cpp pack.in..... command line from the spec sheet into your command line as shown here and also outlined in the tutorial I hyperlinked above.\n\nHopefully that helps."
    ]
  },
  {
    "question": "project_I was checking my void shuffle function and found that if I only shuffle the deck 5 times instead of 7, I pass all the public tests, yet if I do the 7 listed within the spec, I fail one of the tests.   The issue is if I listen to the spec and implement 7 shuffles, I fail the pack public tests portion.   Has anybody came across this problem and been able to fix it?",
    "answers": [
      "Look at how simple the pack public test is. It only checks the first card! I would look more thoroughly using a debugger to see if one individual shuffle is correct. It is more than likely that the actual shuffle is incorrect, but it happens to put the first card in the correct spot after 5 shuffles but the wrong spot after 7."
    ]
  },
  {
    "question": "project_Hello! My partner and I coded euchre.cpp so that the 00, 01, and 50 outfiles are identical to the correct ones. However, autograder isn't taking our euchre.cpp file and giving this error:   make: *** No rule to make target 'euchre-warning-check.s'. Stop.  Since we didn't face any issues in the terminal (no segmentation fault, out of bounds error shown), we were wondering how we could go about this issue. Thanks!   By the way, I don't believe we edited the makefile at all.",
    "answers": [
      "You have that error because your file isn't attached to the submission. The autograder isn't accepting your file because it has a capital E (i.e. should be euchre.cpp not Euchre.cpp)."
    ]
  },
  {
    "question": "project_Good afternoon,   1) While researching best practices for writing a helper function, I came across the topic of using an anonymous namespace. Is this something we've covered that I missed or is this out of scope for this class?  2) I've read several of the posts about the STL sort() function, but I still don't see how we could use the sort() function given the additional logic requirements (trump and led card values). Am I misunderstanding how the sort function works, the specs, or both? I've gone ahead and written my own sort helper function that takes trump and led card into account. Please advise.  Very Respectfully,  TJ",
    "answers": [
      "1 - Out of scope\n\n2 - Read the pro-tip from the spec. \n\n cards in a human player\u2019s hand must always be printed in ascending order, as defined by the < operator in Card.hpp.\n\nThat means you don't worry about trump or led card when sorting. Just use the simple ordering from the < operator."
    ]
  },
  {
    "question": "project_After each hand, how do we determine the upcard, do we reshuffle again?",
    "answers": [
      "Spec:\n\nThe dealer shuffles the deck at the beginning of each hand."
    ]
  },
  {
    "question": "project_Hi! I am a bit confused with the play_card function. In the test01 correct output hand 9, the trump is spades,  the led is Jack of clubs,  and the three cards that Gabriel left in this trick are  Queen of diamonds,  nine of clubs,  and ten of clubs. In the spec, it says \"If a Simple Player can follow suit, they play the highest card that follows suit. Otherwise, they play the lowest card in their hand.\" So in this case, Gabriel has clubs available, and he should play ten of clubs, right? But in test01, Gabriel is playing nine of clubs instead. Could anyone clarify a bit about the logic of the play_hand function? Thanks!",
    "answers": [
      "Got the answer! The left bower's suit is the trump suit. So there is no matching for the led card suit and the available cards left. In this case, the lowest card will be played."
    ]
  },
  {
    "question": "project_Can someone explain why my tests are not catching \"Card Bug 10\":  Card_less(const Card &a, const Card &b, Suit trump) Bug #1 - Check the behavior of the operator by comparing two cards asserting the result is correct.  I have tests that run that compare smaller and larger and assert true, larger and smaller and assert false, and the same card to assert false.   I am not sure what I am missing.",
    "answers": [
      "A few things that you could test for: using Card_less with trump and non-trump cards, left bower, right bower, and any other interesting cases you can think of. However, looking at your autograder, you already have full points for the tests so note that catching additional bugs will not give you any more points."
    ]
  },
  {
    "question": "project_For the human player, I'm confused about how to implement it in Euchre. When I run it, the cout statements from the player class run as well as the euchre cout statements so then they print twice like when someone passes. Could I have some clarification on what I should be implementing for the main class for the human player",
    "answers": [
      "Within euchre.cpp, you shouldn't have separate code for human and simple player, it should be the same. The difference between the two should be handled within Player.cpp with the overloaded functions."
    ]
  },
  {
    "question": "project_I think my implementation for add_and_discard() function might be wrong for HumanPlayer.   For add_and_discard(), it is prompting the user to enter the number corresponding to the card they want to discard (or - 1 if they want to discard the upcard).   Question 1: Is this \"number corresponding to the card\" the index of the card in player's hand? or is it the number represented in the enum list?   Question 2: If my add_card() function sorts the hand, and I call the add_card() function in the add_and_discard() function, how do we generally know that this sort algorithm will use the < operator I defined in card.cpp? Isn't sort() function part of the <algorithm> library?",
    "answers": [
      "1. Index.\n\n2. The sort function will attempt to sort the cards using operator< of the object (a Card) that it is trying to sort, which you have previously defined."
    ]
  },
  {
    "question": "project_Hello, I just had a doubt going back to player.cpp. For the function add_discard, are we allowed to add the upcard to the hand even if the hand already has 5 cards? After adding the ucpard, I just check to see what is the lowest and discard that one, ending up with a final hand vector that is 5 elements and that meets the max_hand_size =5 . I saw in another post that you can also discard before you add, but that seems to complicate things a bit, so just wanted to check if adding and then discarding is also valid. Tahnks",
    "answers": [
      "Running the add_card function requires that you have less than MAX_HAND_SIZE cards as part of the invariant, so running it before discard is probably not the best approach. You can discard before adding without complicating things too much."
    ]
  },
  {
    "question": "project_I have a  query about how the autograder uses the test cases we write. Are these test cases just for us to check our code for bugs or are these actually used by the autograder for grading?  In a scenario, where my code implementation is correct but I write an incorrect test case ( i.e. expected output and actual do not match ) but actual output is correct, would the autograder deduct points?  I am trying to understand how the test cases I write are used by the autograder.",
    "answers": [
      "The autograder grades your test cases in two ways:\n\n1. seeing if they can catch the bugs against the autograder's buggy implementations (Ex of this on AG is \"Mutation Testing Suites\")\n\n2. against your own code (Ex of this on AG is \"Student Card tests on Student Card\")\n\nTherefore, to get full points, you need to have test cases that produce correct output, as well as code that passes your own test cases!"
    ]
  },
  {
    "question": "project_Hi,  I was wondering when checking the command line arguments in euchre.cpp, would we have to account for situations where the type of the argument is not the expected type? For example, if the input is:  ./euchre.exe noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple pack .in  My code currently assumes that the fourth argument is an integer, and the above input causes an error but does not cause the error message (that was specified in the spec) to print. I was wondering if we need to account for cases like this, or if we just need to check for the 4 errors that are in the project spec.  There are exactly 12 arguments, including the executable name.  Points to win the game is between 1 and 100, inclusive.  The shuffle argument is either shuffle or noshuffle.  The types of each of the players are either Simple or Human.  Any help is appreciated. Thank you!",
    "answers": [
      "The project spec tells you exactly what to account for. Assuming this is the same as previous projects, you wouldn't have to worry about anything else and can assume that the user inputs things correctly, just like the rest of the project!"
    ]
  },
  {
    "question": "project_Hi,   In my euchre.cpp I didn't do a shuffle() function but instead just did a if-then statement that would call the shuffle function in pack.cpp to shuffle the deck depending on the input. However, the shuffle does not seem to work properly with test01. The deck does get shuffled, but in a different order than it is supposed to (I think). My code passes test 00 and the checkpoints to Pack.cpp, so I'm just wondering why it is not working with euchre.cpp.     Thank you!",
    "answers": [
      "I had a similar problem until I realized I was not adding and discarding after making trump if that helps. If not, you can also make a print function for pack and print pack before every hand and deal yourself manually from the pack that prints and see if it matches the hands in the spec for the players."
    ]
  },
  {
    "question": "project_What might be the reason that when I run euchre cpp in human player mode, sometimes the order of the card in each player's hand will change?",
    "answers": [
      "could it be your shuffle function?\n\ndo you mean in across a single run of the program or across multiple runs of the program?",
      "#631"
    ]
  },
  {
    "question": "project_What's the difference between euchre public tests and euchre public tests with card? My implementation is passing with cards, but not the regular one.",
    "answers": [
      "See P3 FAQ!"
    ]
  },
  {
    "question": "project_Hi, I am really confused. I use debugger to check my function. what might be the reason that some player have correct card order and some do not?",
    "answers": [
      "could it be your shuffle function?",
      "When are you reordering your cards so that they print correctly? I find it helpful to reorder them 1) after all of the cards are dealt, and 2) whenever you add a new card to your hand. Don't forget those special cases when a dealer picks up a card!",
      "Took a look at your AG- looks like the issue is in sorting the cards. make sure you are sorting the hand any time the hand is modified."
    ]
  },
  {
    "question": "project_Basically the title, but why does the pack.in argument exist? Isn't every deck always going to be the four suits of 9, 10, J, Q, K, A?  Or are there other rules with modified decks?",
    "answers": [
      "While I'm not a Euchre expert, I believe the game is always played with a pack stripped down to 24 cards. The benefits of reading in a pack from input is that you can have some random ordering of those 24 cards. Imagine a world where we only had the default Pack constructor, even with shuffling, the order of the cards would be deterministic, leading to great predictability and a not-that-fun game. However, with this custom constructor that reads from an input stream, you can actually change the order of the cards in the file, and thus, how they will be dealt later on."
    ]
  },
  {
    "question": "project_My files pass the test cases when all of my files are run together, but when solution files are provided, my euchre.cpp fails the test cases. I suspect that there is probably a print statement within my player.cpp that is supposed to be in euchre.cpp or vice versa, but other than combing through every function detailed in the spec, I was wondering if there was a more direct method to debug or find out which errors were returned by the test cases with the provided solution files as the autograder does not give any more info other than that I failed the test cases.",
    "answers": [
      "You are correct in that there are print statements in player.cpp that should be in euchre.cpp. I would look through your player.cpp to make sure you are not printing anything in there as all printing should be handled by euchre.cpp."
    ]
  },
  {
    "question": "project_For game, I had my game function take all the arguments and store that in the game class. However, it's telling me this is too many arguments. Should I instead make different functions that set different things? Like a function that sets the players for example.",
    "answers": [
      "What is telling you that there are too many arguments? Is it the autograder? If so, yes, it's good practice to break things up into different functions."
    ]
  },
  {
    "question": "project_How does this point system work in Euchre?   The extent of my knowledge is that if someone within a pair wins a trick, then they get a point for their pair. Then, the pair with the highest amount of points win.  However, I know there are contingencies, but it is unclear how many there are and what we have to account for. Can someone explain the point system for Euchre please and thank you!",
    "answers": [
      "Here's an example with Team A and B.\n\nIf team A scored more points than team B\n\nIf they ordered up the trump card\n\nif they won all five tricks: 2 points (and this is a \"march\")\n\nIf they won 3+ tricks: 1 point\n\nIf they did not order the trump card\n\nThey get 2 points (team B got \"euchred\")\n\n\n\nVice versa for team B. (Sorry if I made a mistake in here)"
    ]
  },
  {
    "question": "project_Hi, I just submitted code to the autograder and it isn't compiling despite working just fine on VS code. If it makes a difference I'm running with the sanitizer. When I submitted, I got the following errors for Player.cpp (and more like them this is only a portion). What am I doing wrong?  Player.cpp:6:1: error: \u2018HumanPlayer\u2019 does not name a type     6 | HumanPlayer::HumanPlayer(const std::string& name) {       | ^~~~~~~~~~~ Player.cpp:13:1: error: \u2018SimplePlayer\u2019 does not name a type    13 | SimplePlayer::SimplePlayer(const std::string& name) {       | ^~~~~~~~~~~~ Player.cpp:20:20: error: \u2018HumanPlayer\u2019 has not been declared    20 | const std::string& HumanPlayer::get_name() const {       |                    ^~~~~~~~~~~ Player.cpp:20:44: error: non-member function \u2018const std::string& get_name()\u2019 cannot have cv-qualifier    20 | const std::string& HumanPlayer::get_name() const {       |                                            ^~~~~ Player.cpp: In function \u2018const std::string& get_name()\u2019: Player.cpp:21:16: error: \u2018player_name\u2019 was not declared in this scope    21 |         return player_name;       |                ^~~~~~~~~~~ Player.cpp: At global scope: Player.cpp:24:20: error: \u2018SimplePlayer\u2019 has not been declared    24 | const std::string& SimplePlayer::get_name() const {       |                    ^~~~~~~~~~~~",
    "answers": [
      "#505"
    ]
  },
  {
    "question": "project_Hello, when implementing game class and main in euchre.cpp, should we include a destructor. I know we manually free the memory at the end per the project spec, so technically a destructor wouldn't be needed, right? I'm just a bit confused because the player class in player.hpp had one. Thanks",
    "answers": [
      "only include a destructor for game if the default one is not enough. For example, if you had player pointers which were dynamically allocated as member variables (ie. you called new in the constructor), you would need a destructor to free that memory."
    ]
  },
  {
    "question": "project_Hi, where should the game class functions be implemented? Outside or inside the game class definition? Since there is no .hpp file I am bit confused. Like this functions:  void shuffle(); void deal(/* ... */); void make_trump(/* ... */); void play_hand(/* ... */);     Also, so The /*...*/ refer to parameters that we need to include that each each function takes?  Thanks",
    "answers": [
      "You can implement them right in the class. Also yeah the  /*...*/ is just potential parameters for each function"
    ]
  },
  {
    "question": "project_How should we test our Game class in order to best prepare for the private cases? We already have all our unit testing for the other classes like Card, Player, and Pack and have passed the autograder tests so far, but want to further test our code to make sure the game functions properly. All of our functions in the Game class are private so we wouldn't be able to test them so the only public function we could use would just be our general play() function that just runs through the entire game.   Is there any way we could further test our code, or is passing the public tests enough?    Thanks.",
    "answers": [
      "I think if you make your own correct implementation for a certain scenario and put it in an out file you can test in the same way you did for the others.",
      "I think it\u2019s useful to play with a shuffled pack with 3 simple players and one human player that you control. that way, you can change the cards you play and make sure the game behaves as it should, while still testing the simple player."
    ]
  },
  {
    "question": "project_Hi, i just want to double check do we need to consider the case when a human player wrongly orders up a suit that is not the upcard's suit in round 1? For instance, if the upcard is a diamond, but in round one a human player tries to input \"Hearts\", should we regard this as the human player passes, or reprompt for a correct input? Or should we just assume that they know the rules?",
    "answers": [
      "You can just assume that they know the rules"
    ]
  },
  {
    "question": "project_Hi, how does the game work in terms of shuffling. If the argument is shuffle (and not noshuffle) is the pack shuffled once at the start of the game or every hand?",
    "answers": [
      "at the start of every hand"
    ]
  },
  {
    "question": "project_Hi,  When testing with output files and diff checker with terminal, the output appears the exact same, however in autograder, one of the tests (01) is giving an error. Given the terminal output is exactly as expected, I can only assume that the error is either:  1. A whitespace error (although diff checker shows no errors; perhaps something with endl vs \\n?)  2. Something I have in my card, player, pack which is not in the solution files because it should be in my euchre.cpp.  Either way, I'm not sure to go about the best way of debugging this, as we cannot see the output on autograder? Any tips for solving this issue?",
    "answers": [
      "I assume you\u2019re failing the euchre.cpp with solution card, pack and player tests. this means that when card, pack and player are all correct, your euchre file produces incorrect output. this is usually due to the fact that you are printing output in the wrong file (ie. calling print hand in euchre.cpp instead of player.cpp)"
    ]
  },
  {
    "question": "project_Hi, I noticed that each time I play, I am always getting the same upcards to start off the game. Is this normal or is there something wrong with my code?",
    "answers": [
      "This is expected. Our shuffle function is not random, and all the provided public tests read the pack from the pack.in file. To get different upcards, you\u2019d have to start with a different pack file."
    ]
  },
  {
    "question": "project_Hi, Should we always write helper function as private function? And should I write RME for helpers?",
    "answers": [
      "It depends on which file you are referring to. If you are referring to euchre.cpp, it's up to you. If you are referring to other files, you should think about if you write helper function as private function, do you need to modify the corresponding .h file? If so, you can't, because you are not turning in .h file to AG. Also, check the second Requirements and Restrictions from the spec.\n\nRME for helpers - good practice but not required for grading."
    ]
  },
  {
    "question": "project_I have tried many times on modifying player_test cpp and considered many edge cases, but still cannot get full credit. Are there any suggestions? Thanks.",
    "answers": [
      "I'd say go through the spec to make sure you are testing every possible edge case. That's what worked for me.",
      "test the left bower (leading, playing, add and discard)\n\nspecifically, in situations where playing/leading/adding another card could be seen as the better option when examining rank alone, but the correct choice is the bower\n\ntest when a player has all trump (leading/playing)\n\ntest when a player has no trump (leading/playing)\n\ntests the conventions of \"following suit\"\n\nwhat suit is the left bower considered to be?\n\nwhat card should the simple player play if they cannot follow suit?\n\ntest add and discard in both cases (adding, or keeping the original card)\n\ntest with trump and bowers\n\ntest make trump\n\nHopefully this helps. A lot of test cases are going to be concerning the bowers, but make sure you're testing all the functions you wrote in player.cpp\n\nand if all else fails, we have office hours today and tomorrow."
    ]
  },
  {
    "question": "project_For example, during round 2 of making trump, if the upcard is a diamond, and a player has one Jack of Hearts, would that be considered a face of the next suit (hearts -> order up) or is it a face first suit (diamonds -> can't order up)?   This is from the specs for round 2 of making trump \"They will order up if that would mean they have one or more cards that are either face or ace cards of the trump suit in their hand (the right and left bowers, and Q, K, A of the order-up suit).\" So from my example above, would the right bower in this case be Jack of Hearts, left bower is Jack of Diamonds?",
    "answers": [
      "In this case, hearts would be ordered up, so Jack of hearts would be the right bower.",
      "Youssef answered correctly, for given a trump suit, the right and left bower are also members of that suit. So if you are in Round 2 of making trump and the upcard is Diamonds (and the suit now being considered is Hearts), then yes, the Jack of Hearts (right bower) and Jack of Diamonds (left bower) would both be considered as face/ace cards that contribute."
    ]
  },
  {
    "question": "project_Hi, I have a code duplication for my deal function in euchre.cpp, Is there any good way to avoid this? I've been suggested to use loops, but I'm not sure how to actually go about it.",
    "answers": [
      "Put the duplicated code to a function and call it!"
    ]
  },
  {
    "question": "project_Can I create a new function for inside of Player.cpp? The autograder says that I have deep nesting and long functions which would be avoidable if I created a function that contained the for loops and if statements. If so, would i define the function within SimplePlayer class or outside of both classes?",
    "answers": [
      "yes!"
    ]
  },
  {
    "question": "project_As you can see below, that adi and chi-chih only have accumulated 3 points, so they should only get 1 points. But, why did it say that they have two points?    Test case 00 file:  Hand 0 Adi deals Jack of Diamonds turned up Barbara passes Chi-Chih passes Dabbala passes Adi passes Barbara orders up Hearts  Jack of Spades led by Barbara King of Spades played by Chi-Chih Ace of Spades played by Dabbala Nine of Diamonds played by Adi Dabbala takes the trick  King of Clubs led by Dabbala Ace of Clubs played by Adi Nine of Spades played by Barbara Jack of Clubs played by Chi-Chih Adi takes the trick  Ten of Diamonds led by Adi Ten of Spades played by Barbara Nine of Clubs played by Chi-Chih Queen of Clubs played by Dabbala Adi takes the trick  Jack of Hearts led by Adi Ace of Hearts played by Barbara Ten of Clubs played by Chi-Chih Ten of Hearts played by Dabbala Adi takes the trick  Queen of Hearts led by Adi King of Hearts played by Barbara Queen of Spades played by Chi-Chih Nine of Hearts played by Dabbala Barbara takes the trick  Adi and Chi-Chih win the hand euchred! Adi and Chi-Chih have 2 points Barbara and Dabbala have 0 points  Adi and Chi-Chih win!",
    "answers": [
      "When the a team orders up a suit, if the team that didn\u2019t order up the suit wins the hand by taking at least 3 tricks, they\u2019ve \u201ceuchred\u201d the other team and they get 2 points instead of 1.\n\nTo reiterate, the reason it\u2019s 2 points instead of one is that Adi\u2019s team won the hand when Barbara\u2019s team ordered up the suit."
    ]
  },
  {
    "question": "project_in our code, we always end up with different output but have no idea what is going wrong  it looks like our deal() gives wrong hands when shuffle = TRUE, no idea why, and feel like shuffle()  function in pack.cpp is correct ./euchre.exe pack.in shuffle 10 Edsger Simple Fran Simple Gabriel Simple Herb Simple could we get some hints?",
    "answers": [
      "It's difficult to tell without seeing your code. Some ideas for debugging would be\n\nCheck the ordering of your cards before and after the shuffle function. Make sure next is set to 0 after shuffling - if there's an error with your shuffle() function, you'll likely see an issue here.\n\nIf the cards are shuffled correctly, check which player is set to the dealer, and walk through the card dealing steps to see if your cards are being assigned in the correct order. \n\nIf your output is always changing, there might be some undefined behavior going on. Use autograder or address sanitizers to check for this.\n\nThe debugger will be the best way to identify the issue. If you can't figure it out, come to office hours for additional help!"
    ]
  },
  {
    "question": "project_When making card_less, if the ranks of the two cards are the same, how do you decide which one is greater than or less than in value? I know that the trump will be the greatest, but from there, what is the ranking of the suits.",
    "answers": [
      "If you're not considering the led card or the trump card, the ranking of suits is Diamonds > Clubs > Hearts > Spades!"
    ]
  },
  {
    "question": "project_Are we supposed to print out the players decision in the make_trump function for human player? or do we just modify the  order_up_suit only?",
    "answers": [
      "I think we're supposed to print the decision in euchre.cpp, since you print the decision for both simple players and human players. From the spec: \"output that is common to both Simple and Human Players should be printed by the Euchre Game driver\"",
      "Yes, as the other student said, since the output of their choice is independent of what type of player they are, it should be printed from your euchre driver."
    ]
  },
  {
    "question": "project_For the euchre driver program, after hand 0 concludes and hand 1 is dealt, all of the cards to be dealt become the two of spades. I think that this is because of an issue with closing/reopening the input stream, but I'm not sure how to correct it.",
    "answers": [
      "If you recall, there's a function inside Pack.cpp that allows you to reset the pack. Can you think of a way you can utilize that function? You don't have to reopen the input stream."
    ]
  },
  {
    "question": "project_For the hand zero in test 01, edsgar played one card that is not supposed to be on his hand, and this problem still exist after I modified the shuffle so that it reads all card from pack.",
    "answers": [
      "If anyone makes trump in the first round, the dealer (Edsger) picks up the upcard (nine of hearts) and discards one of the cards in their hand. This is done using the helper function add_and_discard"
    ]
  },
  {
    "question": "project_Hi, are we allowed to write helper functions in Player.cpp (as private functions)? I think no need to modify Player.hpp in this case? Thanks",
    "answers": [
      "Yes, just make sure to not modify the .hpp file."
    ]
  },
  {
    "question": "project_Does anyone know what the final card deck order is supposed to be after shuffling? currently trying to debug for euchre_test01 and I keep turning up the nine of diamonds instead of nine of hearts after dealing. I'm trying to write individual test cases for pack so if anyone knows the order that would be very helpful!",
    "answers": [
      "A good way to test your shuffle function is to call shuffle() on the pack 20 times- this should make the pack equal to the order of the original pack before shuffling."
    ]
  },
  {
    "question": "project_My partner and I have been attempting to debug this for a while, but we can't figure out what's going wrong for Hand 9 in euchre_test01. It looks like Gabriel is playing the three cards that he's supposed to, but in the wrong order (Queen of Diamonds, Nine of Clubs, Ten of Clubs instead of Nine of Clubs, Ten of Clubs, Queen of Diamonds)    Because the Jack of Clubs, which is led by Fran, is the left bower, should we be treating the led suit as if it were spades? We attempted to change which version of get_suit we use but when we use get_suit(trump) we end up seeing even more output differences.  Can we please get a hint on where we might be going wrong? Thank you so much!",
    "answers": [
      "Because the Jack of Clubs, which is led by Fran, is the left bower, should we be treating the led suit as if it were spades? We attempted to change which version of get_suit we use but when we use get_suit(trump) we end up seeing even more output differences.\n\nYes, Fran is leading with spades as the led suit because the jack of clubs is the left bower. You should change the version of get_suit you use in the play_card and lead_card functions (always consider the LB as part of the trump suit when trump is decided). Unfortunately, the other issues you are getting as a result of this were probably separate issues that haven't come up until now."
    ]
  },
  {
    "question": "project_In Player.cpp several of our functions had too much nesting, so we wrote helper functions to help with that. Since these helper functions were all in SimplePlayer, do we need to make them static or any type of other notation (like const, etc)? They are public functions in SimplePlayer. Also, for the parameters for these helper functions, should we pass them in by reference or const (since other given Player functions do not)? Thanks!",
    "answers": [
      "They should be private member functions, or static, out of class helper functions. All other design choices are up to you. Conventionally we will pass an object by const reference if it is large to avoid making a copy."
    ]
  },
  {
    "question": "project_Managed to get the correct output for both the Euchre00 and the Euchre01 Simple Player tests, word for word, player for player, card for card. After compiling, I noticed a random segmentation fault when I ran ./euchre.exe pack.in shuffle 10 Edsger Simple Fran Simple Gabriel Simple Herb Simple> output. I kept running this command without recompiling it to try and recreate this error, but I could only do so about once every hundred or so times. Every other time it would work perfectly fine and return the correct output. There's no pattern to it, and I believe I set up the sanitizer correctly, but it isn't telling me anything either. Anyone have any ideas on what could be happening here?",
    "answers": [
      "I would take a look at the AG for guidance here- looks like you're getting some undefined behavior. Specifically, you're indexing with an index of -1. In player.cpp, you set an index to -1 in a few cases. I think there are some cases in your code where the index is not set to another value before being used."
    ]
  },
  {
    "question": "project_Hi, is there any tip or hint as to how to check that the number of points is between 1 and 100. I'm having trouble because the argument is a string so I don't know how I could compare it to an int.  Thanks",
    "answers": [
      "Convert the string to an int first, then do the comparison."
    ]
  },
  {
    "question": "project_Are the style checks shown in the autograder the only styles that are being checked? If we get full marks on all the style checks after submitting, can we assume that there are no further style problems with the code and we will receive full points for that portion when the final grade comes out?",
    "answers": [
      "For style checks, what you see is what you get."
    ]
  },
  {
    "question": "project_The order of our pack after shuffling is incorrect. Cards 9 and 19 are switched, while the rest of the pack is in order. We verified that the order of cards during pack_in is correct, and Pack.cpp passes all public and private tests.   Is there any reason why these specific cards might be out of order?",
    "answers": [
      "It's difficult to say without looking at your code. I would try examining your shuffle function using the visual debugger. If you've already tried that, come to office hours or make a private post with your code."
    ]
  },
  {
    "question": "project_Hello, I did my code but I didn't need to use pack.reset() or pack.empty() that I implemnted as specified in pack.cpp. I am afraid I might have not understood part of the game and you need to reset the pack somewhere (for example). Any help? Thanks",
    "answers": [
      "You should be resetting the pack between every hand because cards are re-shuffled (as per the shuffle/noshuffle argument) and re-dealt at the beginning of every hand."
    ]
  },
  {
    "question": "project_I am not sure what parameters to include for the make_trump member function in the game class. I am just unsure because we already have a make_trump function in the player.cpp implementation so how would these two functions differ in terms of implementation if they do the same thing? I am thinking that they should have the same arguments but i wanted to confirm.",
    "answers": [
      "Remember, the design of Game::make_trump is completely up to you! One thing to consider is that Player::make_trump will be called for every single Player at your table until someone orders up (for up to two rounds). Thus, it might make sense to put those (potential) 8 function calls into the Game::make_trump function. This is also a great place to add the cout statements for when someone passes/orders up (see the euchre_test00.out.correct for an example of you need to output). Does this help?"
    ]
  },
  {
    "question": "project_When I ran test 01 in the terminal and checked the output with the correct output it showed there was an error, however when I submitted it to the autograder it passed the test, is there a reason this could happen?",
    "answers": [
      "Your executable might have not been up to date?"
    ]
  },
  {
    "question": "project_In the autograder, we are failing the style checks, for  few different things.   1) we are failing long function in card, it it says it's 49/40, but when we check it ourselves, it is 41/40, so we are wondering what counts towards this?  2) we are also failing deep nesting, and we're a little confused, because we have max of 4 nested loop, and we are assuming that this means how loops there are stacked? but we were wondering if it means like all of the loops on the same stack inside another loop(eg. for, then if statement insides, compared to a for loop with multiple if statements insides  3) we are also falling code dupilication because of card less, are we are wondering if we are supposed to call the card less(a,b,trump) inside of the card less (a,b,led, trump)? otherwise we are a little confused how to go about this?",
    "answers": [
      "1. Not sure about what counts towards this, but I would recommend maybe moving some code into separate helper functions.\n\n2. Hmmm, I'm not sure if I answering what you're asking, but nesting means that within the curly braces of a loop, you have created another loop, for example:\n\nfor (...) {\n    for (...) {\n        for (...) {\n            \\\\ this is an example of 3 nested loops!\n        }\n    }\n}\n\n3.  Yes, the logic for Card less (a, b, trump) is reusable so you can call it from inside Card less (a, b, led,trump) !"
    ]
  },
  {
    "question": "project_In the spec sheet, it says a test file cannot have more than 50 test cases. Will I lose points if my player_tests.cpp file has more than 50 test cases? Is one test case considred to be one ASSERTION statement?",
    "answers": [
      "I would follow what the spec sheet is for best practice, but I cannot say for sure if you will lose points for not. Hmmm, I would call one test function a test case, rather than every ASSERTION."
    ]
  },
  {
    "question": "project_The order of our pack after shuffling is incorrect. Cards 9 and 19 are switched, while the rest of the pack is in order. We verified that the order of cards during pack_in is correct, and Pack.cpp passes all public and private tests.   Is there any reason why these specific cards might be out of order? This is our code for shuffle:       Card shuffle[PACK_SIZE];  \u00a0 \u00a0 for(int j = 0; j < 7; j++) \u00a0 \u00a0 { \u00a0 \u00a0 \u00a0 \u00a0 for (int i = 0; i < PACK_SIZE/2; i+=1) \u00a0 \u00a0 \u00a0 \u00a0 { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 shuffle[i * 2] = cards[i + (PACK_SIZE / 2)]; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 shuffle[i*2 +1] = cards[i]; \u00a0 \u00a0 \u00a0 \u00a0 }  \u00a0 \u00a0 \u00a0 \u00a0 for(int i = 0; i < PACK_SIZE; i++) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cards[i] = shuffle[i]; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } \u00a0 \u00a0 } \u00a0 \u00a0  \u00a0 \u00a0 next = 0;",
    "answers": [
      "Hmmm, your code looks pretty good to me after a quick glance. One question I have: is this causing you to fail the tests later on, specifically for the euchre.cpp driver? I ran this function locally in lieu of my own and everything seems to work correctly. I get the same ordering by running your function as compared to my own.  How did you come to determine that Card 9 and 19 are switched?"
    ]
  },
  {
    "question": "project_Literally had no problem up until today. We failed one of the public test cases so we made edits to the code, and it passed on our laptops. When we submitted it to autograder, it did not compile at all, even though it compiles and passes on vs code without an issue.",
    "answers": [
      "Look at the lines and compilation issues that the AG highlights. Check out those spots in your code and see if the actual issues exist. Verify that the copy you submitted to AG matches the copy that you have locally.",
      "There were no warnings or errors when running on vs code. Is there anyway to reset the vs code compiler? Any changes we made just ended up still having the code run and work. Tried to deleting the .exe file and doing make and ./ and it still ends up the same."
    ]
  },
  {
    "question": "project_Hello. I have a similar issue to another anonymous post where one wrong card is played in Hand 0 (when Edsger is supposed to play Nine of Hearts, he plays Ten of Diamonds in my program). I attended office hours yesterday and was told that my add_and_discard function is correctly implemented, so I have no idea what is wrong with my make_trump function that is causing incorrect gameplay. Are there any logic errors in my implementation that I haven't addressed?: Suit make_trump() {     int eldest = (dealer_index + 1) % 4;     bool is_dealer;      // first round     for (int i = 0; i < 4; ++i) {         int player_index = (eldest + i) % 4;         is_dealer = (player_index == dealer_index);         order_up_suit = upcard.get_suit();                  if (get_player(player_index)->make_trump(upcard,              is_dealer, 1, order_up_suit)) {             if (is_dealer) {                 get_player(dealer_index)->add_and_discard(upcard);             }             cout << get_player(player_index)->get_name()              << \" orders up \" << order_up_suit << endl << endl;             if (player_index % 2 == 0) {                 the_maker = 1;             } else {                 the_maker = 2;             }                         trump = order_up_suit;             return order_up_suit;         } else {             cout << get_player(player_index)->get_name()              << \" passes\" << endl;         }     }      // second round      for (int i = 0; i < 4; ++i) {         int player_index = (eldest + i) % 4;         is_dealer = (player_index == dealer_index);                  if (get_player(player_index)->make_trump(upcard,              is_dealer, 2, order_up_suit)) {             cout << get_player(player_index)->get_name()              << \" orders up \" << order_up_suit << endl << endl;             if (player_index % 2 == 0) {                 the_maker = 1;             } else {                 the_maker = 2;             }             trump = order_up_suit;             return order_up_suit;         } else {             cout << get_player(player_index)->get_name()              << \" passes\" << endl;         }     }     return order_up_suit; }",
    "answers": [
      "Your issue is because you are only adding and discarding if the current player is the dealer (ie. the dealer orders up in the first round). If ANY player orders up during the first round, the dealer has the option to add the upcard and discard a card.\n\nhere's the line you need to fix:\n\n if (is_dealer) {\n\n     get_player(dealer_index)->add_and_discard(upcard);\n\n }"
    ]
  },
  {
    "question": "project_My output: Ten of Diamonds led by Adi Ten of Spades played by Barbara Nine of Clubs played by Chi-Chih Nine of Hearts played by Dabbala Dabbala takes the trick  Correct output:  Ten of Diamonds led by Adi Ten of Spades played by Barbara Nine of Clubs played by Chi-Chih Queen of Clubs played by Dabbala Adi takes the trick  At time of playing, Dabbala has 9 of hearts, 10 of hearts, and queen of clubs. Trump suit is hearts and led suit is diamonds. According to simple player strategy, they should not consider trump and only consider the led card. Dabbala can't follow suit here, they should play the lowest card in their hand. I am (potentially incorrectly) interpreting this as a pure relational comparison of their ranks (9 of hearts < queen of clubs). Regardless of comparing suit or rank, 9 of hearts is definitively lower given (A > K > Q > J > 10 > 9), with ties broken by suit (D > C > H > S).  What am I missing here? Why is it that Queen of Clubs is the correct move here? The only thing I can think of is if somehow my hands have been dealt incorrectly, but the rest of my output preceding this point is correct. Thanks!",
    "answers": [
      "simple player strategy does not entirely ignore trump; if they cannot follow suit, they play the actual lowest card in their hand. according to the rules of the game, every trump card is greater than every other card."
    ]
  },
  {
    "question": "project_Does the long functions style check include lines that don't have code in them? ie. just empty lines",
    "answers": [
      "No, it will only count lines with code in them, at least from what I can see, along with in the error it will say \"non-commenting source statements\", so it should only count lines that actually have code in them."
    ]
  },
  {
    "question": "project_hi! is there any way to see if our tests return a false positive / number of bugs we expose before putting it into autograder?  follow up: if we get full points for the test cases but want to expose more bugs (to ensure we pass private tests), will we get points deducted if we have a false positive even though we have 14/14 bugs exposed without the false positive?",
    "answers": [
      "No points are deducted for false positives, but the test case that contains a false positive will not contribute to catching bugs on the autograder (because the test case is invalid)"
    ]
  },
  {
    "question": "project_If the ai doesnt have card of type led card, then should it play the highest trump card it has and then if not the lowest possible card they have or should they go right to the last option?  Thank you.",
    "answers": [
      "It should go right to the last option, so play the lowest possible card."
    ]
  },
  {
    "question": "project_I made my last submission to the autograder and it said, Core tests finished. You can submit again now! Are we supposed to make another submission or will the private tests get graded automatically?",
    "answers": [
      "The private tests will get graded automatically"
    ]
  },
  {
    "question": "project_If so, then how likely is that? And how \"poorly\" would you have had to write your code for that to happen?  I didn't write any of my own test cases for the driver, by the way... I only heard after that that it was probably a good idea to test the euchre.cpp...",
    "answers": [
      "I believe that's very unlikely, def still possible, but you should likely be okay"
    ]
  },
  {
    "question": "project_When will private test scores be released? I was under the impression that they are released right after the deadline.",
    "answers": [
      "They've been released. They're usually released the morning after."
    ]
  },
  {
    "question": "project_I got my final score back for project 3 and I see that my most recent submission was the one scored instead of an older one which had a higher grade on the autograder. I was under the impression that the highest submission was graded and not the most recent one. Am i missing something?",
    "answers": [
      "The final graded submission is the one that has your highest public + private test score. So that means your older submission that had a higher public test grade on the autograder probably had a lower total score."
    ]
  },
  {
    "question": "project_I reviewed our private test scores and got points deducted in Player private, HumanPlayer private, and Euchre private. There is no details about the output I guess for the project reuse purposes, so I am just really curious about and want to reflect kn which exactly part that we have issues in .",
    "answers": [
      "There's most likely some edge case error in your Player/HumanPlayer. Beyond that, I'd suggest going to Proffice hours to discuss this with a professor as they are the only ones who can view the private test case output."
    ]
  }
]